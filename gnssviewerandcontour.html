<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPS Coordinates Visualizer - Advanced</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .controls {
            padding: 20px 30px;
            background: rgba(52, 152, 219, 0.05);
            border-bottom: 1px solid rgba(52, 152, 219, 0.1);
        }

        .input-methods {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .method-tabs {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .tab-btn {
            padding: 12px 24px;
            background: white;
            border: 2px solid #3498db;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            color: #3498db;
        }

        .tab-btn.active {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .tab-btn:hover:not(.active) {
            background: rgba(52, 152, 219, 0.1);
        }

        .input-method {
            display: none;
        }

        .input-method.active {
            display: block;
        }

        .input-method input[type="file"] {
            padding: 12px;
            border: 2px dashed #3498db;
            border-radius: 10px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        .input-method input[type="file"]:hover {
            border-color: #2980b9;
            background: rgba(52, 152, 219, 0.05);
        }

        #csvPaste {
            width: 100%;
            padding: 15px;
            border: 2px solid #3498db;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
            min-height: 120px;
            transition: border-color 0.3s ease;
        }

        #csvPaste:focus {
            outline: none;
            border-color: #2980b9;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .process-btn {
            margin-top: 10px;
            padding: 12px 24px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .process-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(52, 152, 219, 0.3);
        }

        .visualization-controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .viz-btn {
            padding: 12px 20px;
            background: linear-gradient(135deg, #8e44ad, #9b59b6);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            justify-content: center;
            min-width: 140px;
        }

        .viz-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(142, 68, 173, 0.3);
        }

        .viz-btn.active {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
        }

        .btn-icon {
            font-size: 1.2em;
        }

        .load-sample {
            padding: 12px 24px;
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .load-sample:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(46, 204, 113, 0.3);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 0;
            min-height: 700px;
        }

        .map-container {
            position: relative;
            background: #ecf0f1;
            border-right: 2px solid #ddd;
        }

        #map {
            height: 700px;
            width: 100%;
        }
        
        .viewer-container {
            position: relative;
            background: #f8f9fa;
            border-right: 2px solid #ddd;
            display: flex;
            flex-direction: column;
        }
        
        .viewer-container h3 {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            padding: 15px;
            margin: 0;
            font-size: 1.2rem;
            font-weight: 500;
            text-align: center;
        }
        
        #groundSurface3DMain {
            flex: 1;
            background: #e0e8f0;
        }
        
        .viewer-controls {
            background: white;
            padding: 15px;
            border-top: 2px solid #ddd;
        }

        .drawing-instructions {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: none;
            font-weight: 500;
            color: #2c3e50;
        }

        .drawing-instructions.active {
            display: block;
        }

        .data-panel {
            padding: 30px;
            background: white;
            overflow-y: auto;
            max-height: 700px;
        }
        
        .contour-map-section {
            background: white;
            padding: 20px;
            margin: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .contour-map-section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.5rem;
            font-weight: 300;
            text-align: center;
        }
        
        #contourMap {
            height: 500px;
            width: 100%;
            border-radius: 10px;
            border: 2px solid #ddd;
        }
        
        .contour-map-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .data-panel h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 300;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid rgba(52, 152, 219, 0.1);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #7f8c8d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .slider-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .slider-section h4 {
            margin-bottom: 15px;
            color: #2c3e50;
            font-size: 1.1rem;
        }

        .slider-control {
            margin-bottom: 15px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
            color: #555;
        }

        .slider-value {
            font-weight: bold;
            color: #3498db;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #2980b9;
            transform: scale(1.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            border: none;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .data-table th {
            background: linear-gradient(135deg, #34495e, #2c3e50);
            color: white;
            padding: 15px 10px;
            text-align: left;
            font-weight: 500;
            font-size: 0.9rem;
        }

        .data-table td {
            padding: 12px 10px;
            border-bottom: 1px solid #ecf0f1;
            font-size: 0.85rem;
        }

        .data-table tr:hover {
            background: rgba(52, 152, 219, 0.05);
        }

        .data-table tr:nth-child(even) {
            background: rgba(248, 249, 250, 0.5);
        }

        .cross-section-panel {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .cross-section-panel.active {
            display: flex;
        }
        
        .cross-section-content {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.3);
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .cross-section-header {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 15px 15px 0 0;
            flex-shrink: 0;
        }

        .cross-section-header h3 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 300;
        }
        
        .cross-section-body {
            padding: 30px;
            overflow-y: auto;
            flex: 1;
        }

        .close-cross-section {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            color: white;
            padding: 8px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .close-cross-section:hover {
            background: white;
            color: #3498db;
        }

        #crossSectionChart {
            width: 100% !important;
            height: 600px !important;
        }

        .marker-info {
            font-family: 'Segoe UI', sans-serif;
        }

        .marker-info h4 {
            margin: 0 0 10px 0;
            color: #2c3e50;
        }

        .marker-info p {
            margin: 5px 0;
            font-size: 0.9rem;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
        }

        .error {
            background: #e74c3c;
            color: white;
            padding: 15px;
            margin: 20px 30px;
            border-radius: 10px;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .data-panel {
                max-height: none;
            }
        }

        @media (max-width: 768px) {
            .method-tabs {
                flex-direction: column;
                align-items: stretch;
            }

            .header h1 {
                font-size: 2rem;
            }

            .stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>GPS Coordinates Visualizer - Advanced</h1>
            <p>Interactive mapping with heatmaps, contours, and cross-section analysis</p>
        </div>

        <div class="controls">
            <div class="input-methods">
                <div class="method-tabs">
                    <button class="tab-btn active" onclick="switchTab('file')">Upload File</button>
                    <button class="tab-btn" onclick="switchTab('paste')">Paste Data</button>
                    <button class="load-sample" onclick="loadSampleData()">Load Sample Data</button>
                </div>

                <div id="fileTab" class="input-method active">
                    <input type="file" id="csvFile" accept=".csv,.xlsx,.xls" placeholder="Choose CSV or Excel file...">
                </div>

                <div id="pasteTab" class="input-method">
                    <textarea id="csvPaste" placeholder="Paste your data here...&#10;&#10;Supports:&#10;‚Ä¢ CSV format with headers&#10;‚Ä¢ Space-separated data (like your survey output)&#10;‚Ä¢ Tab-separated data&#10;&#10;Example:&#10;1 322965.3 6279430 33.837 gcp 115.0918 -33.6102..." rows="8"></textarea>
                    <button class="process-btn" onclick="processPastedData()">Process Data</button>
                </div>
            </div>
        </div>

        <div class="main-content">
            <!-- Column 1: Map -->
            <div class="map-container">
                <div id="map"></div>
                <div class="drawing-instructions" id="drawingInstructions">
                    Click on map to draw cross-section line. Click again to finish.
                </div>
            </div>

            <!-- Column 2: 3D Viewer -->
            <div class="viewer-container">
                <h3>üèîÔ∏è 3D Ground Surface (Kriging)</h3>
                <div id="groundSurface3DMain"></div>
                <div class="viewer-controls">
                    <div style="font-size: 11px; color: #666; margin-bottom: 8px;">
                        <strong>Mouse:</strong> Left=Rotate | Right=Pan | Scroll=Zoom
                    </div>
                    <div style="display: flex; gap: 5px; margin-bottom: 8px; flex-wrap: wrap;">
                        <button class="view-btn" onclick="reset3DGroundView()">Reset</button>
                        <button class="view-btn" onclick="setTop3DGroundView()">Top</button>
                        <button class="view-btn" onclick="setSide3DGroundView()">Side</button>
                        <button class="view-btn" style="background: linear-gradient(135deg, #0066cc 0%, #004080 100%);" onclick="setNorth3DGroundView()">N</button>
                        <button class="view-btn" style="background: linear-gradient(135deg, #0066cc 0%, #004080 100%);" onclick="setSouth3DGroundView()">S</button>
                        <button class="view-btn" style="background: linear-gradient(135deg, #0066cc 0%, #004080 100%);" onclick="setEast3DGroundView()">E</button>
                        <button class="view-btn" style="background: linear-gradient(135deg, #0066cc 0%, #004080 100%);" onclick="setWest3DGroundView()">W</button>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; font-size: 10px;">
                        <label style="cursor: pointer;">
                            <input type="checkbox" id="show3DPoints" checked onchange="render3DGroundSurface()"> Points
                        </label>
                        <label style="cursor: pointer;">
                            <input type="checkbox" id="show3DWireframe" checked onchange="render3DGroundSurface()"> Wireframe
                        </label>
                    </div>
                </div>
            </div>

            <!-- Column 3: Controls -->
            <div class="data-panel">
                <h3>Survey Data & Controls</h3>
                <div class="stats" id="stats">
                    <div class="stat-card">
                        <div class="stat-value" id="pointCount">0</div>
                        <div class="stat-label">Points</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avgElevation">0</div>
                        <div class="stat-label">Avg Elevation</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avgRMS">0</div>
                        <div class="stat-label">Avg RMS</div>
                    </div>
                </div>

                <div class="visualization-controls">
                    <button class="viz-btn" onclick="toggleHeatmap()" id="heatmapBtn">
                        <span class="btn-icon">üî•</span>
                        Heatmap
                    </button>
                    <button class="viz-btn" onclick="toggleContours()" id="contourBtn">
                        <span class="btn-icon">üìä</span>
                        Contours
                    </button>
                    <button class="viz-btn" onclick="toggleTIN()" id="tinBtn">
                        <span class="btn-icon">üî∫</span>
                        TIN
                    </button>
                    <button class="viz-btn" onclick="startCrossSection()" id="crossSectionBtn">
                        <span class="btn-icon">üìè</span>
                        X-Section
                    </button>
                </div>

                <div class="slider-section">
                    <h4>Data Filters</h4>
                    
                    <div class="slider-control">
                        <div class="slider-label">
                            <span>Elevation Range</span>
                            <span class="slider-value" id="elevationValue">All</span>
                        </div>
                        <input type="range" id="elevationSlider" min="0" max="100" value="100" oninput="updateFilters()">
                    </div>

                    <div class="slider-control">
                        <div class="slider-label">
                            <span>RMS Threshold</span>
                            <span class="slider-value" id="rmsValue">All</span>
                        </div>
                        <input type="range" id="rmsSlider" min="0" max="100" value="100" oninput="updateFilters()">
                    </div>

                    <div class="slider-control">
                        <div class="slider-label">
                            <span>Marker Size</span>
                            <span class="slider-value" id="markerSizeValue">8</span>
                        </div>
                        <input type="range" id="markerSizeSlider" min="3" max="15" value="8" oninput="updateMarkerSize()">
                    </div>

                    <div class="slider-control">
                        <div class="slider-label">
                            <span>Heatmap Intensity</span>
                            <span class="slider-value" id="heatmapIntensityValue">0.6</span>
                        </div>
                        <input type="range" id="heatmapIntensitySlider" min="20" max="100" value="60" oninput="updateHeatmapIntensity()">
                    </div>

                    <div class="slider-control">
                        <div class="slider-label">
                            <span>Contour Interval (m)</span>
                            <span class="slider-value" id="contourIntervalValue">1</span>
                        </div>
                        <input type="range" id="contourIntervalSlider" min="0" max="10" value="4" oninput="updateContourInterval()">
                    </div>
                </div>

                <div class="slider-section" style="border: 2px solid #28a745;">
                    <h4 style="color: #28a745;">Kriging Parameters</h4>
                    
                    <div class="slider-control">
                        <div class="slider-label">
                            <span style="font-size: 11px;">Vertical Exaggeration</span>
                            <span class="slider-value" id="ground3DVertExagValue">2.0x</span>
                        </div>
                        <input type="range" id="ground3DVerticalExaggeration" min="0.5" max="10" step="0.5" value="2" 
                               style="width: 100%;" onchange="update3DGroundVerticalExaggeration(this.value)">
                    </div>
                            
                            <label style="font-size: 11px; display: block; margin-bottom: 5px;">
                                Surface Smoothness: <span id="krigingSmoothValue">20</span>
                            </label>
                            <input type="range" id="krigingSmooth" min="1" max="20" step="1" value="20" 
                                   style="width: 100%; margin-bottom: 8px;" onchange="updateKrigingSmooth(this.value)">
                            
                            <label style="font-size: 11px; display: block; margin-bottom: 5px;">
                                Grid Resolution: <span id="gridResolutionValue">200x200</span>
                            </label>
                            <input type="range" id="gridResolution" min="40" max="200" step="10" value="200" 
                                   style="width: 100%; margin-bottom: 8px;" onchange="updateGridResolution(this.value)">
                            
                            <label style="font-size: 11px; display: block; margin-bottom: 5px;">
                                Interpolation Power: <span id="interpPowerValue">5</span>
                            </label>
                            <input type="range" id="interpPower" min="0.5" max="5" step="0.1" value="5" 
                                   style="width: 100%; margin-bottom: 8px;" onchange="updateInterpPower(this.value)">
                            
                            <label style="font-size: 11px; display: block; margin-bottom: 5px;">
                                Nugget Effect: <span id="nuggetValue">0%</span>
                            </label>
                            <input type="range" id="nuggetEffect" min="0" max="30" step="1" value="0" 
                                   style="width: 100%; margin-bottom: 8px;" onchange="updateNugget(this.value)">
                            
                            <label style="font-size: 11px; display: block; margin-bottom: 5px;">
                                Influence Radius: <span id="influenceRadiusValue">5x</span>
                            </label>
                            <input type="range" id="influenceRadius" min="0.5" max="5" step="0.1" value="5" 
                                   style="width: 100%; margin-bottom: 8px;" onchange="updateInfluenceRadius(this.value)">
                            
                            <label style="font-size: 11px; display: block; margin-bottom: 5px;">
                                Gaussian Smoothing: <span id="gaussianSmoothValue">Very Heavy</span>
                            </label>
                            <input type="range" id="gaussianSmooth" min="0" max="5" step="1" value="5" 
                                   style="width: 100%; margin-bottom: 8px;" onchange="updateGaussianSmooth(this.value)">
                            
                            <label style="font-size: 11px; display: block; margin-bottom: 5px;">
                                <input type="checkbox" id="useSpline" onchange="render3DGroundSurface()"> Use Spline Interpolation
                            </label>
                            
                            <div style="font-size: 10px; color: #666; margin-top: 8px; line-height: 1.3;">
                                <strong>Tips:</strong> Smoothness (1=rough, 20=very smooth) ‚Ä¢ Resolution (40=fast, 200=ultra-detailed) ‚Ä¢ Power (0.5=gradual, 5=sharp) ‚Ä¢ Nugget (0=exact, 30%=loose) ‚Ä¢ Radius (0.5=local, 5=global) ‚Ä¢ Gaussian (0=none, 5=heavy blur)
                            </div>
                        </div>
                    </div>
                </div>

                <div id="dataContainer">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h4 style="margin: 0;">Survey Points Data</h4>
                        <label style="font-size: 12px; cursor: pointer;">
                            <input type="checkbox" id="showDataTable" checked onchange="toggleDataTable()"> Show Table
                        </label>
                    </div>
                    <div id="dataTableContainer">
                        <div class="loading">Load CSV data to view survey points</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Kriging-based Contour Map Section -->
        <div class="contour-map-section">
            <h3>üìä Kriging-Based Contour Map</h3>
            <div style="display: grid; grid-template-columns: 1fr 350px; gap: 20px;">
                <!-- Contour Map -->
                <div>
                    <div id="contourMap"></div>
                </div>
                
                <!-- Contour Controls Panel -->
                <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; border: 2px solid #3498db;">
                    <h4 style="color: #2c3e50; margin-bottom: 15px; font-size: 1.2rem;">Contour Controls</h4>
                    
                    <!-- Contour Interval -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 14px;">
                            Contour Interval
                        </label>
                        <select id="krigingContourInterval" onchange="updateKrigingContours()" 
                                style="width: 100%; padding: 8px 12px; border-radius: 5px; border: 2px solid #3498db; font-size: 14px;">
                            <option value="0.05">0.05m (Very Dense)</option>
                            <option value="0.1">0.1m (Dense)</option>
                            <option value="0.2">0.2m</option>
                            <option value="0.25">0.25m</option>
                            <option value="0.5" selected>0.5m (Default)</option>
                            <option value="1">1m</option>
                            <option value="2">2m</option>
                            <option value="5">5m (Sparse)</option>
                            <option value="10">10m (Very Sparse)</option>
                        </select>
                    </div>
                    
                    <!-- Line Style -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 14px;">
                            Line Weight: <span id="contourWeightValue">2.5px</span>
                        </label>
                        <input type="range" id="contourLineWeight" min="1" max="6" step="0.5" value="2.5" 
                               onchange="updateContourStyle()" style="width: 100%;">
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 14px;">
                            Line Opacity: <span id="contourOpacityValue">90%</span>
                        </label>
                        <input type="range" id="contourLineOpacity" min="10" max="100" step="10" value="90" 
                               onchange="updateContourStyle()" style="width: 100%;">
                    </div>
                    
                    <!-- Line Color -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 14px;">
                            Line Color
                        </label>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="color" id="contourLineColor" value="#FF6B00" onchange="updateContourStyle()" 
                                   style="width: 60px; height: 35px; border: 2px solid #ddd; border-radius: 5px; cursor: pointer;">
                            <select id="contourColorPreset" onchange="applyContourColorPreset()" 
                                    style="flex: 1; padding: 8px; border-radius: 5px; border: 2px solid #ddd;">
                                <option value="#FF6B00">Orange (Default)</option>
                                <option value="#0066cc">Blue</option>
                                <option value="#cc0000">Red</option>
                                <option value="#00cc00">Green</option>
                                <option value="#cc00cc">Purple</option>
                                <option value="#000000">Black</option>
                                <option value="#FFFF00">Yellow</option>
                                <option value="#00FFFF">Cyan</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Smoothing -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 14px;">
                            Line Smoothing: <span id="contourSmoothValue">Medium</span>
                        </label>
                        <input type="range" id="contourSmoothing" min="0" max="3" step="0.5" value="0.5" 
                               onchange="updateContourStyle()" style="width: 100%;">
                    </div>
                    
                    <!-- Visibility Toggles -->
                    <div style="margin-bottom: 20px; padding: 15px; background: white; border-radius: 8px; border: 1px solid #ddd;">
                        <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px;">Visibility</div>
                        <label style="display: block; margin-bottom: 8px; cursor: pointer;">
                            <input type="checkbox" id="showKrigingContourLabels" checked onchange="updateKrigingContours()"> 
                            <span style="font-size: 13px;">Show Elevation Labels</span>
                        </label>
                        <label style="display: block; margin-bottom: 8px; cursor: pointer;">
                            <input type="checkbox" id="show3DContours" checked onchange="render3DGroundSurface()"> 
                            <span style="font-size: 13px;">Show on 3D Model</span>
                        </label>
                        <label style="display: block; margin-bottom: 8px; cursor: pointer;">
                            <input type="checkbox" id="showSurveyPointsOnContour" checked onchange="updateKrigingContours()"> 
                            <span style="font-size: 13px;">Show Survey Points</span>
                        </label>
                        <label style="display: block; cursor: pointer;">
                            <input type="checkbox" id="highlightMajorContours" onchange="updateKrigingContours()"> 
                            <span style="font-size: 13px;">Highlight Major Contours</span>
                        </label>
                    </div>
                    
                    <!-- Label Style -->
                    <div style="margin-bottom: 15px; padding: 15px; background: white; border-radius: 8px; border: 1px solid #ddd;">
                        <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px;">Label Settings</div>
                        <label style="display: block; margin-bottom: 8px; font-size: 13px;">
                            Label Frequency: <span id="labelFreqValue">Every 2nd</span>
                        </label>
                        <input type="range" id="labelFrequency" min="1" max="5" step="1" value="2" 
                               onchange="updateLabelFrequency()" style="width: 100%; margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 8px; font-size: 13px;">
                            Label Size: <span id="labelSizeValue">11px</span>
                        </label>
                        <input type="range" id="labelSize" min="8" max="16" step="1" value="11" 
                               onchange="updateKrigingContours()" style="width: 100%;">
                    </div>
                    
                    <!-- Quick Actions -->
                    <div style="display: flex; gap: 8px; flex-direction: column;">
                        <button onclick="resetContourSettings()" 
                                style="padding: 10px; background: linear-gradient(135deg, #95a5a6, #7f8c8d); color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                            Reset to Defaults
                        </button>
                        <button onclick="exportContourMap()" 
                                style="padding: 10px; background: linear-gradient(135deg, #27ae60, #229954); color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                            üì• Export Contour Map
                        </button>
                        <button onclick="exportMainMap()" 
                                style="padding: 10px; background: linear-gradient(135deg, #3498db, #2980b9); color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                            üó∫Ô∏è Export Main Map
                        </button>
                        <button onclick="export3DView()" 
                                style="padding: 10px; background: linear-gradient(135deg, #9b59b6, #8e44ad); color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                            üèîÔ∏è Export 3D View
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="cross-section-panel" id="crossSectionPanel">
        <div class="cross-section-content">
            <div class="cross-section-header">
                <h3>Elevation Cross Section</h3>
                <button class="close-cross-section" onclick="closeCrossSection()">‚úï Close</button>
            </div>
            <div class="cross-section-body">
                <canvas id="crossSectionChart"></canvas>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tokml/0.4.0/tokml.js"></script>
    <!-- Leaflet.heat plugin -->
    <script>
    // Simplified heatmap implementation
    L.HeatLayer = (L.Layer ? L.Layer : L.Class).extend({
        initialize: function (latlngs, options) {
            this._latlngs = latlngs;
            L.setOptions(this, options);
        },
        setLatLngs: function (latlngs) {
            this._latlngs = latlngs;
            return this.redraw();
        },
        addLatLng: function (latlng) {
            this._latlngs.push(latlng);
            return this.redraw();
        },
        setOptions: function (options) {
            L.setOptions(this, options);
            if (this._heat) {
                this._updateOptions();
            }
            return this.redraw();
        },
        redraw: function () {
            if (this._heat && !this._frame && this._map && !this._map._animating) {
                this._frame = L.Util.requestAnimFrame(this._redraw, this);
            }
            return this;
        },
        onAdd: function (map) {
            this._map = map;
            if (!this._canvas) {
                this._initCanvas();
            }
            if (this.options.pane) {
                this.getPane().appendChild(this._canvas);
            } else {
                map._panes.overlayPane.appendChild(this._canvas);
            }
            map.on('moveend', this._reset, this);
            if (map.options.zoomAnimation && L.Browser.any3d) {
                map.on('zoomanim', this._animateZoom, this);
            }
            this._reset();
        },
        onRemove: function (map) {
            if (this.options.pane) {
                this.getPane().removeChild(this._canvas);
            } else {
                map.getPanes().overlayPane.removeChild(this._canvas);
            }
            map.off('moveend', this._reset, this);
            if (map.options.zoomAnimation) {
                map.off('zoomanim', this._animateZoom, this);
            }
        },
        addTo: function (map) {
            map.addLayer(this);
            return this;
        },
        _initCanvas: function () {
            var canvas = this._canvas = L.DomUtil.create('canvas', 'leaflet-heatmap-layer leaflet-layer');
            var originProp = L.DomUtil.testProp(['transformOrigin', 'WebkitTransformOrigin', 'msTransformOrigin']);
            canvas.style[originProp] = '50% 50%';
            var size = this._map.getSize();
            canvas.width  = size.x;
            canvas.height = size.y;
            var animated = this._map.options.zoomAnimation && L.Browser.any3d;
            L.DomUtil.addClass(canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));
        },
        _updateOptions: function () {},
        _reset: function () {
            var topLeft = this._map.containerPointToLayerPoint([0, 0]);
            L.DomUtil.setPosition(this._canvas, topLeft);
            var size = this._map.getSize();
            if (this._canvas.width !== size.x) this._canvas.width = size.x;
            if (this._canvas.height !== size.y) this._canvas.height = size.y;
            this._redraw();
        },
        _redraw: function () {
            if (!this._map) return;
            var data = [], r = this.options.radius, size = this._map.getSize(),
                bounds = new L.Bounds(L.point([-r, -r]), size.add([r, r])),
                max = this.options.max === undefined ? 1 : this.options.max,
                maxZoom = this.options.maxZoom === undefined ? this._map.getMaxZoom() : this.options.maxZoom,
                v = 1 / Math.pow(2, Math.max(0, Math.min(maxZoom - this._map.getZoom(), 12))),
                cellSize = r / 2, grid = [], panePos = this._map._getMapPanePos(), offsetX = panePos.x % cellSize,
                offsetY = panePos.y % cellSize, i, len, p, cell, x, y, j, len2;
            for (i = 0, len = this._latlngs.length; i < len; i++) {
                p = this._map.latLngToContainerPoint(this._latlngs[i]);
                x = Math.floor((p.x - offsetX) / cellSize) + 2;
                y = Math.floor((p.y - offsetY) / cellSize) + 2;
                var alt = this._latlngs[i].alt !== undefined ? this._latlngs[i].alt : this._latlngs[i][2] !== undefined ? +this._latlngs[i][2] : 1;
                if (!grid[y]) grid[y] = [];
                if (!grid[y][x]) {
                    grid[y][x] = { val: 0 };
                }
                grid[y][x].val += alt * v;
            }
            for (i = 0, len = grid.length; i < len; i++) {
                if (grid[i]) {
                    for (j = 0, len2 = grid[i].length; j < len2; j++) {
                        cell = grid[i][j];
                        if (cell) {
                            data.push([
                                Math.round((j - 2) * cellSize + offsetX),
                                Math.round((i - 2) * cellSize + offsetY),
                                Math.min(cell.val, max)
                            ]);
                        }
                    }
                }
            }
            this._drawHeatmap(data, max);
            this._frame = null;
        },
        _drawHeatmap: function(data, max) {
            var ctx = this._canvas.getContext('2d'), r = this.options.radius || 25,
                blur = this.options.blur === undefined ? 15 : this.options.blur;
            ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
            for (var i = 0, len = data.length, p; i < len; i++) {
                p = data[i];
                ctx.globalAlpha = Math.max(p[2] / max, 0);
                ctx.drawImage(this._getGradient(), p[0] - r, p[1] - r, 2 * r, 2 * r);
            }
            var colored = ctx.getImageData(0, 0, this._canvas.width, this._canvas.height);
            this._colorize(colored.data, this.options.gradient || this._defaultGradient);
            ctx.putImageData(colored, 0, 0);
        },
        _colorize: function(pixels, gradient) {
            for (var i = 0, len = pixels.length, j; i < len; i += 4) {
                j = pixels[i + 3] * 4;
                if (j) {
                    pixels[i] = gradient[j];
                    pixels[i + 1] = gradient[j + 1];
                    pixels[i + 2] = gradient[j + 2];
                }
            }
        },
        _getGradient: function() {
            if (!this._circle) {
                var r = this.options.radius || 25, blur = this.options.blur === undefined ? 15 : this.options.blur,
                    circle = this._circle = document.createElement('canvas'), ctx = circle.getContext('2d');
                circle.width = circle.height = r * 2;
                ctx.shadowOffsetX = ctx.shadowOffsetY = r * 2;
                ctx.shadowBlur = blur;
                ctx.shadowColor = 'black';
                ctx.beginPath();
                ctx.arc(-r, -r, r / 2, 0, Math.PI * 2, true);
                ctx.closePath();
                ctx.fill();
            }
            return this._circle;
        },
        _animateZoom: function (e) {
            var scale = this._map.getZoomScale(e.zoom), offset = this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());
            if (L.DomUtil.setTransform) {
                L.DomUtil.setTransform(this._canvas, offset, scale);
            } else {
                this._canvas.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ')';
            }
        },
        _defaultGradient: (function() {
            var canvas = document.createElement('canvas'), ctx = canvas.getContext('2d'), gradient;
            canvas.width = 1; canvas.height = 256;
            ctx.fillStyle = 'blue'; ctx.fillRect(0, 0, 1, 64);
            ctx.fillStyle = 'cyan'; ctx.fillRect(0, 64, 1, 64);
            ctx.fillStyle = 'lime'; ctx.fillRect(0, 128, 1, 64);
            ctx.fillStyle = 'yellow'; ctx.fillRect(0, 192, 1, 32);
            ctx.fillStyle = 'red'; ctx.fillRect(0, 224, 1, 32);
            gradient = ctx.getImageData(0, 0, 1, 256).data;
            return gradient;
        })()
    });
    L.heatLayer = function (latlngs, options) {
        return new L.HeatLayer(latlngs, options);
    };
    </script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
        }
    }
    </script>
    <script>
        let map;
        let contourMap = null;  // New kriging-based contour map
        let markers = [];
        let surveyData = [];
        let filteredData = [];
        let tinLayer = null;
        let contoursLayer = null;
        let heatmapLayer = null;
        let crossSectionLine = null;
        let crossSectionPoints = [];
        let drawingCrossSection = false;
        let crossSectionChart = null;
        let krigingContoursLayer = null;  // For kriging-based contours
        
        let showingTIN = false;
        let showingContours = false;
        let showingHeatmap = false;

        let elevationRange = { min: 0, max: 100 };
        let rmsRange = { min: 0, max: 1 };
        let contourInterval = 1;

        // 3D Ground Surface variables
        let ground3DScene = null;
        let ground3DCamera = null;
        let ground3DRenderer = null;
        let ground3DControls = null;
        let ground3DVerticalExaggeration = 2.0;
        let ground3DKrigingGrid = null;
        
        // Kriging parameters
        let krigingSmoothing = 20;  // Maximum smoothness
        let krigingGridResolution = 200;  // Maximum resolution
        let krigingInterpPower = 5;  // Maximum power
        let krigingNuggetPercent = 0;  // No nugget effect (exact fit)
        let krigingInfluenceRadius = 5;  // Maximum influence
        let krigingGaussianSmooth = 5;  // Very Heavy smoothing
        let useSplineInterpolation = false;

        // Initialize map
        function initMap() {
            map = L.map('map', {
                maxZoom: 22,
                minZoom: 10,
                crs: L.CRS.EPSG3857  // Explicitly set Web Mercator projection
            }).setView([-33.61, 115.09], 16);
            
            // Satellite imagery layer (default)
            const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '¬© Esri',
                maxZoom: 22
            });
            
            // OpenStreetMap layer (alternative)
            const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            });
            
            // Add satellite layer by default
            satelliteLayer.addTo(map);
            
            // Layer control to switch between satellite and OSM
            const baseMaps = {
                "Satellite": satelliteLayer,
                "Street Map": osmLayer
            };
            L.control.layers(baseMaps).addTo(map);
            
            // Initialize contour map with same CRS
            contourMap = L.map('contourMap', {
                maxZoom: 22,
                minZoom: 10,
                crs: L.CRS.EPSG3857  // Same projection as main map
            }).setView([-33.61, 115.09], 16);
            
            // Satellite imagery for contour map
            const contourSatellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '¬© Esri',
                maxZoom: 22
            });
            
            const contourOSM = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            });
            
            contourSatellite.addTo(contourMap);
            
            const contourBaseMaps = {
                "Satellite": contourSatellite,
                "Street Map": contourOSM
            };
            L.control.layers(contourBaseMaps).addTo(contourMap);
        }

        function switchTab(method) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            document.querySelectorAll('.input-method').forEach(m => m.classList.remove('active'));
            document.getElementById(method + 'Tab').classList.add('active');
        }

        function processPastedData() {
            const rawText = document.getElementById('csvPaste').value.trim();
            if (!rawText) {
                showError('Please paste data first');
                return;
            }

            if (!rawText.includes(',') && rawText.includes(' ')) {
                parseSpaceSeparatedData(rawText);
            } else {
                parseCSVData(rawText);
            }
        }

        function parseSpaceSeparatedData(rawText) {
            const lines = rawText.trim().split('\n');
            const headers = [
                'Name', 'Code', 'Easting', 'Northing', 'Elevation', 'Description',
                'Longitude', 'Latitude', 'Ellipsoidal height', 'Origin', 'Easting RMS',
                'Northing RMS', 'Elevation RMS', 'Lateral RMS', 'Antenna height',
                'Antenna height units', 'Solution status', 'Correction type',
                'Averaging start', 'Averaging start2', 'Averaging start3', 'Averaging end',
                'Averaging end2', 'Averaging end3', 'Samples', 'PDOP', 'GDOP',
                'Base easting', 'Base northing', 'Base elevation', 'Base longitude',
                'Base latitude', 'Base ellipsoidal height', 'Baseline', 'Mount point',
                'CS name', 'GPS Satellites', 'GLONASS Satellites', 'Galileo Satellites',
                'BeiDou Satellites', 'QZSS Satellites'
            ];

            surveyData = [];

            lines.forEach(line => {
                if (line.trim()) {
                    const values = line.trim().split(/\s+/);
                    const dataPoint = {};

                    values.forEach((value, index) => {
                        if (index < headers.length) {
                            if (!isNaN(value) && value !== '') {
                                dataPoint[headers[index]] = parseFloat(value);
                            } else {
                                dataPoint[headers[index]] = value;
                            }
                        }
                    });

                    if (dataPoint.Latitude != null && dataPoint.Longitude != null &&
                        !isNaN(dataPoint.Latitude) && !isNaN(dataPoint.Longitude)) {

                        if (dataPoint['Averaging start2']) {
                            dataPoint['Averaging start'] = dataPoint['Averaging start'] + ' ' +
                                dataPoint['Averaging start2'] + ' ' + dataPoint['Averaging start3'];
                        }
                        if (dataPoint['Averaging end2']) {
                            dataPoint['Averaging end'] = dataPoint['Averaging end'] + ' ' +
                                dataPoint['Averaging end2'] + ' ' + dataPoint['Averaging end3'];
                        }

                        surveyData.push(dataPoint);
                    }
                }
            });

            if (surveyData.length === 0) {
                showError('No valid GPS coordinates found in the pasted data');
                return;
            }

            initializeData();
        }

        function loadSampleData() {
            const sampleCSV = `Name,Code,Easting,Northing,Elevation,Description,Longitude,Latitude,Ellipsoidal height,Origin,Easting RMS,Northing RMS,Elevation RMS,Lateral RMS,Antenna height,Antenna height units,Solution status,Correction type,Averaging start,Averaging end,Samples,PDOP,GDOP,Base easting,Base northing,Base elevation,Base longitude,Base latitude,Base ellipsoidal height,Baseline,Mount point,CS name,GPS Satellites,GLONASS Satellites,Galileo Satellites,BeiDou Satellites,QZSS Satellites
1,322965.3,6279430,33.837,gcp,115.0918,-33.6102,1.805,Global,0.011,0.011,0.026,0.016,1.934,m,FIX,RTK,2025-07-21 11:30:20.0 UTC+08:00,2025-07-21 11:30:30.0 UTC+08:00,49,2.9,3.4,343222,6272667,6.403,115.3088,-33.6744,-26.311,21357.17,BUSS00AUS0,GDA2020 / MGA zone 50 + AHD height,9,9,0,0,0
2,322931.6,6279481,32.97,gcp,115.0914,-33.6097,0.939,Global,0.01,0.011,0.02,0.015,1.934,m,FIX,RTK,2025-07-21 11:31:17.4 UTC+08:00,2025-07-21 11:31:27.4 UTC+08:00,49,2.9,3.4,343222,6272667,6.403,115.3088,-33.6744,-26.311,21405.3,BUSS00AUS0,GDA2020 / MGA zone 50 + AHD height,8,9,0,0,0
3,322945.5,6279455,33.5,gcp,115.0916,-33.6099,1.468,Global,0.01,0.01,0.022,0.014,1.934,m,FIX,RTK,2025-07-21 11:32:00.0 UTC+08:00,2025-07-21 11:32:10.0 UTC+08:00,49,2.8,3.3,343222,6272667,6.403,115.3088,-33.6744,-26.311,21380.5,BUSS00AUS0,GDA2020 / MGA zone 50 + AHD height,9,8,0,0,0
4,322920.8,6279505,32.1,gcp,115.0912,-33.6095,0.069,Global,0.012,0.012,0.028,0.017,1.934,m,FIX,RTK,2025-07-21 11:33:05.0 UTC+08:00,2025-07-21 11:33:15.0 UTC+08:00,49,3.0,3.5,343222,6272667,6.403,115.3088,-33.6744,-26.311,21428.9,BUSS00AUS0,GDA2020 / MGA zone 50 + AHD height,8,9,0,0,0
5,322975.2,6279410,34.2,gcp,115.0920,-33.6104,2.168,Global,0.011,0.011,0.024,0.016,1.934,m,FIX,RTK,2025-07-21 11:34:20.0 UTC+08:00,2025-07-21 11:34:30.0 UTC+08:00,49,2.9,3.4,343222,6272667,6.403,115.3088,-33.6744,-26.311,21338.2,BUSS00AUS0,GDA2020 / MGA zone 50 + AHD height,9,9,0,0,0`;

            parseCSVData(sampleCSV);
        }

        function parseCSVData(csvText) {
            Papa.parse(csvText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    if (results.errors.length > 0) {
                        showError('CSV parsing errors: ' + results.errors.map(e => e.message).join(', '));
                        return;
                    }

                    surveyData = results.data.filter(row =>
                        row.Latitude != null && row.Longitude != null &&
                        !isNaN(row.Latitude) && !isNaN(row.Longitude)
                    );

                    if (surveyData.length === 0) {
                        showError('No valid GPS coordinates found in the data');
                        return;
                    }

                    initializeData();
                }
            });
        }

        function initializeData() {
            // Calculate ranges
            elevationRange.min = Math.min(...surveyData.map(p => parseFloat(p.Elevation || 0)));
            elevationRange.max = Math.max(...surveyData.map(p => parseFloat(p.Elevation || 0)));
            rmsRange.min = Math.min(...surveyData.map(p => parseFloat(p['Lateral RMS'] || 0)));
            rmsRange.max = Math.max(...surveyData.map(p => parseFloat(p['Lateral RMS'] || 0)));

            filteredData = [...surveyData];

            displayData();
            updateMap();
            updateStats();
            updateFilterLabels();
            
            // Initialize 3D ground surface visualization
            render3DGroundSurface();
            
            // Generate kriging-based contours
            updateKrigingContours();
        }
        
        function updateContourStyle() {
            const weight = parseFloat(document.getElementById('contourLineWeight').value);
            const opacity = parseFloat(document.getElementById('contourLineOpacity').value) / 100;
            const color = document.getElementById('contourLineColor').value;
            const smoothing = parseFloat(document.getElementById('contourSmoothing').value);
            
            document.getElementById('contourWeightValue').textContent = weight + 'px';
            document.getElementById('contourOpacityValue').textContent = Math.round(opacity * 100) + '%';
            
            const smoothLabels = ['None', 'Light', 'Medium', 'Heavy'];
            const smoothIndex = Math.round(smoothing * 2);
            document.getElementById('contourSmoothValue').textContent = smoothLabels[smoothIndex];
            
            // Store values globally for use in updateKrigingContours
            window.contourStyle = { weight, opacity, color, smoothing };
            
            updateKrigingContours();
        }

        function applyContourColorPreset() {
            const color = document.getElementById('contourColorPreset').value;
            document.getElementById('contourLineColor').value = color;
            updateContourStyle();
        }

        function updateLabelFrequency() {
            const freq = parseInt(document.getElementById('labelFrequency').value);
            const labels = ['Every Contour', 'Every 2nd', 'Every 3rd', 'Every 4th', 'Every 5th'];
            document.getElementById('labelFreqValue').textContent = labels[freq - 1];
            updateKrigingContours();
        }

        function resetContourSettings() {
            document.getElementById('krigingContourInterval').value = '0.5';
            document.getElementById('contourLineWeight').value = '2.5';
            document.getElementById('contourLineOpacity').value = '90';
            document.getElementById('contourLineColor').value = '#FF6B00';
            document.getElementById('contourColorPreset').value = '#FF6B00';
            document.getElementById('contourSmoothing').value = '0.5';
            document.getElementById('showKrigingContourLabels').checked = true;
            document.getElementById('show3DContours').checked = true;
            document.getElementById('showSurveyPointsOnContour').checked = true;
            document.getElementById('highlightMajorContours').checked = false;
            document.getElementById('labelFrequency').value = '2';
            document.getElementById('labelSize').value = '11';
            
            updateContourStyle();
        }

        function exportContourMap() {
            if (!contourMap) {
                alert('No contour map to export');
                return;
            }
            
            // Create modal for export options
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 15px;
                box-shadow: 0 10px 40px rgba(0,0,0,0.3);
                max-width: 400px;
                width: 90%;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin-top: 0; color: #2c3e50;">Export Contour Map</h3>
                <p style="color: #666; margin-bottom: 20px;">Choose export format:</p>
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <button onclick="exportContoursAsKMZ()" style="padding: 15px; background: linear-gradient(135deg, #f39c12, #e67e22); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 600;">
                        üåç Export as KMZ (Google Earth)
                    </button>
                    <button onclick="exportMapAsPNG()" style="padding: 15px; background: linear-gradient(135deg, #3498db, #2980b9); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 600;">
                        üì∑ Export as PNG Image
                    </button>
                    <button onclick="exportMapAsPDF()" style="padding: 15px; background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 600;">
                        üìÑ Export as PDF Document
                    </button>
                    <button onclick="this.closest('.export-modal').remove()" style="padding: 12px; background: #95a5a6; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                        Cancel
                    </button>
                </div>
            `;
            
            modal.className = 'export-modal';
            modal.appendChild(dialog);
            document.body.appendChild(modal);
            
            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        async function exportContoursAsKMZ() {
            const modal = document.querySelector('.export-modal');
            if (modal) modal.remove();
            
            // Show loading indicator
            const loading = document.createElement('div');
            loading.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 20px 40px;
                border-radius: 10px;
                z-index: 10001;
                font-size: 16px;
            `;
            loading.textContent = 'üåç Generating KMZ for Google Earth...';
            document.body.appendChild(loading);
            
            try {
                if (!ground3DKrigingGrid) {
                    alert('No contour data available. Please ensure data is loaded and 3D surface is rendered.');
                    loading.remove();
                    return;
                }
                
                const selectedData = getSelectedData();
                const interval = parseFloat(document.getElementById('krigingContourInterval').value);
                const style = window.contourStyle || { color: '#FF6B00', weight: 2.5, opacity: 0.9 };
                
                // Convert hex color to KML RGB format
                const hexToKmlColor = (hex, opacity) => {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    const a = Math.round(opacity * 255);
                    // KML uses AABBGGRR format
                    return a.toString(16).padStart(2, '0') + 
                           b.toString(16).padStart(2, '0') + 
                           g.toString(16).padStart(2, '0') + 
                           r.toString(16).padStart(2, '0');
                };
                
                const kmlColor = hexToKmlColor(style.color, style.opacity);
                
                // Build KML document
                let kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>Kriging Contour Map</name>
    <description>Generated from GPS survey data with kriging interpolation. Interval: ${interval}m</description>
    
    <!-- Contour Line Style -->
    <Style id="contourLine">
      <LineStyle>
        <color>${kmlColor}</color>
        <width>${style.weight}</width>
      </LineStyle>
      <PolyStyle>
        <color>00000000</color>
        <fill>0</fill>
      </PolyStyle>
    </Style>
    
    <!-- Survey Point Style -->
    <Style id="surveyPoint">
      <IconStyle>
        <color>ff00ff00</color>
        <scale>0.8</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png</href>
        </Icon>
      </IconStyle>
      <LabelStyle>
        <scale>0.7</scale>
      </LabelStyle>
    </Style>
    
    <!-- Contour Lines Folder -->
    <Folder>
      <name>Contour Lines</name>
      <description>Elevation contours at ${interval}m intervals</description>
`;
                
                // Get contour data from the stored global contour layers
                const { grid, bounds, resolution, dx, dy } = ground3DKrigingGrid;
                const allValues = grid.flat();
                const minElev = Math.min(...allValues);
                const maxElev = Math.max(...allValues);
                
                const levels = [];
                for (let level = Math.ceil(minElev / interval) * interval; level <= maxElev; level += interval) {
                    levels.push(level);
                }
                
                // Generate contours for each level
                for (const level of levels) {
                    const segments = [];
                    
                    // Marching squares to extract contour segments
                    for (let i = 0; i < resolution; i++) {
                        for (let j = 0; j < resolution; j++) {
                            const v00 = grid[i][j];
                            const v10 = grid[i][j + 1];
                            const v01 = grid[i + 1][j];
                            const v11 = grid[i + 1][j + 1];
                            
                            if (!isFinite(v00) || !isFinite(v10) || !isFinite(v01) || !isFinite(v11)) continue;
                            
                            const c = (v00 >= level ? 8 : 0) + (v10 >= level ? 4 : 0) + 
                                     (v11 >= level ? 2 : 0) + (v01 >= level ? 1 : 0);
                            if (c === 0 || c === 15) continue;
                            
                            const lon0 = bounds.minX + j * dx;
                            const lat0 = bounds.minY + i * dy;
                            const edges = [];
                            
                            const minDenom = 0.000001;
                            
                            // Calculate edge intersections
                            const topDenom = v10 - v00;
                            if (Math.abs(topDenom) > minDenom) {
                                const t = (level - v00) / topDenom;
                                if (t > 0 && t < 1) {
                                    edges.push({ lon: lon0 + t * dx, lat: lat0 });
                                }
                            }
                            
                            const rightDenom = v11 - v10;
                            if (Math.abs(rightDenom) > minDenom) {
                                const t = (level - v10) / rightDenom;
                                if (t > 0 && t < 1) {
                                    edges.push({ lon: lon0 + dx, lat: lat0 + t * dy });
                                }
                            }
                            
                            const bottomDenom = v11 - v01;
                            if (Math.abs(bottomDenom) > minDenom) {
                                const t = (level - v01) / bottomDenom;
                                if (t > 0 && t < 1) {
                                    edges.push({ lon: lon0 + t * dx, lat: lat0 + dy });
                                }
                            }
                            
                            const leftDenom = v01 - v00;
                            if (Math.abs(leftDenom) > minDenom) {
                                const t = (level - v00) / leftDenom;
                                if (t > 0 && t < 1) {
                                    edges.push({ lon: lon0, lat: lat0 + t * dy });
                                }
                            }
                            
                            if (edges.length >= 2) {
                                segments.push({ start: edges[0], end: edges[1] });
                            }
                        }
                    }
                    
                    // Connect segments into polylines
                    const polylines = connectContourSegmentsImproved(segments, dx, dy);
                    
                    // Add each polyline as a KML Placemark
                    polylines.forEach((polyline, idx) => {
                        if (polyline.length >= 2) {
                            kml += `      <Placemark>
        <name>${level.toFixed(2)}m Contour</name>
        <description>Elevation: ${level.toFixed(2)} meters</description>
        <styleUrl>#contourLine</styleUrl>
        <LineString>
          <tessellate>1</tessellate>
          <altitudeMode>clampToGround</altitudeMode>
          <coordinates>
`;
                            polyline.forEach(p => {
                                kml += `            ${p.lon.toFixed(8)},${p.lat.toFixed(8)},0\n`;
                            });
                            
                            kml += `          </coordinates>
        </LineString>
      </Placemark>
`;
                        }
                    });
                }
                
                kml += `    </Folder>
    
    <!-- Survey Points Folder -->
    <Folder>
      <name>Survey Points</name>
      <description>${selectedData.length} GPS survey points</description>
`;
                
                // Add survey points
                selectedData.forEach(p => {
                    const lat = parseFloat(p.Latitude);
                    const lng = parseFloat(p.Longitude);
                    const elev = parseFloat(p.Elevation || 0);
                    
                    kml += `      <Placemark>
        <name>${p.Name || 'Point'}</name>
        <description>
          <![CDATA[
            <b>Elevation:</b> ${elev.toFixed(3)}m<br/>
            <b>Latitude:</b> ${lat.toFixed(6)}¬∞<br/>
            <b>Longitude:</b> ${lng.toFixed(6)}¬∞<br/>
            <b>RMS:</b> ${p['Lateral RMS'] || 'N/A'}
          ]]>
        </description>
        <styleUrl>#surveyPoint</styleUrl>
        <Point>
          <altitudeMode>clampToGround</altitudeMode>
          <coordinates>${lng.toFixed(8)},${lat.toFixed(8)},0</coordinates>
        </Point>
      </Placemark>
`;
                });
                
                kml += `    </Folder>
  </Document>
</kml>`;
                
                // Create KMZ file (zipped KML)
                const zip = new JSZip();
                zip.file('doc.kml', kml);
                
                const kmzBlob = await zip.generateAsync({ type: 'blob' });
                
                // Download KMZ
                const url = URL.createObjectURL(kmzBlob);
                const link = document.createElement('a');
                const timestamp = new Date().toISOString().split('T')[0];
                link.download = `contour_map_${timestamp}.kmz`;
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
                
                loading.remove();
                showExportSuccess('KMZ file downloaded! Open in Google Earth.');
                
            } catch (error) {
                console.error('KMZ export error:', error);
                loading.remove();
                alert('Error exporting KMZ. Please try again.');
            }
        }

        async function exportMapAsPNG() {
            const modal = document.querySelector('.export-modal');
            if (modal) modal.remove();
            
            // Show loading indicator
            const loading = document.createElement('div');
            loading.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 20px 40px;
                border-radius: 10px;
                z-index: 10001;
                font-size: 16px;
            `;
            loading.textContent = 'üì∏ Capturing map...';
            document.body.appendChild(loading);
            
            try {
                const mapElement = document.getElementById('contourMap');
                
                // Capture the map using html2canvas
                const canvas = await html2canvas(mapElement, {
                    useCORS: true,
                    allowTaint: true,
                    backgroundColor: '#ffffff',
                    scale: 2, // Higher quality
                    logging: false
                });
                
                // Convert to PNG and download
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().split('T')[0];
                    link.download = `contour_map_${timestamp}.png`;
                    link.href = url;
                    link.click();
                    URL.revokeObjectURL(url);
                    
                    loading.remove();
                    showExportSuccess('PNG image downloaded successfully!');
                }, 'image/png');
                
            } catch (error) {
                console.error('Export error:', error);
                loading.remove();
                alert('Error exporting map. Please try again.');
            }
        }

        async function exportMapAsPDF() {
            const modal = document.querySelector('.export-modal');
            if (modal) modal.remove();
            
            // Show loading indicator
            const loading = document.createElement('div');
            loading.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 20px 40px;
                border-radius: 10px;
                z-index: 10001;
                font-size: 16px;
            `;
            loading.textContent = 'üìÑ Generating PDF...';
            document.body.appendChild(loading);
            
            try {
                const { jsPDF } = window.jspdf;
                const mapElement = document.getElementById('contourMap');
                
                // Capture the map
                const canvas = await html2canvas(mapElement, {
                    useCORS: true,
                    allowTaint: true,
                    backgroundColor: '#ffffff',
                    scale: 2,
                    logging: false
                });
                
                // Create PDF
                const imgData = canvas.toDataURL('image/png');
                const pdf = new jsPDF({
                    orientation: 'landscape',
                    unit: 'mm',
                    format: 'a4'
                });
                
                // Calculate dimensions to fit page
                const pdfWidth = pdf.internal.pageSize.getWidth();
                const pdfHeight = pdf.internal.pageSize.getHeight();
                const canvasAspect = canvas.width / canvas.height;
                const pdfAspect = pdfWidth / pdfHeight;
                
                let imgWidth, imgHeight, xOffset, yOffset;
                
                if (canvasAspect > pdfAspect) {
                    // Canvas is wider - fit to width
                    imgWidth = pdfWidth - 20; // 10mm margin on each side
                    imgHeight = imgWidth / canvasAspect;
                    xOffset = 10;
                    yOffset = (pdfHeight - imgHeight) / 2;
                } else {
                    // Canvas is taller - fit to height
                    imgHeight = pdfHeight - 20;
                    imgWidth = imgHeight * canvasAspect;
                    xOffset = (pdfWidth - imgWidth) / 2;
                    yOffset = 10;
                }
                
                // Add title
                pdf.setFontSize(16);
                pdf.setFont(undefined, 'bold');
                pdf.text('Kriging-Based Contour Map', pdfWidth / 2, 10, { align: 'center' });
                
                // Add map image
                pdf.addImage(imgData, 'PNG', xOffset, yOffset + 5, imgWidth, imgHeight);
                
                // Add metadata
                pdf.setFontSize(8);
                pdf.setFont(undefined, 'normal');
                const timestamp = new Date().toLocaleString();
                const selectedData = getSelectedData();
                const interval = document.getElementById('krigingContourInterval').value;
                
                pdf.text(`Generated: ${timestamp}`, 10, pdfHeight - 10);
                pdf.text(`Survey Points: ${selectedData.length}`, 10, pdfHeight - 6);
                pdf.text(`Contour Interval: ${interval}m`, 60, pdfHeight - 6);
                pdf.text(`Elevation Range: ${elevationRange.min.toFixed(2)}m - ${elevationRange.max.toFixed(2)}m`, 120, pdfHeight - 6);
                
                // Save PDF
                const timestamp_file = new Date().toISOString().split('T')[0];
                pdf.save(`contour_map_${timestamp_file}.pdf`);
                
                loading.remove();
                showExportSuccess('PDF document downloaded successfully!');
                
            } catch (error) {
                console.error('Export error:', error);
                loading.remove();
                alert('Error exporting PDF. Please try again.');
            }
        }

        function showExportSuccess(message) {
            const success = document.createElement('div');
            success.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #27ae60, #229954);
                color: white;
                padding: 15px 25px;
                border-radius: 10px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.2);
                z-index: 10002;
                font-weight: 600;
                animation: slideIn 0.3s ease-out;
            `;
            success.textContent = '‚úì ' + message;
            document.body.appendChild(success);
            
            setTimeout(() => {
                success.style.animation = 'slideOut 0.3s ease-out';
                setTimeout(() => success.remove(), 300);
            }, 3000);
        }

        async function exportMainMap() {
            // Show loading indicator
            const loading = document.createElement('div');
            loading.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 20px 40px;
                border-radius: 10px;
                z-index: 10001;
                font-size: 16px;
            `;
            loading.textContent = 'üì∏ Capturing main map...';
            document.body.appendChild(loading);
            
            try {
                const mapElement = document.getElementById('map');
                
                const canvas = await html2canvas(mapElement, {
                    useCORS: true,
                    allowTaint: true,
                    backgroundColor: '#ffffff',
                    scale: 2,
                    logging: false
                });
                
                // Show format selection
                loading.remove();
                showFormatSelection('main_map', canvas);
                
            } catch (error) {
                console.error('Export error:', error);
                loading.remove();
                alert('Error exporting map. Please try again.');
            }
        }

        async function export3DView() {
            const loading = document.createElement('div');
            loading.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 20px 40px;
                border-radius: 10px;
                z-index: 10001;
                font-size: 16px;
            `;
            loading.textContent = 'üèîÔ∏è Capturing 3D view...';
            document.body.appendChild(loading);
            
            try {
                const viewerElement = document.getElementById('groundSurface3DMain');
                
                const canvas = await html2canvas(viewerElement, {
                    useCORS: true,
                    allowTaint: true,
                    backgroundColor: '#e0e8f0',
                    scale: 2,
                    logging: false
                });
                
                loading.remove();
                showFormatSelection('3d_view', canvas);
                
            } catch (error) {
                console.error('Export error:', error);
                loading.remove();
                alert('Error exporting 3D view. Please try again.');
            }
        }

        function showFormatSelection(name, canvas) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 15px;
                box-shadow: 0 10px 40px rgba(0,0,0,0.3);
                max-width: 400px;
                width: 90%;
            `;
            
            const title = name.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
            
            dialog.innerHTML = `
                <h3 style="margin-top: 0; color: #2c3e50;">Export ${title}</h3>
                <p style="color: #666; margin-bottom: 20px;">Choose export format:</p>
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <button class="export-png-btn" style="padding: 15px; background: linear-gradient(135deg, #3498db, #2980b9); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 600;">
                        üì∑ Export as PNG Image
                    </button>
                    <button class="export-pdf-btn" style="padding: 15px; background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 600;">
                        üìÑ Export as PDF Document
                    </button>
                    <button class="cancel-btn" style="padding: 12px; background: #95a5a6; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                        Cancel
                    </button>
                </div>
            `;
            
            modal.appendChild(dialog);
            document.body.appendChild(modal);
            
            // PNG export
            dialog.querySelector('.export-png-btn').onclick = () => {
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().split('T')[0];
                    link.download = `${name}_${timestamp}.png`;
                    link.href = url;
                    link.click();
                    URL.revokeObjectURL(url);
                    modal.remove();
                    showExportSuccess('PNG image downloaded successfully!');
                }, 'image/png');
            };
            
            // PDF export
            dialog.querySelector('.export-pdf-btn').onclick = () => {
                const { jsPDF } = window.jspdf;
                const imgData = canvas.toDataURL('image/png');
                const pdf = new jsPDF({
                    orientation: canvas.width > canvas.height ? 'landscape' : 'portrait',
                    unit: 'mm',
                    format: 'a4'
                });
                
                const pdfWidth = pdf.internal.pageSize.getWidth();
                const pdfHeight = pdf.internal.pageSize.getHeight();
                const canvasAspect = canvas.width / canvas.height;
                const pdfAspect = pdfWidth / pdfHeight;
                
                let imgWidth, imgHeight, xOffset, yOffset;
                
                if (canvasAspect > pdfAspect) {
                    imgWidth = pdfWidth - 20;
                    imgHeight = imgWidth / canvasAspect;
                    xOffset = 10;
                    yOffset = (pdfHeight - imgHeight) / 2;
                } else {
                    imgHeight = pdfHeight - 20;
                    imgWidth = imgHeight * canvasAspect;
                    xOffset = (pdfWidth - imgWidth) / 2;
                    yOffset = 10;
                }
                
                pdf.setFontSize(16);
                pdf.setFont(undefined, 'bold');
                pdf.text(title, pdfWidth / 2, 10, { align: 'center' });
                
                pdf.addImage(imgData, 'PNG', xOffset, yOffset + 5, imgWidth, imgHeight);
                
                pdf.setFontSize(8);
                pdf.setFont(undefined, 'normal');
                const timestamp = new Date().toLocaleString();
                pdf.text(`Generated: ${timestamp}`, 10, pdfHeight - 5);
                
                const timestamp_file = new Date().toISOString().split('T')[0];
                pdf.save(`${name}_${timestamp_file}.pdf`);
                
                modal.remove();
                showExportSuccess('PDF document downloaded successfully!');
            };
            
            // Cancel
            dialog.querySelector('.cancel-btn').onclick = () => modal.remove();
            modal.onclick = (e) => {
                if (e.target === modal) modal.remove();
            };
        }

        function updateKrigingContours() {
            if (!contourMap || !ground3DKrigingGrid) return;
            
            // Remove existing contours
            if (krigingContoursLayer) {
                contourMap.removeLayer(krigingContoursLayer);
                krigingContoursLayer = null;
            }
            
            const selectedData = getSelectedData();
            if (selectedData.length < 3) return;
            
            const interval = parseFloat(document.getElementById('krigingContourInterval').value);
            const showLabels = document.getElementById('showKrigingContourLabels').checked;
            const showSurveyPoints = document.getElementById('showSurveyPointsOnContour').checked;
            const highlightMajor = document.getElementById('highlightMajorContours').checked;
            const labelFreq = parseInt(document.getElementById('labelFrequency').value);
            const labelSize = parseInt(document.getElementById('labelSize').value);
            
            // Get style settings or use defaults
            const style = window.contourStyle || { 
                weight: 2.5, 
                opacity: 0.9, 
                color: '#FF6B00', 
                smoothing: 0.5 
            };
            
            // Use the kriging grid from 3D visualization
            const { grid, bounds, resolution, dx, dy } = ground3DKrigingGrid;
            
            // Find min/max elevation in grid
            const allValues = grid.flat();
            const minElev = Math.min(...allValues);
            const maxElev = Math.max(...allValues);
            
            // Generate contour levels
            const levels = [];
            for (let level = Math.ceil(minElev / interval) * interval; level <= maxElev; level += interval) {
                levels.push(level);
            }
            
            const contourLayers = [];
            
            levels.forEach((level, levelIdx) => {
                const segments = [];
                
                // Improved marching squares algorithm with all 16 cases
                for (let i = 0; i < resolution; i++) {
                    for (let j = 0; j < resolution; j++) {
                        const v00 = grid[i][j];
                        const v10 = grid[i][j + 1];
                        const v01 = grid[i + 1][j];
                        const v11 = grid[i + 1][j + 1];
                        
                        if (!isFinite(v00) || !isFinite(v10) || !isFinite(v01) || !isFinite(v11)) continue;
                        
                        // Calculate binary case index
                        const c = (v00 >= level ? 8 : 0) + 
                                 (v10 >= level ? 4 : 0) + 
                                 (v11 >= level ? 2 : 0) + 
                                 (v01 >= level ? 1 : 0);
                        
                        if (c === 0 || c === 15) continue; // All in or all out
                        
                        const lon0 = bounds.minX + j * dx;
                        const lat0 = bounds.minY + i * dy;
                        const edges = [];
                        
                        const minDenom = 0.000001;
                        
                        // Calculate edge intersections with improved interpolation
                        // Top edge (between v00 and v10)
                        const topDenom = v10 - v00;
                        if (Math.abs(topDenom) > minDenom) {
                            const t = (level - v00) / topDenom;
                            if (t > 0 && t < 1) {
                                edges.push({ 
                                    lon: lon0 + t * dx, 
                                    lat: lat0, 
                                    edge: 0,
                                    id: `${i}_${j}_top`
                                });
                            } else if (Math.abs(t) < 0.01) { // Very close to v00
                                edges.push({ lon: lon0, lat: lat0, edge: 0, id: `${i}_${j}_top` });
                            } else if (Math.abs(t - 1) < 0.01) { // Very close to v10
                                edges.push({ lon: lon0 + dx, lat: lat0, edge: 0, id: `${i}_${j}_top` });
                            }
                        }
                        
                        // Right edge (between v10 and v11)
                        const rightDenom = v11 - v10;
                        if (Math.abs(rightDenom) > minDenom) {
                            const t = (level - v10) / rightDenom;
                            if (t > 0 && t < 1) {
                                edges.push({ 
                                    lon: lon0 + dx, 
                                    lat: lat0 + t * dy, 
                                    edge: 1,
                                    id: `${i}_${j}_right`
                                });
                            } else if (Math.abs(t) < 0.01) {
                                edges.push({ lon: lon0 + dx, lat: lat0, edge: 1, id: `${i}_${j}_right` });
                            } else if (Math.abs(t - 1) < 0.01) {
                                edges.push({ lon: lon0 + dx, lat: lat0 + dy, edge: 1, id: `${i}_${j}_right` });
                            }
                        }
                        
                        // Bottom edge (between v01 and v11)
                        const bottomDenom = v11 - v01;
                        if (Math.abs(bottomDenom) > minDenom) {
                            const t = (level - v01) / bottomDenom;
                            if (t > 0 && t < 1) {
                                edges.push({ 
                                    lon: lon0 + t * dx, 
                                    lat: lat0 + dy, 
                                    edge: 2,
                                    id: `${i}_${j}_bottom`
                                });
                            } else if (Math.abs(t) < 0.01) {
                                edges.push({ lon: lon0, lat: lat0 + dy, edge: 2, id: `${i}_${j}_bottom` });
                            } else if (Math.abs(t - 1) < 0.01) {
                                edges.push({ lon: lon0 + dx, lat: lat0 + dy, edge: 2, id: `${i}_${j}_bottom` });
                            }
                        }
                        
                        // Left edge (between v00 and v01)
                        const leftDenom = v01 - v00;
                        if (Math.abs(leftDenom) > minDenom) {
                            const t = (level - v00) / leftDenom;
                            if (t > 0 && t < 1) {
                                edges.push({ 
                                    lon: lon0, 
                                    lat: lat0 + t * dy, 
                                    edge: 3,
                                    id: `${i}_${j}_left`
                                });
                            } else if (Math.abs(t) < 0.01) {
                                edges.push({ lon: lon0, lat: lat0, edge: 3, id: `${i}_${j}_left` });
                            } else if (Math.abs(t - 1) < 0.01) {
                                edges.push({ lon: lon0, lat: lat0 + dy, edge: 3, id: `${i}_${j}_left` });
                            }
                        }
                        
                        // Handle ambiguous saddle point cases (5 and 10)
                        if (c === 5 || c === 10) {
                            const vCenter = (v00 + v10 + v01 + v11) / 4;
                            
                            if (c === 5) {
                                // Case 5: v00 and v11 are above level
                                if (vCenter >= level) {
                                    // Two separate segments
                                    if (edges.length >= 4) {
                                        segments.push({ start: edges[0], end: edges[1] });
                                        segments.push({ start: edges[2], end: edges[3] });
                                    }
                                } else {
                                    // Connected through center
                                    if (edges.length >= 4) {
                                        segments.push({ start: edges[0], end: edges[3] });
                                        segments.push({ start: edges[1], end: edges[2] });
                                    }
                                }
                            } else {
                                // Case 10: v10 and v01 are above level
                                if (vCenter >= level) {
                                    if (edges.length >= 4) {
                                        segments.push({ start: edges[0], end: edges[3] });
                                        segments.push({ start: edges[1], end: edges[2] });
                                    }
                                } else {
                                    if (edges.length >= 4) {
                                        segments.push({ start: edges[0], end: edges[1] });
                                        segments.push({ start: edges[2], end: edges[3] });
                                    }
                                }
                            }
                        } else {
                            // Standard cases - connect pairs of edges
                            if (edges.length === 2) {
                                segments.push({ start: edges[0], end: edges[1] });
                            } else if (edges.length === 4) {
                                // Should only happen in saddle cases, but handle anyway
                                segments.push({ start: edges[0], end: edges[1] });
                                segments.push({ start: edges[2], end: edges[3] });
                            }
                        }
                    }
                }
                
                // Connect segments into polylines with improved connectivity
                const polylines = connectContourSegmentsImproved(segments, dx, dy);
                
                polylines.forEach((polyline, idx) => {
                    const latLngs = polyline.map(p => [p.lat, p.lon]);
                    
                    // Debug: log first contour line coordinates for validation
                    if (levelIdx === 0 && idx === 0 && latLngs.length > 0) {
                        console.log('First contour line sample:', {
                            level: level,
                            firstPoint: latLngs[0],
                            bounds: { minLat: bounds.minY, maxLat: bounds.maxY, minLon: bounds.minX, maxLon: bounds.maxX },
                            surveyBounds: {
                                minLat: Math.min(...selectedData.map(p => parseFloat(p.Latitude))),
                                maxLat: Math.max(...selectedData.map(p => parseFloat(p.Latitude))),
                                minLon: Math.min(...selectedData.map(p => parseFloat(p.Longitude))),
                                maxLon: Math.max(...selectedData.map(p => parseFloat(p.Longitude)))
                            }
                        });
                    }
                    
                    if (latLngs.length >= 2) {
                        // Determine if this is a major contour (divisible by 5 * interval)
                        const isMajor = highlightMajor && (Math.abs(level % (5 * interval)) < 0.001);
                        
                        const line = L.polyline(latLngs, {
                            color: style.color,
                            weight: isMajor ? style.weight * 1.5 : style.weight,
                            opacity: style.opacity,
                            smoothFactor: style.smoothing,
                            noClip: false
                        });
                        
                        line.bindPopup(`Elevation: ${level.toFixed(2)}m`);
                        contourLayers.push(line);
                        
                        // Add labels at eastern (rightmost) extent of contour lines
                        const shouldLabel = showLabels && (levelIdx % labelFreq === 0) && latLngs.length > 10;
                        if (shouldLabel) {
                            // Find the easternmost point (maximum longitude)
                            let easternmostIdx = 0;
                            let maxLng = latLngs[0][1]; // [lat, lng] format
                            
                            for (let i = 1; i < latLngs.length; i++) {
                                if (latLngs[i][1] > maxLng) {
                                    maxLng = latLngs[i][1];
                                    easternmostIdx = i;
                                }
                            }
                            
                            const labelIcon = L.divIcon({
                                className: 'contour-label',
                                html: `<div style="background: rgba(255,255,255,0.9); padding: 2px 6px; border-radius: 3px; font-size: ${labelSize}px; font-weight: ${isMajor ? 'bold' : '600'}; color: ${style.color}; border: 1px solid ${style.color}; white-space: nowrap; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">${level.toFixed(2)}m</div>`,
                                iconSize: [60, 20],
                                iconAnchor: [0, 10]  // Anchor at left edge, vertically centered
                            });
                            const marker = L.marker(latLngs[easternmostIdx], { icon: labelIcon });
                            contourLayers.push(marker);
                        }
                    }
                });
            });
            
            if (contourLayers.length > 0) {
                krigingContoursLayer = L.layerGroup(contourLayers).addTo(contourMap);
                
                // Get actual bounds from selected data points, not contour layers
                const selectedData = getSelectedData();
                if (selectedData.length > 0) {
                    const lats = selectedData.map(p => parseFloat(p.Latitude));
                    const lngs = selectedData.map(p => parseFloat(p.Longitude));
                    const pointBounds = L.latLngBounds(
                        [Math.min(...lats), Math.min(...lngs)],
                        [Math.max(...lats), Math.max(...lngs)]
                    );
                    contourMap.fitBounds(pointBounds.pad(0.1));
                }
            }
            
            // Add survey points to contour map if enabled
            if (showSurveyPoints) {
                selectedData.forEach(p => {
                    const lat = parseFloat(p.Latitude);
                    const lng = parseFloat(p.Longitude);
                    
                    // Validate coordinates are in expected range for Perth area
                    if (lat < -34 && lat > -32 && lng > 115 && lng < 116) {
                        const marker = L.circleMarker([lat, lng], {
                            radius: 5,
                            fillColor: '#00ff00',
                            color: '#fff',
                            weight: 2,
                            fillOpacity: 0.9
                        }).addTo(contourMap);
                        marker.bindPopup(`${p.Name}<br>Elev: ${p.Elevation}m<br>Lat: ${lat.toFixed(6)}<br>Lng: ${lng.toFixed(6)}`);
                    }
                });
            }
        }
        
        function connectContourSegmentsImproved(segments, dx, dy) {
            if (segments.length === 0) return [];
            
            const polylines = [];
            const used = new Array(segments.length).fill(false);
            // Much more aggressive tolerance - use full grid cell diagonal
            const tolerance = Math.sqrt(dx * dx + dy * dy) * 0.5;
            
            // First pass: connect obvious neighbors
            for (let i = 0; i < segments.length; i++) {
                if (used[i]) continue;
                
                const polyline = [segments[i].start, segments[i].end];
                used[i] = true;
                
                // Keep extending until no more connections found
                let foundConnection = true;
                let safetyCounter = 0;
                const maxAttempts = segments.length * 2;
                
                while (foundConnection && safetyCounter < maxAttempts) {
                    foundConnection = false;
                    safetyCounter++;
                    
                    const lastPoint = polyline[polyline.length - 1];
                    const firstPoint = polyline[0];
                    
                    let bestMatch = -1;
                    let bestDist = tolerance;
                    let bestConnection = null;
                    
                    // Find the closest segment to connect
                    for (let j = 0; j < segments.length; j++) {
                        if (used[j]) continue;
                        
                        // Check all four possible connections
                        const connections = [
                            { dist: Math.hypot(lastPoint.lon - segments[j].start.lon, lastPoint.lat - segments[j].start.lat), 
                              type: 'lastToStart', point: segments[j].end },
                            { dist: Math.hypot(lastPoint.lon - segments[j].end.lon, lastPoint.lat - segments[j].end.lat), 
                              type: 'lastToEnd', point: segments[j].start },
                            { dist: Math.hypot(firstPoint.lon - segments[j].end.lon, firstPoint.lat - segments[j].end.lat), 
                              type: 'firstToEnd', point: segments[j].start },
                            { dist: Math.hypot(firstPoint.lon - segments[j].start.lon, firstPoint.lat - segments[j].start.lat), 
                              type: 'firstToStart', point: segments[j].end }
                        ];
                        
                        // Find closest connection for this segment
                        for (const conn of connections) {
                            if (conn.dist < bestDist) {
                                bestDist = conn.dist;
                                bestMatch = j;
                                bestConnection = conn;
                            }
                        }
                    }
                    
                    // Make the best connection if found
                    if (bestMatch >= 0 && bestConnection) {
                        used[bestMatch] = true;
                        foundConnection = true;
                        
                        if (bestConnection.type === 'lastToStart' || bestConnection.type === 'lastToEnd') {
                            polyline.push(bestConnection.point);
                        } else {
                            polyline.unshift(bestConnection.point);
                        }
                    }
                }
                
                // Check if polyline forms a closed loop
                if (polyline.length > 3) {
                    const firstPt = polyline[0];
                    const lastPt = polyline[polyline.length - 1];
                    const closeDist = Math.hypot(firstPt.lon - lastPt.lon, firstPt.lat - lastPt.lat);
                    if (closeDist < tolerance * 2) {
                        polyline.push({ lon: firstPt.lon, lat: firstPt.lat }); // Close the loop
                    }
                }
                
                // Only add polylines with at least 2 points
                if (polyline.length >= 2) {
                    polylines.push(polyline);
                }
            }
            
            // Second pass: try to connect remaining segments with even more tolerance
            const remaining = [];
            for (let i = 0; i < segments.length; i++) {
                if (!used[i]) {
                    remaining.push(segments[i]);
                }
            }
            
            if (remaining.length > 0) {
                const extraTolerance = tolerance * 2;
                
                for (let i = 0; i < remaining.length; i++) {
                    const seg = remaining[i];
                    let added = false;
                    
                    // Try to add to existing polylines
                    for (let p = 0; p < polylines.length && !added; p++) {
                        const poly = polylines[p];
                        const lastPt = poly[poly.length - 1];
                        const firstPt = poly[0];
                        
                        const distLastToStart = Math.hypot(lastPt.lon - seg.start.lon, lastPt.lat - seg.start.lat);
                        const distLastToEnd = Math.hypot(lastPt.lon - seg.end.lon, lastPt.lat - seg.end.lat);
                        const distFirstToStart = Math.hypot(firstPt.lon - seg.start.lon, firstPt.lat - seg.start.lat);
                        const distFirstToEnd = Math.hypot(firstPt.lon - seg.end.lon, firstPt.lat - seg.end.lat);
                        
                        if (distLastToStart < extraTolerance) {
                            poly.push(seg.end);
                            added = true;
                        } else if (distLastToEnd < extraTolerance) {
                            poly.push(seg.start);
                            added = true;
                        } else if (distFirstToStart < extraTolerance) {
                            poly.unshift(seg.end);
                            added = true;
                        } else if (distFirstToEnd < extraTolerance) {
                            poly.unshift(seg.start);
                            added = true;
                        }
                    }
                    
                    // If still not added, create new polyline
                    if (!added) {
                        polylines.push([seg.start, seg.end]);
                    }
                }
            }
            
            return polylines;
        }

        function updateFilters() {
            const elevSlider = document.getElementById('elevationSlider');
            const rmsSlider = document.getElementById('rmsSlider');

            const elevThreshold = elevationRange.min + (elevationRange.max - elevationRange.min) * (elevSlider.value / 100);
            const rmsThreshold = rmsRange.min + (rmsRange.max - rmsRange.min) * (rmsSlider.value / 100);

            filteredData = surveyData.filter(point => {
                const elev = parseFloat(point.Elevation || 0);
                const rms = parseFloat(point['Lateral RMS'] || 0);
                return elev <= elevThreshold && rms <= rmsThreshold;
            });

            updateFilterLabels();
            updateMap();
            updateStats();
            
            if (showingHeatmap) {
                toggleHeatmap();
                toggleHeatmap();
            }
            if (showingContours) {
                toggleContours();
                toggleContours();
            }
        }

        function updateFilterLabels() {
            const elevSlider = document.getElementById('elevationSlider');
            const rmsSlider = document.getElementById('rmsSlider');

            const elevThreshold = elevationRange.min + (elevationRange.max - elevationRange.min) * (elevSlider.value / 100);
            const rmsThreshold = rmsRange.min + (rmsRange.max - rmsRange.min) * (rmsSlider.value / 100);

            document.getElementById('elevationValue').textContent = 
                elevSlider.value == 100 ? 'All' : `‚â§ ${elevThreshold.toFixed(2)}m`;
            document.getElementById('rmsValue').textContent = 
                rmsSlider.value == 100 ? 'All' : `‚â§ ${rmsThreshold.toFixed(3)}`;
        }

        function updateMarkerSize() {
            const size = document.getElementById('markerSizeSlider').value;
            document.getElementById('markerSizeValue').textContent = size;
            updateMap();
        }

        function updateHeatmapIntensity() {
            const intensity = document.getElementById('heatmapIntensitySlider').value / 100;
            document.getElementById('heatmapIntensityValue').textContent = intensity.toFixed(2);
            
            if (showingHeatmap && heatmapLayer) {
                map.removeLayer(heatmapLayer);
                heatmapLayer = null;
                toggleHeatmap();
            }
        }

        function updateContourInterval() {
            const sliderValue = parseInt(document.getElementById('contourIntervalSlider').value);
            
            // Map slider positions to specific intervals: 0.1, 0.2, 0.25, 0.5, 1, 2, 3, 4, 5, 10, 20
            const intervals = [0.1, 0.2, 0.25, 0.5, 1, 2, 3, 4, 5, 10, 20];
            contourInterval = intervals[sliderValue];
            
            document.getElementById('contourIntervalValue').textContent = contourInterval;
            
            if (showingContours && contoursLayer) {
                map.removeLayer(contoursLayer);
                contoursLayer = null;
                toggleContours();
            }
        }

        // Color gradient function (shared by heatmap, contours, and 3D visualizations)
        function getColorForValue(norm) {
            // Better color gradient: blue -> cyan -> green -> yellow -> red
            if (norm < 0.25) {
                const t = norm / 0.25;
                return {
                    r: 0,
                    g: Math.floor(t * 255),
                    b: 255
                };
            } else if (norm < 0.5) {
                const t = (norm - 0.25) / 0.25;
                return {
                    r: 0,
                    g: 255,
                    b: Math.floor((1 - t) * 255)
                };
            } else if (norm < 0.75) {
                const t = (norm - 0.5) / 0.25;
                return {
                    r: Math.floor(t * 255),
                    g: 255,
                    b: 0
                };
            } else {
                const t = (norm - 0.75) / 0.25;
                return {
                    r: 255,
                    g: Math.floor((1 - t) * 255),
                    b: 0
                };
            }
        }

        function toggleHeatmap() {
            const selectedData = getSelectedData();
            if (selectedData.length === 0) {
                showError('No selected points to display');
                return;
            }

            const btn = document.getElementById('heatmapBtn');

            if (showingHeatmap) {
                if (heatmapLayer) {
                    map.removeLayer(heatmapLayer);
                    heatmapLayer = null;
                }
                if (heatmapBoundaryLayer) {
                    map.removeLayer(heatmapBoundaryLayer);
                    heatmapBoundaryLayer = null;
                }
                if (heatmapLegend) {
                    map.removeControl(heatmapLegend);
                    heatmapLegend = null;
                }
                showingHeatmap = false;
                btn.classList.remove('active');
            } else {
                createHeatmap();
                showingHeatmap = true;
                btn.classList.add('active');
            }
        }

        function createHeatmap() {
            const intensity = parseFloat(document.getElementById('heatmapIntensitySlider').value) / 100;
            
            const selectedData = getSelectedData();
            
            // Create heatmap data with boundary restriction
            const heatData = selectedData.map(point => {
                const lat = parseFloat(point.Latitude);
                const lng = parseFloat(point.Longitude);
                const elevation = parseFloat(point.Elevation || 0);
                
                // Normalize elevation for intensity
                const normalizedElev = (elevation - elevationRange.min) / (elevationRange.max - elevationRange.min);
                
                return [lat, lng, normalizedElev];
            });

            heatmapLayer = L.heatLayer(heatData, {
                radius: 40,  // Reduced radius to stay closer to points
                blur: 20,    // Reduced blur to avoid spreading too far
                maxZoom: 17,
                max: 1.0,
                minOpacity: 0,  // Fade to transparent at edges
                gradient: {
                    0.0: 'blue',
                    0.2: 'cyan',
                    0.4: 'lime',
                    0.6: 'yellow',
                    0.8: 'orange',
                    1.0: 'red'
                }
            }).addTo(map);
            
            // Add boundary polygon showing interpolation area (convex hull)
            addHeatmapBoundary(selectedData);
            
            // Add heatmap legend
            addHeatmapLegend();
        }

        let heatmapBoundaryLayer = null;

        function addHeatmapBoundary(selectedData) {
            // Remove existing boundary
            if (heatmapBoundaryLayer) {
                map.removeLayer(heatmapBoundaryLayer);
            }
            
            if (selectedData.length < 3) return;
            
            // Create convex hull around survey points
            const points = selectedData.map(p => ({
                x: parseFloat(p.Longitude),
                y: parseFloat(p.Latitude)
            }));
            
            const hull = convexHull(points);
            
            if (hull.length < 3) return;
            
            // Convert to LatLng format
            const boundaryCoords = hull.map(p => [p.y, p.x]);
            boundaryCoords.push(boundaryCoords[0]); // Close the polygon
            
            // Add boundary line to map
            heatmapBoundaryLayer = L.polygon(boundaryCoords, {
                color: '#3498db',
                weight: 2,
                opacity: 0.8,
                fill: false,
                dashArray: '5, 5'
            }).addTo(map);
            
            heatmapBoundaryLayer.bindPopup('<strong>Interpolation Boundary</strong><br>Heatmap is restricted to area within survey points');
        }

        let heatmapLegend = null;

        function addHeatmapLegend() {
            // Remove existing legend if present
            if (heatmapLegend) {
                map.removeControl(heatmapLegend);
            }
            
            heatmapLegend = L.control({ position: 'bottomleft' });
            
            heatmapLegend.onAdd = function(map) {
                const div = L.DomUtil.create('div', 'heatmap-legend');
                div.style.cssText = `
                    background: white;
                    padding: 10px;
                    border-radius: 8px;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                    font-size: 12px;
                `;
                
                div.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 8px;">Elevation (m)</div>
                    <div style="display: flex; align-items: center; margin-bottom: 4px;">
                        <div style="width: 20px; height: 15px; background: red; margin-right: 8px; border: 1px solid #ccc;"></div>
                        <span>${elevationRange.max.toFixed(1)}m (High)</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 4px;">
                        <div style="width: 20px; height: 15px; background: orange; margin-right: 8px; border: 1px solid #ccc;"></div>
                        <span>${(elevationRange.min + (elevationRange.max - elevationRange.min) * 0.8).toFixed(1)}m</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 4px;">
                        <div style="width: 20px; height: 15px; background: yellow; margin-right: 8px; border: 1px solid #ccc;"></div>
                        <span>${(elevationRange.min + (elevationRange.max - elevationRange.min) * 0.6).toFixed(1)}m</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 4px;">
                        <div style="width: 20px; height: 15px; background: lime; margin-right: 8px; border: 1px solid #ccc;"></div>
                        <span>${(elevationRange.min + (elevationRange.max - elevationRange.min) * 0.4).toFixed(1)}m</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 4px;">
                        <div style="width: 20px; height: 15px; background: cyan; margin-right: 8px; border: 1px solid #ccc;"></div>
                        <span>${(elevationRange.min + (elevationRange.max - elevationRange.min) * 0.2).toFixed(1)}m</span>
                    </div>
                    <div style="display: flex; align-items: center;">
                        <div style="width: 20px; height: 15px; background: blue; margin-right: 8px; border: 1px solid #ccc;"></div>
                        <span>${elevationRange.min.toFixed(1)}m (Low)</span>
                    </div>
                `;
                
                return div;
            };
            
            heatmapLegend.addTo(map);
        }

        function toggleContours() {
            const selectedData = getSelectedData();
            if (selectedData.length < 3) {
                showError('Need at least 3 selected points to display contours');
                return;
            }

            const btn = document.getElementById('contourBtn');

            if (showingContours) {
                if (contoursLayer) {
                    map.removeLayer(contoursLayer);
                    contoursLayer = null;
                }
                showingContours = false;
                btn.classList.remove('active');
            } else {
                createContours();
                showingContours = true;
                btn.classList.add('active');
            }
        }

        function createContours() {
            const selectedData = getSelectedData();
            if (selectedData.length < 3) return;
            
            const pts = turf.featureCollection(
                selectedData.map(p =>
                    turf.point([+p.Longitude, +p.Latitude], {
                        elevation: +p.Elevation
                    })
                )
            );
            
            const interpolated = turf.interpolate(pts, 10, {
                gridType: 'points',
                property: 'elevation',
                units: 'degrees'
            });
            
            const elevs = selectedData.map(p => +p.Elevation);
            const minE = Math.min(...elevs);
            const maxE = Math.max(...elevs);
            const breaks = [];
            
            // Start from the first multiple of contourInterval at or below minE
            const startElev = Math.floor(minE / contourInterval) * contourInterval;
            
            for (let z = startElev; z <= maxE; z += contourInterval) {
                breaks.push(z);
            }

            const contours = turf.isolines(interpolated, breaks, {
                zProperty: 'elevation'
            });

            contoursLayer = L.geoJSON(contours, {
                style: feature => {
                    const elev = feature.properties.elevation;
                    const normalizedElev = (elev - minE) / (maxE - minE);
                    const hue = (1 - normalizedElev) * 240;
                    
                    return {
                        color: `hsl(${hue}, 70%, 40%)`,
                        weight: 2,
                        opacity: 0.8
                    };
                },
                onEachFeature: (f, l) => l.bindPopup(`Elevation: ${f.properties.elevation.toFixed(3)} m`)
            }).addTo(map);
        }

        function toggleTIN() {
            const selectedData = getSelectedData();
            if (selectedData.length < 3) {
                showError('Need at least 3 selected points to create TIN surface');
                return;
            }

            const btn = document.getElementById('tinBtn');

            if (showingTIN) {
                if (tinLayer) {
                    map.removeLayer(tinLayer);
                    tinLayer = null;
                }
                showingTIN = false;
                btn.classList.remove('active');
            } else {
                createTINSurface();
                showingTIN = true;
                btn.classList.add('active');
            }
        }

        function createTINSurface() {
            const selectedData = getSelectedData();
            if (selectedData.length < 3) {
                showError('Need at least 3 selected points to create TIN surface');
                return;
            }
            
            const points = selectedData.map(point => ({
                x: parseFloat(point.Longitude),
                y: parseFloat(point.Latitude),
                z: parseFloat(point.Elevation || 0)
            }));

            // Simple convex hull triangulation for visualization
            const triangles = simpleTriangulation(points);

            if (triangles.length === 0) {
                showError('Could not generate triangulation');
                return;
            }

            const trianglePolygons = [];
            const elevations = points.map(p => p.z);
            const minElev = Math.min(...elevations);
            const maxElev = Math.max(...elevations);

            triangles.forEach((triangle, index) => {
                const avgElev = (triangle[0].z + triangle[1].z + triangle[2].z) / 3;
                const normalizedElev = maxElev > minElev ? (avgElev - minElev) / (maxElev - minElev) : 0.5;
                const hue = (1 - normalizedElev) * 240;
                const color = `hsl(${hue}, 70%, 50%)`;

                const coords = triangle.map(point => [point.y, point.x]);
                coords.push(coords[0]);

                const polygon = L.polygon(coords, {
                    color: color,
                    fillColor: color,
                    fillOpacity: 0.4,
                    weight: 1,
                    opacity: 0.6
                });

                polygon.bindPopup(`
                    <div class="marker-info">
                        <h4>TIN Triangle #${index + 1}</h4>
                        <p><strong>Average Elevation:</strong> ${avgElev.toFixed(3)}m</p>
                    </div>
                `);

                trianglePolygons.push(polygon);
            });

            tinLayer = L.layerGroup(trianglePolygons).addTo(map);
        }

        function simpleTriangulation(points) {
            if (points.length < 3) return [];

            const triangles = [];
            const hull = convexHull(points);

            for (let i = 1; i < hull.length - 1; i++) {
                triangles.push([hull[0], hull[i], hull[i + 1]]);
            }

            return triangles;
        }

        function convexHull(points) {
            if (points.length < 3) return points;

            const sorted = [...points].sort((a, b) => a.x - b.x || a.y - b.y);

            const lower = [];
            for (let point of sorted) {
                while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], point) <= 0) {
                    lower.pop();
                }
                lower.push(point);
            }

            const upper = [];
            for (let i = sorted.length - 1; i >= 0; i--) {
                const point = sorted[i];
                while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], point) <= 0) {
                    upper.pop();
                }
                upper.push(point);
            }

            lower.pop();
            upper.pop();

            return lower.concat(upper);
        }

        function cross(o, a, b) {
            return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
        }

        // Kriging interpolation class for smooth ground surface
        class GroundKriging {
            constructor(points, values, smoothing = 3, nuggetPercent = 5, influenceRadius = 1.5) {
                this.points = points;
                this.values = values;
                this.smoothing = smoothing;
                this.nuggetPercent = nuggetPercent;
                this.influenceRadius = influenceRadius;
                this.calculateVariogram();
            }
            
            calculateVariogram() {
                const variance = this.calculateVariance();
                const avgDist = this.calculateAverageDistance();
                
                // Adjusted for smoother kriging that passes through points
                this.nugget = variance * (this.nuggetPercent / 100);
                this.sill = variance * (1 - this.nuggetPercent / 100);
                // Much larger range for broader influence
                this.range = avgDist * (0.8 + this.smoothing * 0.3) * this.influenceRadius;
            }
            
            calculateVariance() {
                const mean = this.values.reduce((a, b) => a + b, 0) / this.values.length;
                return this.values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / this.values.length;
            }
            
            calculateAverageDistance() {
                let totalDist = 0, count = 0;
                for (let i = 0; i < this.points.length; i++) {
                    for (let j = i + 1; j < this.points.length; j++) {
                        const dx = this.points[i].x - this.points[j].x;
                        const dy = this.points[i].y - this.points[j].y;
                        totalDist += Math.sqrt(dx * dx + dy * dy);
                        count++;
                    }
                }
                return count > 0 ? totalDist / count : 100;
            }
            
            variogram(h) {
                if (h === 0) return 0;
                if (h <= this.range) {
                    const ratio = h / this.range;
                    return this.nugget + this.sill * (1.5 * ratio - 0.5 * ratio * ratio * ratio);
                }
                return this.nugget + this.sill;
            }
            
            predict(x, y, interpPower = 2.0) {
                let sumWeights = 0, sumValues = 0;
                const minDist = 0.00001; // Very small threshold for exact matches
                
                // Check if we're at an exact survey point location
                for (let i = 0; i < this.points.length; i++) {
                    const dx = x - this.points[i].x;
                    const dy = y - this.points[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // If we're essentially at a survey point, return its exact value
                    if (dist < minDist) {
                        return this.values[i];
                    }
                }
                
                // Kriging interpolation for points between survey locations
                for (let i = 0; i < this.points.length; i++) {
                    const dx = x - this.points[i].x;
                    const dy = y - this.points[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Use variogram-based weights with configurable power
                    const gamma = this.variogram(dist);
                    const weight = 1 / Math.pow(gamma + 0.001, interpPower);
                    
                    sumWeights += weight;
                    sumValues += weight * this.values[i];
                }
                
                return sumWeights > 0 ? sumValues / sumWeights : 0;
            }
            
            interpolateGrid(bounds, resolution, interpPower = 2.0, gaussianSmooth = 0) {
                const { minX, maxX, minY, maxY } = bounds;
                const dx = (maxX - minX) / resolution;
                const dy = (maxY - minY) / resolution;
                
                const grid = [];
                for (let i = 0; i <= resolution; i++) {
                    const row = [];
                    for (let j = 0; j <= resolution; j++) {
                        const x = minX + j * dx;
                        const y = minY + i * dy;
                        row.push(this.predict(x, y, interpPower));
                    }
                    grid.push(row);
                }
                
                // Apply Gaussian smoothing if requested
                let smoothedGrid = grid;
                if (gaussianSmooth > 0) {
                    smoothedGrid = this.applyGaussianSmooth(grid, resolution, gaussianSmooth);
                }
                
                return {
                    grid: smoothedGrid,
                    bounds: bounds,
                    resolution: resolution,
                    dx: dx,
                    dy: dy
                };
            }
            
            applyGaussianSmooth(grid, resolution, smoothLevel) {
                if (smoothLevel === 0) return grid;
                
                const smoothed = [];
                const kernelSize = Math.min(smoothLevel * 2 + 1, 11); // Max 11x11 kernel
                const sigma = smoothLevel;
                const offset = Math.floor(kernelSize / 2);
                
                // Generate Gaussian kernel
                const kernel = [];
                let kernelSum = 0;
                for (let i = 0; i < kernelSize; i++) {
                    kernel[i] = [];
                    for (let j = 0; j < kernelSize; j++) {
                        const x = i - offset;
                        const y = j - offset;
                        const value = Math.exp(-(x*x + y*y) / (2 * sigma * sigma));
                        kernel[i][j] = value;
                        kernelSum += value;
                    }
                }
                
                // Normalize kernel
                for (let i = 0; i < kernelSize; i++) {
                    for (let j = 0; j < kernelSize; j++) {
                        kernel[i][j] /= kernelSum;
                    }
                }
                
                // Apply convolution
                for (let i = 0; i <= resolution; i++) {
                    const row = [];
                    for (let j = 0; j <= resolution; j++) {
                        let sum = 0;
                        let weightSum = 0;
                        
                        for (let ki = 0; ki < kernelSize; ki++) {
                            for (let kj = 0; kj < kernelSize; kj++) {
                                const ii = i + ki - offset;
                                const jj = j + kj - offset;
                                
                                if (ii >= 0 && ii <= resolution && jj >= 0 && jj <= resolution) {
                                    const weight = kernel[ki][kj];
                                    sum += grid[ii][jj] * weight;
                                    weightSum += weight;
                                }
                            }
                        }
                        
                        row.push(sum / weightSum);
                    }
                    smoothed.push(row);
                }
                
                return smoothed;
            }
        }

        // Cross Section Functions
        function startCrossSection() {
            const btn = document.getElementById('crossSectionBtn');
            const instructions = document.getElementById('drawingInstructions');

            if (drawingCrossSection) {
                // Cancel drawing
                drawingCrossSection = false;
                crossSectionPoints = [];
                if (crossSectionLine) {
                    map.removeLayer(crossSectionLine);
                    crossSectionLine = null;
                }
                btn.classList.remove('active');
                instructions.classList.remove('active');
                map.off('click', handleCrossSectionClick);
            } else {
                // Start drawing
                drawingCrossSection = true;
                crossSectionPoints = [];
                btn.classList.add('active');
                instructions.classList.add('active');
                map.on('click', handleCrossSectionClick);
            }
        }

        function handleCrossSectionClick(e) {
            crossSectionPoints.push([e.latlng.lat, e.latlng.lng]);

            if (crossSectionPoints.length === 1) {
                // First point
                if (crossSectionLine) {
                    map.removeLayer(crossSectionLine);
                }
                crossSectionLine = L.polyline(crossSectionPoints, {
                    color: 'red',
                    weight: 3,
                    opacity: 0.8
                }).addTo(map);
            } else if (crossSectionPoints.length === 2) {
                // Second point - complete the line
                crossSectionLine.setLatLngs(crossSectionPoints);
                generateCrossSection();
                
                // Reset drawing mode
                drawingCrossSection = false;
                document.getElementById('crossSectionBtn').classList.remove('active');
                document.getElementById('drawingInstructions').classList.remove('active');
                map.off('click', handleCrossSectionClick);
            }
        }

        function generateCrossSection() {
            if (crossSectionPoints.length !== 2) return;

            const [start, end] = crossSectionPoints;
            const line = turf.lineString([[start[1], start[0]], [end[1], end[0]]]);
            const length = turf.length(line, { units: 'meters' });

            // Sample points along the line
            const numSamples = 100;
            const samplePoints = [];
            
            const selectedData = getSelectedData();
            
            for (let i = 0; i <= numSamples; i++) {
                const distance = (i / numSamples) * length;
                const point = turf.along(line, distance, { units: 'meters' });
                
                // Find nearest survey point and interpolate elevation
                const coords = point.geometry.coordinates;
                let nearestDist = Infinity;
                let nearestElev = 0;
                
                selectedData.forEach(p => {
                    const pLng = parseFloat(p.Longitude);
                    const pLat = parseFloat(p.Latitude);
                    const dist = Math.sqrt(
                        Math.pow(coords[0] - pLng, 2) + 
                        Math.pow(coords[1] - pLat, 2)
                    );
                    
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestElev = parseFloat(p.Elevation || 0);
                    }
                });
                
                samplePoints.push({
                    distance: distance,
                    elevation: nearestElev,
                    lat: coords[1],
                    lng: coords[0]
                });
            }

            displayCrossSection(samplePoints, length);
        }

        let crossSectionMarker = null;

        function displayCrossSection(samplePoints, totalLength) {
            const panel = document.getElementById('crossSectionPanel');
            panel.classList.add('active');

            const ctx = document.getElementById('crossSectionChart').getContext('2d');

            if (crossSectionChart) {
                crossSectionChart.destroy();
            }

            // Calculate elevation range
            const elevations = samplePoints.map(p => p.elevation);
            const minElev = Math.min(...elevations);
            const maxElev = Math.max(...elevations);
            const elevRange = maxElev - minElev;
            
            // For true 1:1 scale, Y-axis must span same range as X-axis
            const range = Math.max(totalLength, elevRange);
            const yCenter = (minElev + maxElev) / 2;
            
            // Calculate Y-axis bounds to center the elevation data
            const yMin = yCenter - range / 2;
            const yMax = yCenter + range / 2;

            crossSectionChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: samplePoints.map(p => p.distance.toFixed(1)),
                    datasets: [{
                        label: 'Elevation (m)',
                        data: samplePoints.map(p => p.elevation),
                        borderColor: 'rgb(52, 152, 219)',
                        backgroundColor: 'rgba(52, 152, 219, 0.1)',
                        fill: true,
                        tension: 0,  // No smoothing - sharp angles
                        pointRadius: 0,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1,  // 1:1 aspect ratio - square chart
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        title: {
                            display: true,
                            text: `Cross Section Profile - TRUE 1:1 SCALE (1m vertical = 1m horizontal)`
                        },
                        subtitle: {
                            display: true,
                            text: `Total Length: ${totalLength.toFixed(1)}m | Elevation Range: ${elevRange.toFixed(1)}m`
                        },
                        tooltip: {
                            enabled: true,
                            callbacks: {
                                title: function(context) {
                                    const index = context[0].dataIndex;
                                    return `Distance: ${samplePoints[index].distance.toFixed(1)}m`;
                                },
                                label: function(context) {
                                    return `Elevation: ${context.parsed.y.toFixed(3)}m`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Distance (m)'
                            },
                            min: 0,
                            max: range,  // Use same range as Y
                            ticks: {
                                stepSize: Math.ceil(range / 10)
                            }
                        },
                        y: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Elevation (m)'
                            },
                            min: yMin,
                            max: yMax,  // Y-axis spans same range as X
                            ticks: {
                                stepSize: Math.ceil(range / 10)
                            }
                        }
                    },
                    onHover: (event, activeElements) => {
                        if (activeElements.length > 0) {
                            const index = activeElements[0].index;
                            const point = samplePoints[index];
                            
                            // Update or create marker on map showing position on cross-section line
                            if (crossSectionMarker) {
                                map.removeLayer(crossSectionMarker);
                            }
                            
                            crossSectionMarker = L.marker([point.lat, point.lng], {
                                icon: L.divIcon({
                                    className: 'cross-section-marker',
                                    html: '<div style="background: red; width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-top: 12px solid red; margin-left: -8px; margin-top: -12px;"></div>',
                                    iconSize: [16, 12],
                                    iconAnchor: [8, 12]
                                })
                            }).addTo(map);
                        }
                    }
                }
            });

            // Remove marker when mouse leaves chart
            const chartCanvas = document.getElementById('crossSectionChart');
            chartCanvas.addEventListener('mouseleave', () => {
                if (crossSectionMarker) {
                    map.removeLayer(crossSectionMarker);
                    crossSectionMarker = null;
                }
            });
            
            // Add image overlay controls if not already present
            if (!document.getElementById('xsectionOverlayControls')) {
                const overlayControls = document.createElement('div');
                overlayControls.id = 'xsectionOverlayControls';
                overlayControls.style.cssText = `
                    margin-top: 15px;
                    padding: 15px;
                    background: #f8f9fa;
                    border-radius: 8px;
                    border: 2px solid #3498db;
                `;
                
                overlayControls.innerHTML = `
                    <div style="font-weight: 600; margin-bottom: 10px; color: #2c3e50;">
                        üì∑ Image Overlay
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                        <input type="file" id="xsectionImageUpload" accept="image/*" 
                               style="flex: 1; padding: 8px; border: 2px solid #3498db; border-radius: 5px; font-size: 12px;">
                        <button onclick="removeXSectionOverlay()" 
                                style="padding: 8px 15px; background: #e74c3c; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                            Remove
                        </button>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 12px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px;">Opacity: <span id="overlayOpacityValue">50%</span></label>
                            <input type="range" id="overlayOpacity" min="0" max="100" value="50" 
                                   style="width: 100%;" onchange="updateOverlayOpacity(this.value)">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px;">Position X: <span id="overlayXValue">0</span></label>
                            <input type="range" id="overlayX" min="-100" max="100" value="0" 
                                   style="width: 100%;" onchange="updateOverlayPosition()">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px;">Position Y: <span id="overlayYValue">0</span></label>
                            <input type="range" id="overlayY" min="-100" max="100" value="0" 
                                   style="width: 100%;" onchange="updateOverlayPosition()">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px;">Scale: <span id="overlayScaleValue">100%</span></label>
                            <input type="range" id="overlayScale" min="10" max="200" value="100" 
                                   style="width: 100%;" onchange="updateOverlayScale(this.value)">
                        </div>
                    </div>
                `;
                
                // Insert into cross-section body
                const chartCanvas = document.getElementById('crossSectionChart');
                chartCanvas.parentNode.appendChild(overlayControls);
                
                // Setup file upload handler
                document.getElementById('xsectionImageUpload').addEventListener('change', handleXSectionImageUpload);
            }
        }

        let xsectionOverlayImage = null;

        function handleXSectionImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                xsectionOverlayImage = new Image();
                xsectionOverlayImage.src = e.target.result;
                xsectionOverlayImage.onload = function() {
                    addImageToChart();
                };
            };
            reader.readAsDataURL(file);
        }

        function addImageToChart() {
            if (!crossSectionChart || !xsectionOverlayImage) return;
            
            // Add image as a plugin
            const imagePlugin = {
                id: 'backgroundImage',
                beforeDraw: (chart) => {
                    if (xsectionOverlayImage) {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        
                        ctx.save();
                        
                        // Get overlay settings
                        const opacity = parseFloat(document.getElementById('overlayOpacity').value) / 100;
                        const xOffset = parseFloat(document.getElementById('overlayX').value);
                        const yOffset = parseFloat(document.getElementById('overlayY').value);
                        const scale = parseFloat(document.getElementById('overlayScale').value) / 100;
                        
                        ctx.globalAlpha = opacity;
                        
                        const imgWidth = (chartArea.right - chartArea.left) * scale;
                        const imgHeight = (xsectionOverlayImage.height / xsectionOverlayImage.width) * imgWidth;
                        
                        const x = chartArea.left + xOffset + (chartArea.right - chartArea.left - imgWidth) / 2;
                        const y = chartArea.top + yOffset + (chartArea.bottom - chartArea.top - imgHeight) / 2;
                        
                        ctx.drawImage(xsectionOverlayImage, x, y, imgWidth, imgHeight);
                        
                        ctx.restore();
                    }
                }
            };
            
            // Remove old plugin and add new one
            Chart.unregister(imagePlugin);
            Chart.register(imagePlugin);
            
            crossSectionChart.update();
        }

        function updateOverlayOpacity(value) {
            document.getElementById('overlayOpacityValue').textContent = value + '%';
            if (crossSectionChart) crossSectionChart.update();
        }

        function updateOverlayPosition() {
            const x = document.getElementById('overlayX').value;
            const y = document.getElementById('overlayY').value;
            document.getElementById('overlayXValue').textContent = x;
            document.getElementById('overlayYValue').textContent = y;
            if (crossSectionChart) crossSectionChart.update();
        }

        function updateOverlayScale(value) {
            document.getElementById('overlayScaleValue').textContent = value + '%';
            if (crossSectionChart) crossSectionChart.update();
        }

        function removeXSectionOverlay() {
            xsectionOverlayImage = null;
            document.getElementById('xsectionImageUpload').value = '';
            if (crossSectionChart) {
                Chart.unregister({ id: 'backgroundImage' });
                crossSectionChart.update();
            }
        }

        function closeCrossSection() {
            document.getElementById('crossSectionPanel').classList.remove('active');
            if (crossSectionLine) {
                map.removeLayer(crossSectionLine);
                crossSectionLine = null;
            }
            if (crossSectionMarker) {
                map.removeLayer(crossSectionMarker);
                crossSectionMarker = null;
            }
            crossSectionPoints = [];
        }

        function updateMap() {
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];

            const selectedData = getSelectedData();
            if (selectedData.length === 0) return;

            const markerSize = parseInt(document.getElementById('markerSizeSlider').value);

            selectedData.forEach((point, index) => {
                const lat = parseFloat(point.Latitude);
                const lng = parseFloat(point.Longitude);

                if (isNaN(lat) || isNaN(lng)) return;

                const iconColor = point['Solution status'] === 'FIX' ? 'green' : 'orange';

                const marker = L.circleMarker([lat, lng], {
                    radius: markerSize,
                    fillColor: iconColor,
                    color: '#fff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                }).addTo(map);

                const popupContent = `
                    <div class="marker-info">
                        <h4>Point ${point.Name}</h4>
                        <p><strong>Coordinates:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}</p>
                        <p><strong>Elevation:</strong> ${parseFloat(point.Elevation).toFixed(3)}m</p>
                        <p><strong>Description:</strong> ${point.Description}</p>
                        <p><strong>Solution Status:</strong> ${point['Solution status']}</p>
                        <p><strong>Lateral RMS:</strong> ${parseFloat(point['Lateral RMS'] || 0).toFixed(3)}</p>
                    </div>
                `;

                marker.bindPopup(popupContent);
                markers.push(marker);
            });

            if (markers.length > 0) {
                const group = new L.featureGroup(markers);
                map.fitBounds(group.getBounds().pad(0.1));
            }
        }

        function updateStats() {
            const selectedData = getSelectedData();
            const pointCount = selectedData.length;
            
            if (pointCount === 0) {
                document.getElementById('pointCount').textContent = '0';
                document.getElementById('avgElevation').textContent = 'N/A';
                document.getElementById('avgRMS').textContent = 'N/A';
                return;
            }
            
            const avgElevation = selectedData.reduce((sum, p) => sum + parseFloat(p.Elevation || 0), 0) / pointCount;
            const avgRMS = selectedData.reduce((sum, p) => sum + parseFloat(p['Lateral RMS'] || 0), 0) / pointCount;

            document.getElementById('pointCount').textContent = pointCount;
            document.getElementById('avgElevation').textContent = avgElevation.toFixed(2) + 'm';
            document.getElementById('avgRMS').textContent = avgRMS.toFixed(3);
        }

        function displayData() {
            const container = document.getElementById('dataTableContainer');

            let tableHTML = `
                <table class="data-table">
                    <thead>
                        <tr>
                            <th style="width: 40px;">
                                <input type="checkbox" id="selectAllPoints" checked onchange="toggleAllPoints(this.checked)" 
                                       title="Select/Deselect All">
                            </th>
                            <th>Name</th>
                            <th>Longitude</th>
                            <th>Latitude</th>
                            <th>Elevation</th>
                            <th>RMS</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            filteredData.forEach((point, index) => {
                const isSelected = point.selected !== false; // Default to true if not set
                tableHTML += `
                    <tr style="${isSelected ? '' : 'opacity: 0.4; background: #f5f5f5;'}">
                        <td style="text-align: center;">
                            <input type="checkbox" class="point-checkbox" data-index="${index}" 
                                   ${isSelected ? 'checked' : ''} onchange="togglePoint(${index}, this.checked)">
                        </td>
                        <td><strong>${point.Name || 'N/A'}</strong></td>
                        <td>${parseFloat(point.Longitude).toFixed(6)}</td>
                        <td>${parseFloat(point.Latitude).toFixed(6)}</td>
                        <td>${parseFloat(point.Elevation).toFixed(3)}m</td>
                        <td>${parseFloat(point['Lateral RMS'] || 0).toFixed(3)}</td>
                        <td><span style="color: ${point['Solution status'] === 'FIX' ? 'green' : 'orange'}">${point['Solution status'] || 'N/A'}</span></td>
                    </tr>
                `;
            });

            tableHTML += '</tbody></table>';
            container.innerHTML = tableHTML;
        }

        function togglePoint(index, isChecked) {
            if (index >= 0 && index < filteredData.length) {
                filteredData[index].selected = isChecked;
                
                // Update visualizations
                updateMap();
                updateStats();
                
                if (showingHeatmap) {
                    if (heatmapLayer) {
                        map.removeLayer(heatmapLayer);
                        heatmapLayer = null;
                    }
                    if (heatmapBoundaryLayer) {
                        map.removeLayer(heatmapBoundaryLayer);
                        heatmapBoundaryLayer = null;
                    }
                    if (heatmapLegend) {
                        map.removeControl(heatmapLegend);
                        heatmapLegend = null;
                    }
                    if (getSelectedData().length > 0) {
                        createHeatmap();
                    } else {
                        showingHeatmap = false;
                        document.getElementById('heatmapBtn').classList.remove('active');
                    }
                }
                
                if (showingContours) {
                    if (contoursLayer) {
                        map.removeLayer(contoursLayer);
                        contoursLayer = null;
                    }
                    if (getSelectedData().length >= 3) {
                        createContours();
                    } else {
                        showingContours = false;
                        document.getElementById('contourBtn').classList.remove('active');
                    }
                }
                
                if (showingTIN) {
                    if (tinLayer) {
                        map.removeLayer(tinLayer);
                        tinLayer = null;
                    }
                    if (getSelectedData().length >= 3) {
                        createTINSurface();
                    } else {
                        showingTIN = false;
                        document.getElementById('tinBtn').classList.remove('active');
                    }
                }
                
                // Update 3D ground surface
                render3DGroundSurface();
                
                // Update table row styling
                displayData();
                
                // Update select all checkbox
                updateSelectAllCheckbox();
            }
        }

        function toggleAllPoints(isChecked) {
            filteredData.forEach(point => {
                point.selected = isChecked;
            });
            
            // Update all visualizations
            updateMap();
            updateStats();
            
            if (showingHeatmap) {
                if (heatmapLayer) {
                    map.removeLayer(heatmapLayer);
                    heatmapLayer = null;
                }
                if (heatmapBoundaryLayer) {
                    map.removeLayer(heatmapBoundaryLayer);
                    heatmapBoundaryLayer = null;
                }
                if (heatmapLegend) {
                    map.removeControl(heatmapLegend);
                    heatmapLegend = null;
                }
                if (isChecked && getSelectedData().length > 0) {
                    createHeatmap();
                } else {
                    showingHeatmap = false;
                    document.getElementById('heatmapBtn').classList.remove('active');
                }
            }
            
            if (showingContours) {
                if (contoursLayer) {
                    map.removeLayer(contoursLayer);
                    contoursLayer = null;
                }
                if (isChecked && getSelectedData().length >= 3) {
                    createContours();
                } else {
                    showingContours = false;
                    document.getElementById('contourBtn').classList.remove('active');
                }
            }
            
            if (showingTIN) {
                if (tinLayer) {
                    map.removeLayer(tinLayer);
                    tinLayer = null;
                }
                if (isChecked && getSelectedData().length >= 3) {
                    createTINSurface();
                } else {
                    showingTIN = false;
                    document.getElementById('tinBtn').classList.remove('active');
                }
            }
            
            render3DGroundSurface();
            displayData();
        }

        function updateSelectAllCheckbox() {
            const selectAllCheckbox = document.getElementById('selectAllPoints');
            if (selectAllCheckbox) {
                const allSelected = filteredData.every(point => point.selected !== false);
                const noneSelected = filteredData.every(point => point.selected === false);
                
                selectAllCheckbox.checked = allSelected;
                selectAllCheckbox.indeterminate = !allSelected && !noneSelected;
            }
        }

        function getSelectedData() {
            return filteredData.filter(point => point.selected !== false);
        }

        function toggleDataTable() {
            const container = document.getElementById('dataTableContainer');
            const checkbox = document.getElementById('showDataTable');
            container.style.display = checkbox.checked ? 'block' : 'none';
        }

        function showError(message) {
            const container = document.getElementById('dataTableContainer');
            container.innerHTML = `<div class="error">${message}</div>`;
        }

        // 3D Ground Surface Rendering Functions
        async function render3DGroundSurface() {
            const container = document.getElementById('groundSurface3DMain');
            
            const selectedData = getSelectedData();
            if (selectedData.length < 3) {
                container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #999;">Select at least 3 survey points to visualize ground surface</div>';
                return;
            }

            try {
                // Import Three.js modules
                const THREE = await import('three');
                const { OrbitControls } = await import('three/addons/controls/OrbitControls.js');

                // Initialize scene if not exists
                if (!ground3DScene) {
                    ground3DScene = new THREE.Scene();
                    ground3DScene.background = new THREE.Color(0xe0e8f0);

                    // Camera
                    const aspect = container.offsetWidth / container.offsetHeight;
                    ground3DCamera = new THREE.PerspectiveCamera(50, aspect, 0.1, 10000);
                    
                    // Renderer
                    ground3DRenderer = new THREE.WebGLRenderer({ antialias: true });
                    ground3DRenderer.setSize(container.offsetWidth, container.offsetHeight);
                    ground3DRenderer.setPixelRatio(window.devicePixelRatio);
                    container.innerHTML = '';
                    container.appendChild(ground3DRenderer.domElement);

                    // Controls
                    ground3DControls = new OrbitControls(ground3DCamera, ground3DRenderer.domElement);
                    ground3DControls.enableDamping = true;
                    ground3DControls.dampingFactor = 0.05;

                    // Lighting
                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                    ground3DScene.add(ambientLight);

                    const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
                    dirLight1.position.set(50, 100, 50);
                    ground3DScene.add(dirLight1);

                    const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
                    dirLight2.position.set(-50, 50, -50);
                    ground3DScene.add(dirLight2);
                    
                    // No ground plane - removed for cleaner view
                } else {
                    // Clear previous meshes
                    const objectsToRemove = ground3DScene.children.filter(child => 
                        child.type === 'Mesh' || child.type === 'LineSegments' || child.type === 'Points'
                    );
                    objectsToRemove.forEach(obj => {
                        if (obj.geometry) obj.geometry.dispose();
                        if (obj.material) {
                            if (Array.isArray(obj.material)) {
                                obj.material.forEach(mat => mat.dispose());
                            } else {
                                obj.material.dispose();
                            }
                        }
                        ground3DScene.remove(obj);
                    });
                }

                // Prepare data for kriging - use selected data only
                const points = selectedData.map(p => ({
                    x: parseFloat(p.Longitude),
                    y: parseFloat(p.Latitude),
                }));
                const elevations = selectedData.map(p => parseFloat(p.Elevation || 0));

                const minLon = Math.min(...points.map(p => p.x));
                const maxLon = Math.max(...points.map(p => p.x));
                const minLat = Math.min(...points.map(p => p.y));
                const maxLat = Math.max(...points.map(p => p.y));
                const minElev = Math.min(...elevations);
                const maxElev = Math.max(...elevations);

                // Create kriging interpolation that passes through actual points
                const kriging = new GroundKriging(points, elevations, krigingSmoothing, krigingNuggetPercent, krigingInfluenceRadius);
                const bounds = {
                    minX: minLon,
                    maxX: maxLon,
                    minY: minLat,
                    maxY: maxLat
                };
                
                // Use configurable resolution for smooth surface
                ground3DKrigingGrid = kriging.interpolateGrid(bounds, krigingGridResolution, krigingInterpPower, krigingGaussianSmooth);

                // Create 3D mesh from interpolated grid
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const indices = [];
                const colors = [];
                const resolution = ground3DKrigingGrid.resolution;

                // Scale factors for visualization
                const lonScale = 100000; // Scale longitude differences
                const latScale = 111000; // Scale latitude differences (1 degree ‚âà 111km)
                const elevScale = ground3DVerticalExaggeration;

                // Build vertices grid - use kriging interpolated values directly
                for (let i = 0; i <= resolution; i++) {
                    for (let j = 0; j <= resolution; j++) {
                        const lon = bounds.minX + j * ground3DKrigingGrid.dx;
                        const lat = bounds.minY + i * ground3DKrigingGrid.dy;
                        
                        // Use kriging interpolated elevation
                        const elev = ground3DKrigingGrid.grid[i][j];

                        const x = (lon - minLon) * lonScale;
                        const y = (elev - minElev) * elevScale;
                        const z = (lat - minLat) * latScale;

                        vertices.push(x, y, z);

                        // Color based on elevation using heatmap gradient
                        const norm = (elev - minElev) / (maxElev - minElev);
                        const color = getColorForValue(norm);
                        colors.push(color.r / 255, color.g / 255, color.b / 255);
                    }
                }

                // Create triangles
                for (let i = 0; i < resolution; i++) {
                    for (let j = 0; j < resolution; j++) {
                        const tl = i * (resolution + 1) + j;
                        const tr = tl + 1;
                        const bl = (i + 1) * (resolution + 1) + j;
                        const br = bl + 1;

                        indices.push(tl, bl, tr);
                        indices.push(tr, bl, br);
                    }
                }

                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();

                // Create mesh
                const material = new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    side: THREE.DoubleSide,
                    flatShading: false,
                    shininess: 30
                });

                const mesh = new THREE.Mesh(geometry, material);
                ground3DScene.add(mesh);

                // Add 3D contours if enabled
                if (document.getElementById('show3DContours') && document.getElementById('show3DContours').checked) {
                    add3DContoursToModel(THREE, ground3DScene, ground3DKrigingGrid, minLon, minLat, minElev, lonScale, latScale, elevScale);
                }

                // Add wireframe if enabled - create box around actual survey points
                if (document.getElementById('show3DWireframe').checked) {
                    // Create bounding box around survey points
                    const boxGeometry = new THREE.BufferGeometry();
                    const boxVertices = [];
                    
                    // Get actual survey point boundaries (not interpolated grid)
                    const surveyMinLon = Math.min(...filteredData.map(p => parseFloat(p.Longitude)));
                    const surveyMaxLon = Math.max(...filteredData.map(p => parseFloat(p.Longitude)));
                    const surveyMinLat = Math.min(...filteredData.map(p => parseFloat(p.Latitude)));
                    const surveyMaxLat = Math.max(...filteredData.map(p => parseFloat(p.Latitude)));
                    const surveyMinElev = Math.min(...filteredData.map(p => parseFloat(p.Elevation || 0)));
                    const surveyMaxElev = Math.max(...filteredData.map(p => parseFloat(p.Elevation || 0)));
                    
                    // Convert to 3D space
                    const boxMinX = (surveyMinLon - minLon) * lonScale;
                    const boxMaxX = (surveyMaxLon - minLon) * lonScale;
                    const boxMinY = (surveyMinElev - minElev) * elevScale;
                    const boxMaxY = (surveyMaxElev - minElev) * elevScale;
                    const boxMinZ = (surveyMinLat - minLat) * latScale;
                    const boxMaxZ = (surveyMaxLat - minLat) * latScale;
                    
                    // Bottom rectangle
                    boxVertices.push(boxMinX, boxMinY, boxMinZ);
                    boxVertices.push(boxMaxX, boxMinY, boxMinZ);
                    
                    boxVertices.push(boxMaxX, boxMinY, boxMinZ);
                    boxVertices.push(boxMaxX, boxMinY, boxMaxZ);
                    
                    boxVertices.push(boxMaxX, boxMinY, boxMaxZ);
                    boxVertices.push(boxMinX, boxMinY, boxMaxZ);
                    
                    boxVertices.push(boxMinX, boxMinY, boxMaxZ);
                    boxVertices.push(boxMinX, boxMinY, boxMinZ);
                    
                    // Top rectangle
                    boxVertices.push(boxMinX, boxMaxY, boxMinZ);
                    boxVertices.push(boxMaxX, boxMaxY, boxMinZ);
                    
                    boxVertices.push(boxMaxX, boxMaxY, boxMinZ);
                    boxVertices.push(boxMaxX, boxMaxY, boxMaxZ);
                    
                    boxVertices.push(boxMaxX, boxMaxY, boxMaxZ);
                    boxVertices.push(boxMinX, boxMaxY, boxMaxZ);
                    
                    boxVertices.push(boxMinX, boxMaxY, boxMaxZ);
                    boxVertices.push(boxMinX, boxMaxY, boxMinZ);
                    
                    // Vertical edges
                    boxVertices.push(boxMinX, boxMinY, boxMinZ);
                    boxVertices.push(boxMinX, boxMaxY, boxMinZ);
                    
                    boxVertices.push(boxMaxX, boxMinY, boxMinZ);
                    boxVertices.push(boxMaxX, boxMaxY, boxMinZ);
                    
                    boxVertices.push(boxMaxX, boxMinY, boxMaxZ);
                    boxVertices.push(boxMaxX, boxMaxY, boxMaxZ);
                    
                    boxVertices.push(boxMinX, boxMinY, boxMaxZ);
                    boxVertices.push(boxMinX, boxMaxY, boxMaxZ);
                    
                    boxGeometry.setAttribute('position', new THREE.Float32BufferAttribute(boxVertices, 3));
                    
                    const boxWireframe = new THREE.LineSegments(
                        boxGeometry,
                        new THREE.LineBasicMaterial({ 
                            color: 0x0066cc, 
                            linewidth: 2,
                            opacity: 0.8,
                            transparent: true
                        })
                    );
                    ground3DScene.add(boxWireframe);
                }

                // Add survey points if enabled
                if (document.getElementById('show3DPoints').checked) {
                    const pointsGeometry = new THREE.BufferGeometry();
                    const pointsPositions = [];
                    const pointsColors = [];

                    selectedData.forEach(p => {
                        const lon = parseFloat(p.Longitude);
                        const lat = parseFloat(p.Latitude);
                        const elev = parseFloat(p.Elevation || 0);

                        const x = (lon - minLon) * lonScale;
                        const y = (elev - minElev) * elevScale + 0.5; // Slightly above surface
                        const z = (lat - minLat) * latScale;

                        pointsPositions.push(x, y, z);
                        pointsColors.push(1, 0, 0); // Red points
                    });

                    pointsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(pointsPositions, 3));
                    pointsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(pointsColors, 3));

                    const pointsMaterial = new THREE.PointsMaterial({
                        size: 2,
                        vertexColors: true,
                        sizeAttenuation: false
                    });

                    const points3D = new THREE.Points(pointsGeometry, pointsMaterial);
                    ground3DScene.add(points3D);
                }

                // Position camera
                const centerX = (maxLon - minLon) * lonScale / 2;
                const centerZ = (maxLat - minLat) * latScale / 2;
                const maxDim = Math.max((maxLon - minLon) * lonScale, (maxLat - minLat) * latScale);
                
                ground3DCamera.position.set(centerX + maxDim, maxDim * 0.8, centerZ + maxDim);
                ground3DCamera.lookAt(centerX, 0, centerZ);
                ground3DControls.target.set(centerX, 0, centerZ);
                ground3DControls.update();

                // Animation loop
                function animate() {
                    requestAnimationFrame(animate);
                    ground3DControls.update();
                    ground3DRenderer.render(ground3DScene, ground3DCamera);
                }
                
                if (!ground3DRenderer.info.render.frame) {
                    animate();
                }
                
                // Update kriging-based contours map after 3D surface is ready
                updateKrigingContours();

            } catch (error) {
                console.error('3D Ground Surface Error:', error);
                container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #e74c3c;">Error loading 3D visualization</div>';
            }
        }

        function add3DContoursToModel(THREE, scene, krigingGrid, minLon, minLat, minElev, lonScale, latScale, elevScale) {
            const { grid, bounds, resolution, dx, dy } = krigingGrid;
            const interval = parseFloat(document.getElementById('krigingContourInterval').value);
            
            const allValues = grid.flat();
            const minVal = Math.min(...allValues);
            const maxVal = Math.max(...allValues);
            
            const levels = [];
            for (let level = Math.ceil(minVal / interval) * interval; level <= maxVal; level += interval) {
                levels.push(level);
            }
            
            levels.forEach(level => {
                const segments = [];
                
                for (let i = 0; i < resolution; i++) {
                    for (let j = 0; j < resolution; j++) {
                        const v00 = grid[i][j];
                        const v10 = grid[i][j + 1];
                        const v01 = grid[i + 1][j];
                        const v11 = grid[i + 1][j + 1];
                        
                        if (!isFinite(v00) || !isFinite(v10) || !isFinite(v01) || !isFinite(v11)) continue;
                        
                        const c = (v00 >= level ? 8 : 0) + (v10 >= level ? 4 : 0) + 
                                 (v11 >= level ? 2 : 0) + (v01 >= level ? 1 : 0);
                        if (c === 0 || c === 15) continue;
                        
                        const lon0 = bounds.minX + j * dx;
                        const lat0 = bounds.minY + i * dy;
                        const points = [];
                        
                        if ((c >= 8 && c <= 11) || (c >= 4 && c <= 7)) {
                            const denom = v10 - v00;
                            if (Math.abs(denom) > 0.0001) {
                                const t = (level - v00) / denom;
                                if (t >= 0 && t <= 1) {
                                    points.push({ lon: lon0 + t * dx, lat: lat0, elev: level });
                                }
                            }
                        }
                        if ((c >= 4 && c <= 5) || (c >= 12 && c <= 13)) {
                            const denom = v11 - v10;
                            if (Math.abs(denom) > 0.0001) {
                                const t = (level - v10) / denom;
                                if (t >= 0 && t <= 1) {
                                    points.push({ lon: lon0 + dx, lat: lat0 + t * dy, elev: level });
                                }
                            }
                        }
                        if ((c >= 2 && c <= 3) || (c >= 10 && c <= 11)) {
                            const denom = v11 - v01;
                            if (Math.abs(denom) > 0.0001) {
                                const t = (level - v01) / denom;
                                if (t >= 0 && t <= 1) {
                                    points.push({ lon: lon0 + t * dx, lat: lat0 + dy, elev: level });
                                }
                            }
                        }
                        if ((c >= 1 && c <= 2) || (c >= 13 && c <= 14)) {
                            const denom = v01 - v00;
                            if (Math.abs(denom) > 0.0001) {
                                const t = (level - v00) / denom;
                                if (t >= 0 && t <= 1) {
                                    points.push({ lon: lon0, lat: lat0 + t * dy, elev: level });
                                }
                            }
                        }
                        
                        if (points.length >= 2) {
                            segments.push({ start: points[0], end: points[1] });
                        }
                    }
                }
                
                // Draw segments as lines
                segments.forEach(seg => {
                    const vertices = new Float32Array([
                        (seg.start.lon - minLon) * lonScale,
                        (seg.start.elev - minElev) * elevScale + 0.1, // Slightly above surface
                        (seg.start.lat - minLat) * latScale,
                        (seg.end.lon - minLon) * lonScale,
                        (seg.end.elev - minElev) * elevScale + 0.1,
                        (seg.end.lat - minLat) * latScale
                    ]);
                    
                    const lineGeometry = new THREE.BufferGeometry();
                    lineGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                    
                    const lineMaterial = new THREE.LineBasicMaterial({
                        color: 0xFF6B00,
                        linewidth: 2,
                        opacity: 0.9,
                        transparent: true
                    });
                    
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    scene.add(line);
                });
            });
        }

        function update3DGroundVerticalExaggeration(value) {
            ground3DVerticalExaggeration = parseFloat(value);
            document.getElementById('ground3DVertExagValue').textContent = ground3DVerticalExaggeration.toFixed(1) + 'x';
            render3DGroundSurface();
        }

        function updateKrigingSmooth(value) {
            krigingSmoothing = parseInt(value);
            document.getElementById('krigingSmoothValue').textContent = value;
            render3DGroundSurface();
        }

        function updateGridResolution(value) {
            krigingGridResolution = parseInt(value);
            document.getElementById('gridResolutionValue').textContent = value + 'x' + value;
            render3DGroundSurface();
        }

        function updateInterpPower(value) {
            krigingInterpPower = parseFloat(value);
            document.getElementById('interpPowerValue').textContent = value;
            render3DGroundSurface();
        }

        function updateNugget(value) {
            krigingNuggetPercent = parseInt(value);
            document.getElementById('nuggetValue').textContent = value + '%';
            render3DGroundSurface();
        }

        function updateInfluenceRadius(value) {
            krigingInfluenceRadius = parseFloat(value);
            document.getElementById('influenceRadiusValue').textContent = value + 'x';
            render3DGroundSurface();
        }

        function updateGaussianSmooth(value) {
            krigingGaussianSmooth = parseInt(value);
            const labels = ['None', 'Very Light', 'Light', 'Medium', 'Heavy', 'Very Heavy'];
            document.getElementById('gaussianSmoothValue').textContent = labels[value];
            render3DGroundSurface();
        }

        function reset3DGroundView() {
            const selectedData = getSelectedData();
            if (ground3DControls && selectedData.length >= 3) {
                const minLon = Math.min(...selectedData.map(p => parseFloat(p.Longitude)));
                const maxLon = Math.max(...selectedData.map(p => parseFloat(p.Longitude)));
                const minLat = Math.min(...selectedData.map(p => parseFloat(p.Latitude)));
                const maxLat = Math.max(...selectedData.map(p => parseFloat(p.Latitude)));
                
                const lonScale = 100000;
                const latScale = 111000;
                const centerX = (maxLon - minLon) * lonScale / 2;
                const centerZ = (maxLat - minLat) * latScale / 2;
                const maxDim = Math.max((maxLon - minLon) * lonScale, (maxLat - minLat) * latScale);
                
                ground3DCamera.position.set(centerX + maxDim, maxDim * 0.8, centerZ + maxDim);
                ground3DControls.target.set(centerX, 0, centerZ);
                ground3DControls.update();
            }
        }

        function setTop3DGroundView() {
            const selectedData = getSelectedData();
            if (ground3DControls && selectedData.length >= 3) {
                const minLon = Math.min(...selectedData.map(p => parseFloat(p.Longitude)));
                const maxLon = Math.max(...selectedData.map(p => parseFloat(p.Longitude)));
                const minLat = Math.min(...selectedData.map(p => parseFloat(p.Latitude)));
                const maxLat = Math.max(...selectedData.map(p => parseFloat(p.Latitude)));
                
                const lonScale = 100000;
                const latScale = 111000;
                const centerX = (maxLon - minLon) * lonScale / 2;
                const centerZ = (maxLat - minLat) * latScale / 2;
                const maxDim = Math.max((maxLon - minLon) * lonScale, (maxLat - minLat) * latScale);
                
                ground3DCamera.position.set(centerX, maxDim * 1.5, centerZ);
                ground3DControls.target.set(centerX, 0, centerZ);
                ground3DControls.update();
            }
        }

        function setSide3DGroundView() {
            const selectedData = getSelectedData();
            if (ground3DControls && selectedData.length >= 3) {
                const minLon = Math.min(...selectedData.map(p => parseFloat(p.Longitude)));
                const maxLon = Math.max(...selectedData.map(p => parseFloat(p.Longitude)));
                const minLat = Math.min(...selectedData.map(p => parseFloat(p.Latitude)));
                const maxLat = Math.max(...selectedData.map(p => parseFloat(p.Latitude)));
                
                const lonScale = 100000;
                const latScale = 111000;
                const centerX = (maxLon - minLon) * lonScale / 2;
                const centerZ = (maxLat - minLat) * latScale / 2;
                const maxDim = Math.max((maxLon - minLon) * lonScale, (maxLat - minLat) * latScale);
                
                ground3DCamera.position.set(centerX, maxDim * 0.3, centerZ + maxDim * 1.5);
                ground3DControls.target.set(centerX, 0, centerZ);
                ground3DControls.update();
            }
        }

        function setNorth3DGroundView() {
            const selectedData = getSelectedData();
            if (ground3DControls && selectedData.length >= 3) {
                const minLon = Math.min(...selectedData.map(p => parseFloat(p.Longitude)));
                const maxLon = Math.max(...selectedData.map(p => parseFloat(p.Longitude)));
                const minLat = Math.min(...selectedData.map(p => parseFloat(p.Latitude)));
                const maxLat = Math.max(...selectedData.map(p => parseFloat(p.Latitude)));
                
                const lonScale = 100000;
                const latScale = 111000;
                const centerX = (maxLon - minLon) * lonScale / 2;
                const centerZ = (maxLat - minLat) * latScale / 2;
                const maxDim = Math.max((maxLon - minLon) * lonScale, (maxLat - minLat) * latScale);
                
                // View from North (looking South) - camera at +Z
                ground3DCamera.position.set(centerX, maxDim * 0.4, centerZ + maxDim * 1.2);
                ground3DControls.target.set(centerX, maxDim * 0.2, centerZ);
                ground3DControls.update();
            }
        }

        function setSouth3DGroundView() {
            const selectedData = getSelectedData();
            if (ground3DControls && selectedData.length >= 3) {
                const minLon = Math.min(...selectedData.map(p => parseFloat(p.Longitude)));
                const maxLon = Math.max(...selectedData.map(p => parseFloat(p.Longitude)));
                const minLat = Math.min(...selectedData.map(p => parseFloat(p.Latitude)));
                const maxLat = Math.max(...selectedData.map(p => parseFloat(p.Latitude)));
                
                const lonScale = 100000;
                const latScale = 111000;
                const centerX = (maxLon - minLon) * lonScale / 2;
                const centerZ = (maxLat - minLat) * latScale / 2;
                const maxDim = Math.max((maxLon - minLon) * lonScale, (maxLat - minLat) * latScale);
                
                // View from South (looking North) - camera at -Z
                ground3DCamera.position.set(centerX, maxDim * 0.4, centerZ - maxDim * 1.2);
                ground3DControls.target.set(centerX, maxDim * 0.2, centerZ);
                ground3DControls.update();
            }
        }

        function setEast3DGroundView() {
            const selectedData = getSelectedData();
            if (ground3DControls && selectedData.length >= 3) {
                const minLon = Math.min(...selectedData.map(p => parseFloat(p.Longitude)));
                const maxLon = Math.max(...selectedData.map(p => parseFloat(p.Longitude)));
                const minLat = Math.min(...selectedData.map(p => parseFloat(p.Latitude)));
                const maxLat = Math.max(...selectedData.map(p => parseFloat(p.Latitude)));
                
                const lonScale = 100000;
                const latScale = 111000;
                const centerX = (maxLon - minLon) * lonScale / 2;
                const centerZ = (maxLat - minLat) * latScale / 2;
                const maxDim = Math.max((maxLon - minLon) * lonScale, (maxLat - minLat) * latScale);
                
                // View from East (looking West) - camera at +X
                ground3DCamera.position.set(centerX + maxDim * 1.2, maxDim * 0.4, centerZ);
                ground3DControls.target.set(centerX, maxDim * 0.2, centerZ);
                ground3DControls.update();
            }
        }

        function setWest3DGroundView() {
            const selectedData = getSelectedData();
            if (ground3DControls && selectedData.length >= 3) {
                const minLon = Math.min(...selectedData.map(p => parseFloat(p.Longitude)));
                const maxLon = Math.max(...selectedData.map(p => parseFloat(p.Longitude)));
                const minLat = Math.min(...selectedData.map(p => parseFloat(p.Latitude)));
                const maxLat = Math.max(...selectedData.map(p => parseFloat(p.Latitude)));
                
                const lonScale = 100000;
                const latScale = 111000;
                const centerX = (maxLon - minLon) * lonScale / 2;
                const centerZ = (maxLat - minLat) * latScale / 2;
                const maxDim = Math.max((maxLon - minLon) * lonScale, (maxLat - minLat) * latScale);
                
                // View from West (looking East) - camera at -X
                ground3DCamera.position.set(centerX - maxDim * 1.2, maxDim * 0.4, centerZ);
                ground3DControls.target.set(centerX, maxDim * 0.2, centerZ);
                ground3DControls.update();
            }
        }

        document.getElementById('csvFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const fileName = file.name.toLowerCase();
            const isExcel = fileName.endsWith('.xlsx') || fileName.endsWith('.xls');

            if (isExcel) {
                // Handle Excel file
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        
                        // Get first sheet
                        const firstSheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[firstSheetName];
                        
                        // Convert to CSV
                        const csvText = XLSX.utils.sheet_to_csv(worksheet);
                        parseCSVData(csvText);
                    } catch (error) {
                        showError('Error parsing Excel file: ' + error.message);
                    }
                };
                reader.readAsArrayBuffer(file);
            } else {
                // Handle CSV file
                const reader = new FileReader();
                reader.onload = function(e) {
                    parseCSVData(e.target.result);
                };
                reader.readAsText(file);
            }
        });

        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            loadSampleData();
        });
    </script>
</body>

</html>