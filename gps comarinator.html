<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPS Survey Data Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }
        
        #dropZone {
            border: 3px dashed #ccc;
            border-radius: 10px;
            padding: 60px;
            text-align: center;
            background: #fafafa;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 30px;
        }
        
        #dropZone.dragover {
            border-color: #4CAF50;
            background: #e8f5e9;
        }
        
        #dropZone:hover {
            border-color: #999;
        }
        
        .drop-icon {
            font-size: 48px;
            margin-bottom: 20px;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .btn {
            background: #4CAF50;
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }
        
        .btn:hover {
            background: #45a049;
        }
        
        .btn-secondary {
            background: #2196F3;
        }
        
        .btn-secondary:hover {
            background: #0b7dda;
        }
        
        #results {
            display: none;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .stat-label {
            font-size: 12px;
            opacity: 0.9;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 28px;
            font-weight: bold;
        }
        
        .chart-container {
            margin-bottom: 40px;
            padding: 20px;
            background: #fafafa;
            border-radius: 8px;
        }
        
        .chart-container h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 20px;
        }
        
        canvas {
            max-height: 400px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 13px;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        th {
            background: #f5f5f5;
            font-weight: 600;
            color: #333;
            position: sticky;
            top: 0;
        }
        
        tr:hover {
            background: #f9f9f9;
        }
        
        tr[style*="opacity"] {
            text-decoration: line-through;
        }
        
        .location-group {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #4CAF50;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .location-header {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
        }
        
        .metric-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .metric {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
        }
        
        .metric-label {
            font-size: 11px;
            color: #666;
            margin-bottom: 3px;
        }
        
        .metric-value {
            font-size: 16px;
            font-weight: bold;
            color: #333;
        }
        
        .tolerance-control {
            margin: 20px 0;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 5px;
        }
        
        .tolerance-control label {
            font-weight: 600;
            margin-right: 10px;
        }
        
        .tolerance-control input {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 100px;
        }
        
        .warning {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
        }
        
        .info {
            background: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>GPS Survey Data Analyzer</h1>
        <p class="subtitle">Compare GPS/GNSS measurements at the same location ‚Ä¢ Analyze accuracy and repeatability</p>
        
        <div id="dropZone">
            <div class="drop-icon">üìÅ</div>
            <h3>Drag & Drop CSV or Excel File Here</h3>
            <p style="margin: 10px 0;">or</p>
            <button class="btn" onclick="document.getElementById('fileInput').click()">Browse Files</button>
            <input type="file" id="fileInput" accept=".csv,.xlsx,.xls" multiple onchange="handleFiles(this.files)">
            <p style="margin-top: 10px; font-size: 13px; color: #666;">üí° Tip: Select multiple files to compare datasets</p>
        </div>
        
        <div id="datasetManager" style="display: none; margin-bottom: 30px;">
            <h2 style="margin-bottom: 15px;">üìä Loaded Datasets</h2>
            <div id="datasetList" style="background: #f9f9f9; padding: 20px; border-radius: 8px;"></div>
        </div>
        
        <div id="knownPointsSection" style="display: none; margin-bottom: 30px;">
            <h2 style="margin-bottom: 15px;">Known Reference Points (SSMs, Control Points)</h2>
            <div style="background: #f9f9f9; padding: 20px; border-radius: 8px;">
                <div style="margin-bottom: 15px;">
                    <button class="btn btn-secondary" onclick="document.getElementById('knownPointsFile').click()">Upload Known Points CSV/Excel</button>
                    <button class="btn" onclick="showAddPointForm()">Add Point Manually</button>
                    <button class="btn" onclick="clearKnownPoints()" style="background: #f44336;">Clear All</button>
                    <input type="file" id="knownPointsFile" accept=".csv,.xlsx,.xls" style="display: none;" onchange="handleKnownPointsFile(this.files[0])">
                </div>
                
                <div id="addPointForm" style="display: none; background: white; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                    <h3 style="margin-bottom: 10px;">Add Known Point</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 10px;">
                        <div>
                            <label for="pointName" style="display: block; margin-bottom: 3px; font-size: 12px;">Point Name/ID:</label>
                            <input type="text" id="pointName" placeholder="Point Name/ID" style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 100%;">
                        </div>
                        <div>
                            <label for="pointX" style="display: block; margin-bottom: 3px; font-size: 12px;">Easting (X):</label>
                            <input type="number" id="pointX" placeholder="Easting (X)" step="0.001" style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 100%;">
                        </div>
                        <div>
                            <label for="pointY" style="display: block; margin-bottom: 3px; font-size: 12px;">Northing (Y):</label>
                            <input type="number" id="pointY" placeholder="Northing (Y)" step="0.001" style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 100%;">
                        </div>
                        <div>
                            <label for="pointZ" style="display: block; margin-bottom: 3px; font-size: 12px;">Elevation (Z):</label>
                            <input type="number" id="pointZ" placeholder="Elevation (Z)" step="0.001" style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 100%;">
                        </div>
                    </div>
                    <button class="btn" onclick="addKnownPoint()">Add Point</button>
                    <button class="btn" onclick="document.getElementById('addPointForm').style.display='none'" style="background: #999;">Cancel</button>
                </div>
                
                <div style="margin-top: 15px;">
                    <strong>Known Points:</strong> <span id="knownPointCount">0</span>
                    <div id="knownPointsList" style="margin-top: 10px; max-height: 200px; overflow-y: auto;"></div>
                </div>
                
                <div class="info" style="margin-top: 15px; font-size: 13px;">
                    <strong>Format (CSV or Excel):</strong> Name, X, Y, Z (tab or comma separated)<br>
                    Example: SSM123, 405229.500, 6469657.800, -17.250
                </div>
            </div>
        </div>
        
        <div id="results">
            <div class="tolerance-control">
                <label for="tolerance">Location Grouping Tolerance (meters):</label>
                <input type="number" id="tolerance" value="0.5" step="0.1" min="0.01">
                <button class="btn btn-secondary" onclick="reanalyze()">Re-analyze</button>
            </div>
            
            <div class="tolerance-control" style="background: #fff3e0; border-left: 4px solid #ff9800;">
                <h3 style="margin-bottom: 15px; color: #333;">üîç Filter Data Points</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 15px;">
                    <div>
                        <label for="filterHAcc" style="display: block; margin-bottom: 5px;">Max Horizontal Accuracy (m):</label>
                        <input type="number" id="filterHAcc" placeholder="e.g. 0.05" step="0.01" style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 100%;">
                    </div>
                    <div>
                        <label for="filterVAcc" style="display: block; margin-bottom: 5px;">Max Vertical Accuracy (m):</label>
                        <input type="number" id="filterVAcc" placeholder="e.g. 0.1" step="0.01" style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 100%;">
                    </div>
                    <div>
                        <label for="filterMinSat" style="display: block; margin-bottom: 5px;">Min Satellites Used:</label>
                        <input type="number" id="filterMinSat" placeholder="e.g. 25" step="1" style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 100%;">
                    </div>
                    <div>
                        <label for="filterHDOP" style="display: block; margin-bottom: 5px;">Max HDOP:</label>
                        <input type="number" id="filterHDOP" placeholder="e.g. 1.0" step="0.1" style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 100%;">
                    </div>
                    <div>
                        <label for="filterFixID" style="display: block; margin-bottom: 5px;">Fix ID (exact match):</label>
                        <input type="text" id="filterFixID" placeholder="e.g. 4" style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 100%;">
                    </div>
                    <div>
                        <label for="filterRemarks" style="display: block; margin-bottom: 5px;">Remarks Contains:</label>
                        <input type="text" id="filterRemarks" placeholder="e.g. aptella" style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 100%;">
                    </div>
                </div>
                <div style="margin-bottom: 10px;">
                    <button class="btn" onclick="applyFilters()">Apply Filters</button>
                    <button class="btn" onclick="clearFilters()">Clear Filters</button>
                    <button class="btn btn-secondary" onclick="toggleAllPoints()">Select/Deselect All</button>
                    <span id="filterStatus" style="margin-left: 15px; font-weight: bold;"></span>
                </div>
                <div id="manualSelectionInfo" class="info" style="display: none; margin-top: 10px;">
                    <strong>Manual Selection:</strong> Use checkboxes in the data table below to include/exclude specific points
                </div>
            </div>
            
            <div class="stats-grid" id="overallStats"></div>
            
            <div id="comparativeStats" style="display: none; margin-bottom: 30px;">
                <h2 style="margin-bottom: 15px;">üìä Dataset Comparison</h2>
                <div style="overflow-x: auto;">
                    <table id="comparisonTable" style="font-size: 13px;"></table>
                </div>
            </div>
            
            <div id="dopAnalysis" style="display: none; margin-bottom: 30px;">
                <h2 style="margin-bottom: 15px;">üìà DOP vs Accuracy Analysis</h2>
                <div class="info" style="margin-bottom: 20px;">
                    <strong>What is DOP?</strong> Dilution of Precision measures satellite geometry quality. Lower values = better geometry = theoretically better accuracy.
                    <br><strong>HDOP:</strong> Horizontal DOP | <strong>VDOP:</strong> Vertical DOP | <strong>PDOP:</strong> Position (3D) DOP
                </div>
                <div id="dopStatsGrid" class="stats-grid"></div>
                <div class="chart-container">
                    <h2>HDOP vs Horizontal Accuracy</h2>
                    <canvas id="hdopVsHAccChart"></canvas>
                </div>
                <div class="chart-container">
                    <h2>VDOP vs Vertical Accuracy</h2>
                    <canvas id="vdopVsVAccChart"></canvas>
                </div>
                <div class="chart-container">
                    <h2>PDOP vs Position Accuracy</h2>
                    <canvas id="pdopVsPosAccChart"></canvas>
                </div>
            </div>
            
            <div id="errorAnalysisSection" style="display: none;">
                <h2 style="margin: 30px 0 20px 0; color: #d32f2f;">Error Analysis vs Known Points</h2>
                
                <div class="stats-grid" id="errorStats"></div>
                
                <div class="chart-container">
                    <h2>Position Error Vectors (2D)</h2>
                    <canvas id="errorVectorChart"></canvas>
                </div>
                
                <div class="chart-container">
                    <h2>Horizontal Position Error</h2>
                    <canvas id="hErrorChart"></canvas>
                </div>
                
                <div class="chart-container">
                    <h2>Vertical Error</h2>
                    <canvas id="vErrorChart"></canvas>
                </div>
                
                <div class="chart-container">
                    <h2>Error vs Reported Accuracy</h2>
                    <canvas id="errorVsAccuracyChart"></canvas>
                </div>
                
                <h3 style="margin: 30px 0 15px 0;">Matched Points Detail</h3>
                <div id="matchedPointsDetail"></div>
            </div>
            
            <div class="chart-container">
                <h2>Position Scatter Plot (East vs North)</h2>
                <canvas id="scatterChart"></canvas>
            </div>
            
            <div class="chart-container">
                <h2>Horizontal Accuracy Comparison</h2>
                <canvas id="accuracyChart"></canvas>
            </div>
            
            <div class="chart-container">
                <h2>Vertical Accuracy Comparison</h2>
                <canvas id="vAccuracyChart"></canvas>
            </div>
            
            <div class="chart-container">
                <h2>PDOP / HDOP / VDOP Trends</h2>
                <canvas id="dopChart"></canvas>
            </div>
            
            <div class="chart-container">
                <h2>Satellite Count</h2>
                <canvas id="satChart"></canvas>
            </div>
            
            <div class="chart-container">
                <h2>Elevation Comparison</h2>
                <canvas id="elevChart"></canvas>
            </div>
            
            <div id="timeSeriesAnalysis" style="display: none; margin-top: 40px;">
                <h2 style="margin-bottom: 15px; color: #d32f2f;">‚è±Ô∏è Time Series Analysis</h2>
                <div class="chart-container">
                    <h2>Accuracy Over Time</h2>
                    <canvas id="accuracyOverTimeChart"></canvas>
                </div>
                <div class="chart-container">
                    <h2>DOP Values Over Time</h2>
                    <canvas id="dopOverTimeChart"></canvas>
                </div>
                <div class="chart-container">
                    <h2>Satellite Count Over Time</h2>
                    <canvas id="satOverTimeChart"></canvas>
                </div>
            </div>
            
            <div id="satelliteAnalysis" style="display: none; margin-top: 40px;">
                <h2 style="margin-bottom: 15px; color: #d32f2f;">üõ∞Ô∏è Satellite Utilization Analysis</h2>
                <div id="satStatsGrid" class="stats-grid"></div>
                <div class="chart-container">
                    <h2>Satellites in Use vs Horizontal Accuracy</h2>
                    <canvas id="satVsHAccChart"></canvas>
                </div>
                <div class="chart-container">
                    <h2>Satellite Usage Efficiency (In Use / In View)</h2>
                    <canvas id="satEfficiencyChart"></canvas>
                </div>
            </div>
            
            <div id="speedAnalysis" style="display: none; margin-top: 40px;">
                <h2 style="margin-bottom: 15px; color: #d32f2f;">üèÉ Movement vs Accuracy Analysis</h2>
                <div class="info" style="margin-bottom: 20px;">
                    <strong>Theory:</strong> Movement can degrade accuracy due to dynamics, multipath, and antenna orientation changes.
                </div>
                <div id="speedStatsGrid" class="stats-grid"></div>
                <div class="chart-container">
                    <h2>Speed vs Horizontal Accuracy</h2>
                    <canvas id="speedVsAccChart"></canvas>
                </div>
            </div>
            
            <div id="remarksAnalysis" style="display: none; margin-top: 40px;">
                <h2 style="margin-bottom: 15px; color: #d32f2f;">üè∑Ô∏è Correction Network Comparison</h2>
                <div class="info" style="margin-bottom: 20px;">
                    <strong>Your Networks:</strong> Compare performance between different correction sources (aptella, auscors, etc.)
                </div>
                <div style="overflow-x: auto;">
                    <table id="remarksComparisonTable" style="font-size: 13px;"></table>
                </div>
            </div>
            
            <div id="qualityMetrics" style="display: none; margin-top: 40px;">
                <h2 style="margin-bottom: 15px; color: #d32f2f;">üìä Session Quality Metrics</h2>
                <div id="qualityStatsGrid" class="stats-grid"></div>
                <div class="chart-container">
                    <h2>Accuracy Distribution (Histogram)</h2>
                    <canvas id="accuracyHistogram"></canvas>
                </div>
            </div>
            
            <h2 style="margin: 30px 0 20px 0;">Location Groups (Points within tolerance)</h2>
            <div id="locationGroups"></div>
            
            <h2 style="margin: 30px 0 20px 0;">All Data Points</h2>
            <div style="overflow-x: auto;">
                <table id="dataTable"></table>
            </div>
        </div>
    </div>

    <script>
        let datasets = []; // Array of {name, data, enabled, pointsEnabled, color}
        let knownPoints = [];
        let charts = {};
        
        // Drag and drop handlers
        const dropZone = document.getElementById('dropZone');
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = Array.from(e.dataTransfer.files);
            handleFiles(files);
        });
        
        function handleFiles(fileList) {
            const files = Array.from(fileList);
            if (files.length === 0) return;
            
            files.forEach(file => handleFile(file));
        }
        
        function handleFile(file, fileName = null) {
            if (!file) return;
            
            const name = fileName || file.name;
            const fileNameLower = name.toLowerCase();
            const isExcel = fileNameLower.endsWith('.xlsx') || fileNameLower.endsWith('.xls');
            const isCSV = fileNameLower.endsWith('.csv');
            
            if (!isExcel && !isCSV) {
                alert('Please upload a CSV or Excel file (.csv, .xlsx, .xls)');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                if (isExcel) {
                    parseExcel(e.target.result, name);
                } else {
                    const text = e.target.result;
                    parseCSV(text, name);
                }
            };
            
            if (isExcel) {
                reader.readAsArrayBuffer(file);
            } else {
                reader.readAsText(file);
            }
        }
        
        function parseExcel(arrayBuffer, fileName) {
            try {
                const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                
                // Convert to array of arrays
                const data = XLSX.utils.sheet_to_json(firstSheet, { header: 1, raw: false });
                
                if (data.length < 2) {
                    alert('Excel file appears to be empty');
                    return;
                }
                
                const headers = data[0];
                console.log('Excel headers:', headers);
                
                const parsedData = [];
                
                for (let i = 1; i < data.length; i++) {
                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = data[i][index] || '';
                    });
                    
                    // Only add rows that have coordinate data
                    if (row.X && row.Y) {
                        parsedData.push(row);
                    }
                }
                
                if (parsedData.length === 0) {
                    alert(`No valid data found in ${fileName}. Make sure the file has X and Y coordinate columns.`);
                    console.error('First row data:', data[1]);
                    return;
                }
                
                console.log(`Parsed ${parsedData.length} points from ${fileName}`);
                addDataset(fileName, parsedData);
            } catch (error) {
                alert('Error reading Excel file: ' + error.message);
                console.error('Excel parsing error:', error);
            }
        }
        
        function parseCSV(text, fileName) {
            const lines = text.split('\n').filter(line => line.trim());
            if (lines.length < 2) {
                alert('CSV file appears to be empty');
                return;
            }
            
            // Detect delimiter (tab or comma)
            const firstLine = lines[0];
            const delimiter = firstLine.includes('\t') ? '\t' : ',';
            
            const headers = firstLine.split(delimiter).map(h => h.trim());
            
            const parsedData = [];
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(delimiter);
                const row = {};
                headers.forEach((header, index) => {
                    row[header] = values[index] ? values[index].trim() : '';
                });
                
                // Only add rows that have coordinate data
                if (row.X && row.Y) {
                    parsedData.push(row);
                }
            }
            
            if (parsedData.length === 0) {
                alert(`No valid data found in ${fileName}. Make sure the file has X and Y coordinate columns.`);
                return;
            }
            
            console.log(`Parsed ${parsedData.length} points from ${fileName}`);
            addDataset(fileName, parsedData);
        }
        
        function addDataset(name, data) {
            if (!data || data.length === 0) {
                console.error('No data provided to addDataset');
                return;
            }
            
            console.log('Adding dataset:', name, 'with', data.length, 'points');
            console.log('Sample data:', data[0]);
            
            // Normalize column names
            data = data.map(row => {
                const normalized = {};
                Object.keys(row).forEach(key => {
                    let normalizedKey = key;
                    // Map common variations
                    if (key === 'Track Name') normalizedKey = 'ID';
                    if (key === 'Lat') normalizedKey = 'Latitude';
                    if (key === 'Lon') normalizedKey = 'Longitude';
                    normalized[normalizedKey] = row[key];
                });
                return normalized;
            });
            
            // Validate that we have coordinate data
            const hasCoords = data.some(row => row.X && row.Y);
            if (!hasCoords) {
                alert(`Dataset "${name}" doesn't contain valid coordinate data (X and Y columns required)`);
                console.error('No valid coordinates in data:', data[0]);
                return;
            }
            
            const color = getDatasetColor(datasets.length);
            
            datasets.push({
                name: name,
                data: data,
                enabled: true,
                pointsEnabled: new Array(data.length).fill(true),
                color: color
            });
            
            console.log('Dataset added successfully. Total datasets:', datasets.length);
            
            updateDatasetManager();
            analyzeData();
        }
        
        function getDatasetColor(index) {
            const colors = [
                '#4CAF50', '#2196F3', '#FF9800', '#E91E63', 
                '#9C27B0', '#00BCD4', '#CDDC39', '#FF5722'
            ];
            return colors[index % colors.length];
        }
        
        function updateDatasetManager() {
            document.getElementById('datasetManager').style.display = 'block';
            
            const list = document.getElementById('datasetList');
            list.innerHTML = datasets.map((ds, idx) => `
                <div style="display: flex; align-items: center; gap: 15px; padding: 10px; background: white; border-radius: 5px; margin-bottom: 10px; border-left: 4px solid ${ds.color};">
                    <input type="checkbox" ${ds.enabled ? 'checked' : ''} onchange="toggleDataset(${idx})" style="width: 20px; height: 20px; cursor: pointer;">
                    <div style="flex: 1;">
                        <div style="font-weight: bold; color: ${ds.color};">${ds.name}</div>
                        <div style="font-size: 12px; color: #666;">
                            ${ds.data.length} points ‚Ä¢ ${ds.pointsEnabled.filter(e => e).length} enabled
                        </div>
                    </div>
                    <button class="btn" style="background: #f44336; padding: 8px 15px;" onclick="removeDataset(${idx})">Remove</button>
                </div>
            `).join('');
            
            if (datasets.length === 0) {
                document.getElementById('datasetManager').style.display = 'none';
            }
        }
        
        function toggleDataset(idx) {
            datasets[idx].enabled = !datasets[idx].enabled;
            updateDatasetManager();
            analyzeData();
        }
        
        function removeDataset(idx) {
            if (confirm(`Remove dataset "${datasets[idx].name}"?`)) {
                datasets.splice(idx, 1);
                updateDatasetManager();
                analyzeData();
            }
        }
        
        function getAllData() {
            const allData = [];
            datasets.forEach(ds => {
                if (ds.enabled) {
                    ds.data.forEach((point, idx) => {
                        if (ds.pointsEnabled[idx]) {
                            allData.push({...point, _dataset: ds.name, _color: ds.color});
                        }
                    });
                }
            });
            return allData;
        }
        
        function reanalyze() {
            if (datasets.length > 0) {
                analyzeData();
            }
        }
        
        function showAddPointForm() {
            document.getElementById('addPointForm').style.display = 'block';
        }
        
        function applyFilters() {
            const maxHAcc = parseFloat(document.getElementById('filterHAcc').value);
            const maxVAcc = parseFloat(document.getElementById('filterVAcc').value);
            const minSat = parseInt(document.getElementById('filterMinSat').value);
            const maxHDOP = parseFloat(document.getElementById('filterHDOP').value);
            const fixID = document.getElementById('filterFixID').value.trim();
            const remarksFilter = document.getElementById('filterRemarks').value.trim().toLowerCase();
            
            let filteredCount = 0;
            
            datasets.forEach(ds => {
                ds.data.forEach((point, idx) => {
                    let include = true;
                    
                    if (!isNaN(maxHAcc) && parseFloat(point['Horizontal Accuracy']) > maxHAcc) {
                        include = false;
                    }
                    if (!isNaN(maxVAcc) && parseFloat(point['Vertical Accuracy']) > maxVAcc) {
                        include = false;
                    }
                    if (!isNaN(minSat) && parseInt(point['Satellites in Use']) < minSat) {
                        include = false;
                    }
                    if (!isNaN(maxHDOP) && parseFloat(point.HDOP) > maxHDOP) {
                        include = false;
                    }
                    if (fixID && point['Fix ID'] !== fixID) {
                        include = false;
                    }
                    if (remarksFilter) {
                        const remarks = (point.Remarks || point.ID || '').toLowerCase();
                        if (!remarks.includes(remarksFilter)) {
                            include = false;
                        }
                    }
                    
                    ds.pointsEnabled[idx] = include;
                    if (!include) filteredCount++;
                });
            });
            
            updateFilterStatus();
            updateDatasetManager();
            analyzeData();
            
            if (filteredCount > 0) {
                document.getElementById('manualSelectionInfo').style.display = 'block';
            }
        }
        
        function clearFilters() {
            document.getElementById('filterHAcc').value = '';
            document.getElementById('filterVAcc').value = '';
            document.getElementById('filterMinSat').value = '';
            document.getElementById('filterHDOP').value = '';
            document.getElementById('filterFixID').value = '';
            document.getElementById('filterRemarks').value = '';
            
            datasets.forEach(ds => {
                ds.pointsEnabled = new Array(ds.data.length).fill(true);
            });
            
            updateFilterStatus();
            updateDatasetManager();
            analyzeData();
            document.getElementById('manualSelectionInfo').style.display = 'none';
        }
        
        function toggleAllPoints() {
            const allEnabled = datasets.every(ds => ds.pointsEnabled.every(e => e));
            
            datasets.forEach(ds => {
                ds.pointsEnabled = new Array(ds.data.length).fill(!allEnabled);
            });
            
            updateFilterStatus();
            updateDatasetManager();
            analyzeData();
        }
        
        function togglePoint(datasetIdx, pointIdx) {
            datasets[datasetIdx].pointsEnabled[pointIdx] = !datasets[datasetIdx].pointsEnabled[pointIdx];
            updateFilterStatus();
            updateDatasetManager();
            analyzeData();
        }
        
        function addKnownPoint() {
            const name = document.getElementById('pointName').value.trim();
            const x = parseFloat(document.getElementById('pointX').value);
            const y = parseFloat(document.getElementById('pointY').value);
            const z = parseFloat(document.getElementById('pointZ').value);
            
            if (!name || isNaN(x) || isNaN(y)) {
                alert('Please fill in at least Name, X, and Y coordinates');
                return;
            }
            
            knownPoints.push({
                name: name,
                x: x,
                y: y,
                z: isNaN(z) ? null : z
            });
            
            updateKnownPointsList();
            
            // Clear form
            document.getElementById('pointName').value = '';
            document.getElementById('pointX').value = '';
            document.getElementById('pointY').value = '';
            document.getElementById('pointZ').value = '';
            document.getElementById('addPointForm').style.display = 'none';
            
            // Re-analyze if we have data
            if (csvData.length > 0) {
                analyzeData();
            }
        }
        
        function handleKnownPointsFile(file) {
            if (!file) return;
            
            const fileName = file.name.toLowerCase();
            const isExcel = fileName.endsWith('.xlsx') || fileName.endsWith('.xls');
            const isCSV = fileName.endsWith('.csv');
            
            if (!isExcel && !isCSV) {
                alert('Please upload a CSV or Excel file');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                if (isExcel) {
                    parseKnownPointsExcel(e.target.result);
                } else {
                    const text = e.target.result;
                    parseKnownPoints(text);
                }
            };
            
            if (isExcel) {
                reader.readAsArrayBuffer(file);
            } else {
                reader.readAsText(file);
            }
        }
        
        function parseKnownPointsExcel(arrayBuffer) {
            try {
                const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                const data = XLSX.utils.sheet_to_json(firstSheet, { header: 1, raw: false });
                
                let newPoints = [];
                
                data.forEach((row, idx) => {
                    // Skip header row if it looks like a header
                    if (idx === 0 && row[0] && (row[0].toLowerCase().includes('name') || row[0].toLowerCase().includes('id'))) {
                        return;
                    }
                    
                    if (row.length >= 3) {
                        const point = {
                            name: row[0],
                            x: parseFloat(row[1]),
                            y: parseFloat(row[2]),
                            z: row.length >= 4 ? parseFloat(row[3]) : null
                        };
                        
                        if (!isNaN(point.x) && !isNaN(point.y)) {
                            newPoints.push(point);
                        }
                    }
                });
                
                if (newPoints.length > 0) {
                    knownPoints = knownPoints.concat(newPoints);
                    updateKnownPointsList();
                    
                    if (csvData.length > 0) {
                        analyzeData();
                    }
                } else {
                    alert('No valid points found in file. Expected format: Name, X, Y, Z');
                }
            } catch (error) {
                alert('Error reading Excel file: ' + error.message);
            }
        }
        
        function parseKnownPoints(text) {
            const lines = text.split('\n').filter(line => line.trim());
            let newPoints = [];
            
            lines.forEach((line, idx) => {
                // Skip header row if it looks like a header
                if (idx === 0 && (line.toLowerCase().includes('name') || line.toLowerCase().includes('id'))) {
                    return;
                }
                
                // Try comma first, then tab
                let values = line.includes(',') ? line.split(',') : line.split('\t');
                values = values.map(v => v.trim());
                
                if (values.length >= 3) {
                    const point = {
                        name: values[0],
                        x: parseFloat(values[1]),
                        y: parseFloat(values[2]),
                        z: values.length >= 4 ? parseFloat(values[3]) : null
                    };
                    
                    if (!isNaN(point.x) && !isNaN(point.y)) {
                        newPoints.push(point);
                    }
                }
            });
            
            if (newPoints.length > 0) {
                knownPoints = knownPoints.concat(newPoints);
                updateKnownPointsList();
                
                if (csvData.length > 0) {
                    analyzeData();
                }
            } else {
                alert('No valid points found in file. Expected format: Name, X, Y, Z');
            }
        }
        
        function clearKnownPoints() {
            if (knownPoints.length > 0 && !confirm('Clear all known points?')) {
                return;
            }
            knownPoints = [];
            updateKnownPointsList();
            if (csvData.length > 0) {
                analyzeData();
            }
        }
        
        function updateKnownPointsList() {
            document.getElementById('knownPointCount').textContent = knownPoints.length;
            
            const list = document.getElementById('knownPointsList');
            if (knownPoints.length === 0) {
                list.innerHTML = '<div style="color: #999; padding: 10px;">No known points added</div>';
            } else {
                list.innerHTML = `
                    <table style="width: 100%; font-size: 12px;">
                        <tr style="background: #f5f5f5;">
                            <th style="padding: 5px;">Name</th>
                            <th style="padding: 5px;">X</th>
                            <th style="padding: 5px;">Y</th>
                            <th style="padding: 5px;">Z</th>
                            <th style="padding: 5px;">Action</th>
                        </tr>
                        ${knownPoints.map((pt, idx) => `
                            <tr>
                                <td style="padding: 5px;">${pt.name}</td>
                                <td style="padding: 5px;">${pt.x.toFixed(3)}</td>
                                <td style="padding: 5px;">${pt.y.toFixed(3)}</td>
                                <td style="padding: 5px;">${pt.z !== null ? pt.z.toFixed(3) : 'N/A'}</td>
                                <td style="padding: 5px;">
                                    <button onclick="removeKnownPoint(${idx})" style="padding: 2px 8px; font-size: 11px; cursor: pointer;">Remove</button>
                                </td>
                            </tr>
                        `).join('')}
                    </table>
                `;
            }
        }
        
        function removeKnownPoint(idx) {
            knownPoints.splice(idx, 1);
            updateKnownPointsList();
            if (csvData.length > 0) {
                analyzeData();
            }
        }
        
        function matchToKnownPoints(data, tolerance) {
            const matches = [];
            
            data.forEach((point, idx) => {
                const x = parseFloat(point.X);
                const y = parseFloat(point.Y);
                const z = parseFloat(point.Elevation);
                
                let bestMatch = null;
                let bestDist = Infinity;
                
                knownPoints.forEach(known => {
                    const dist = Math.sqrt(Math.pow(x - known.x, 2) + Math.pow(y - known.y, 2));
                    if (dist < bestDist && dist <= tolerance * 5) { // Use 5x tolerance for matching
                        bestDist = dist;
                        bestMatch = known;
                    }
                });
                
                if (bestMatch) {
                    const hError = Math.sqrt(Math.pow(x - bestMatch.x, 2) + Math.pow(y - bestMatch.y, 2));
                    const vError = bestMatch.z !== null ? z - bestMatch.z : null;
                    
                    matches.push({
                        pointData: point,
                        pointIndex: idx,
                        knownPoint: bestMatch,
                        errors: {
                            horizontal: hError,
                            vertical: vError,
                            eastingError: x - bestMatch.x,
                            northingError: y - bestMatch.y
                        }
                    });
                }
            });
            
            return matches;
        }
        
        function analyzeData() {
            if (datasets.length === 0) {
                document.getElementById('results').style.display = 'none';
                return;
            }
            
            document.getElementById('results').style.display = 'block';
            document.getElementById('knownPointsSection').style.display = 'block';
            
            const tolerance = parseFloat(document.getElementById('tolerance').value);
            const data = getAllData();
            
            // Update filter status
            updateFilterStatus();
            
            // Group points by location
            const locationGroups = groupByLocation(data, tolerance);
            
            // Match to known points if available
            const matches = matchToKnownPoints(data, tolerance);
            
            // Display overall statistics
            displayOverallStats(data, locationGroups);
            
            // Display error analysis if we have known points
            if (knownPoints.length > 0 && matches.length > 0) {
                displayErrorAnalysis(matches);
                document.getElementById('errorAnalysisSection').style.display = 'block';
            } else {
                document.getElementById('errorAnalysisSection').style.display = 'none';
            }
            
            // Create charts
            createScatterChart(data, knownPoints, matches);
            createAccuracyChart(data);
            createVAccuracyChart(data);
            createDOPChart(data);
            createSatChart(data);
            createElevChart(data);
            
            // Display location groups
            displayLocationGroups(locationGroups);
            
            // Analyze DOP vs Accuracy relationships
            analyzeDOPAccuracy();
            
            // Time series analysis
            analyzeTimeSeries();
            
            // Satellite utilization analysis
            analyzeSatellites();
            
            // Speed vs accuracy analysis
            analyzeSpeed();
            
            // Remarks/correction network comparison
            analyzeRemarks();
            
            // Quality metrics
            analyzeQualityMetrics();
            
            // Display data table (show all points with checkboxes)
            displayDataTable();
        }
        
        function updateFilterStatus() {
            const status = document.getElementById('filterStatus');
            if (datasets.length === 0) {
                status.textContent = 'No datasets loaded';
                status.style.color = '#999';
                return;
            }
            
            let totalEnabled = 0;
            let totalPoints = 0;
            
            datasets.forEach(ds => {
                if (ds.enabled) {
                    totalPoints += ds.data.length;
                    totalEnabled += ds.pointsEnabled.filter(e => e).length;
                }
            });
            
            if (totalEnabled === totalPoints) {
                status.textContent = `All ${totalPoints} points included`;
                status.style.color = '#4CAF50';
            } else {
                status.textContent = `${totalEnabled} of ${totalPoints} points included`;
                status.style.color = '#ff9800';
            }
        }
        
        function reanalyze() {
            if (csvData.length > 0) {
                analyzeData();
            }
        }
        
        function displayErrorAnalysis(matches) {
            // Calculate error statistics
            const hErrors = matches.map(m => m.errors.horizontal);
            const vErrors = matches.filter(m => m.errors.vertical !== null).map(m => m.errors.vertical);
            const eErrors = matches.map(m => m.errors.eastingError);
            const nErrors = matches.map(m => m.errors.northingError);
            
            const meanHError = hErrors.reduce((a, b) => a + b, 0) / hErrors.length;
            const meanVError = vErrors.length > 0 ? vErrors.reduce((a, b) => a + b, 0) / vErrors.length : null;
            const meanEError = eErrors.reduce((a, b) => a + b, 0) / eErrors.length;
            const meanNError = nErrors.reduce((a, b) => a + b, 0) / nErrors.length;
            
            const rmsHError = Math.sqrt(hErrors.reduce((sum, e) => sum + e * e, 0) / hErrors.length);
            const rmsVError = vErrors.length > 0 ? Math.sqrt(vErrors.reduce((sum, e) => sum + e * e, 0) / vErrors.length) : null;
            
            const maxHError = Math.max(...hErrors);
            const maxVError = vErrors.length > 0 ? Math.max(...vErrors.map(Math.abs)) : null;
            
            const stats = [
                {
                    label: 'Matched Points',
                    value: matches.length
                },
                {
                    label: 'Mean H. Error',
                    value: (meanHError * 1000).toFixed(1) + ' mm'
                },
                {
                    label: 'RMS H. Error',
                    value: (rmsHError * 1000).toFixed(1) + ' mm'
                },
                {
                    label: 'Max H. Error',
                    value: (maxHError * 1000).toFixed(1) + ' mm'
                },
                {
                    label: 'Mean Easting Bias',
                    value: (meanEError * 1000).toFixed(1) + ' mm'
                },
                {
                    label: 'Mean Northing Bias',
                    value: (meanNError * 1000).toFixed(1) + ' mm'
                }
            ];
            
            if (meanVError !== null) {
                stats.push({
                    label: 'Mean V. Error',
                    value: (meanVError * 1000).toFixed(1) + ' mm'
                });
                stats.push({
                    label: 'RMS V. Error',
                    value: (rmsVError * 1000).toFixed(1) + ' mm'
                });
            }
            
            const container = document.getElementById('errorStats');
            container.innerHTML = stats.map(stat => `
                <div class="stat-card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">
                    <div class="stat-label">${stat.label}</div>
                    <div class="stat-value">${stat.value}</div>
                </div>
            `).join('');
            
            // Create error charts
            createErrorVectorChart(matches);
            createHErrorChart(matches);
            createVErrorChart(matches);
            createErrorVsAccuracyChart(matches);
            
            // Display matched points detail
            displayMatchedPoints(matches);
        }
        
        function displayMatchedPoints(matches) {
            const container = document.getElementById('matchedPointsDetail');
            
            container.innerHTML = `
                <div style="overflow-x: auto;">
                    <table>
                        <thead>
                            <tr>
                                <th>GPS ID</th>
                                <th>Known Point</th>
                                <th>H. Error (mm)</th>
                                <th>V. Error (mm)</th>
                                <th>E Error (mm)</th>
                                <th>N Error (mm)</th>
                                <th>Reported H.Acc (mm)</th>
                                <th>Reported V.Acc (mm)</th>
                                <th>Satellites</th>
                                <th>HDOP</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${matches.map(m => {
                                const hAcc = parseFloat(m.pointData['Horizontal Accuracy']) * 1000;
                                const vAcc = parseFloat(m.pointData['Vertical Accuracy']) * 1000;
                                const hError = m.errors.horizontal * 1000;
                                const vError = m.errors.vertical !== null ? m.errors.vertical * 1000 : null;
                                
                                const hAccGood = hError <= hAcc;
                                const vAccGood = vError !== null && Math.abs(vError) <= vAcc;
                                
                                return `
                                    <tr style="${!hAccGood ? 'background: #ffebee;' : ''}">
                                        <td>${m.pointData.ID}</td>
                                        <td><strong>${m.knownPoint.name}</strong></td>
                                        <td style="${!hAccGood ? 'color: red; font-weight: bold;' : ''}">${hError.toFixed(1)}</td>
                                        <td style="${vError !== null && !vAccGood ? 'color: red; font-weight: bold;' : ''}">${vError !== null ? vError.toFixed(1) : 'N/A'}</td>
                                        <td>${(m.errors.eastingError * 1000).toFixed(1)}</td>
                                        <td>${(m.errors.northingError * 1000).toFixed(1)}</td>
                                        <td>${hAcc.toFixed(1)}</td>
                                        <td>${vAcc.toFixed(1)}</td>
                                        <td>${m.pointData['Satellites in Use']}</td>
                                        <td>${m.pointData.HDOP}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
                ${matches.some(m => m.errors.horizontal * 1000 > parseFloat(m.pointData['Horizontal Accuracy']) * 1000) ? 
                    '<div class="warning" style="margin-top: 15px;">‚ö†Ô∏è Some points have actual errors exceeding reported accuracy (highlighted in red)</div>' : 
                    '<div class="info" style="margin-top: 15px;">‚úì All errors are within reported accuracy bounds</div>'}
            `;
        }
        
        function groupByLocation(data, tolerance) {
            const groups = [];
            const processed = new Set();
            
            data.forEach((point, idx) => {
                if (processed.has(idx)) return;
                
                const x = parseFloat(point.X);
                const y = parseFloat(point.Y);
                
                const group = {
                    points: [point],
                    indices: [idx]
                };
                
                // Find all points within tolerance
                data.forEach((other, otherIdx) => {
                    if (otherIdx === idx || processed.has(otherIdx)) return;
                    
                    const ox = parseFloat(other.X);
                    const oy = parseFloat(other.Y);
                    
                    const distance = Math.sqrt(Math.pow(x - ox, 2) + Math.pow(y - oy, 2));
                    
                    if (distance <= tolerance) {
                        group.points.push(other);
                        group.indices.push(otherIdx);
                        processed.add(otherIdx);
                    }
                });
                
                processed.add(idx);
                groups.push(group);
            });
            
            return groups.sort((a, b) => b.points.length - a.points.length);
        }
        
        function displayOverallStats(data, groups) {
            const multiPointGroups = groups.filter(g => g.points.length > 1);
            
            const hAccuracies = data.map(d => parseFloat(d['Horizontal Accuracy']));
            const vAccuracies = data.map(d => parseFloat(d['Vertical Accuracy']));
            
            const stats = [
                {
                    label: 'Total Points',
                    value: data.length
                },
                {
                    label: 'Location Groups',
                    value: groups.length
                },
                {
                    label: 'Repeated Locations',
                    value: multiPointGroups.length
                },
                {
                    label: 'Avg H. Accuracy',
                    value: (hAccuracies.reduce((a, b) => a + b, 0) / hAccuracies.length).toFixed(3) + ' m'
                },
                {
                    label: 'Avg V. Accuracy',
                    value: (vAccuracies.reduce((a, b) => a + b, 0) / vAccuracies.length).toFixed(3) + ' m'
                },
                {
                    label: 'Max Satellites',
                    value: Math.max(...data.map(d => parseInt(d['Satellites in Use'])))
                }
            ];
            
            const container = document.getElementById('overallStats');
            container.innerHTML = stats.map(stat => `
                <div class="stat-card">
                    <div class="stat-label">${stat.label}</div>
                    <div class="stat-value">${stat.value}</div>
                </div>
            `).join('');
            
            // Display comparative stats if multiple datasets
            if (datasets.filter(ds => ds.enabled).length > 1) {
                displayComparativeStats();
            } else {
                document.getElementById('comparativeStats').style.display = 'none';
            }
        }
        
        function displayComparativeStats() {
            const enabledDatasets = datasets.filter(ds => ds.enabled);
            
            const comparisonData = enabledDatasets.map(ds => {
                const points = ds.data.filter((p, idx) => ds.pointsEnabled[idx]);
                
                const hAccs = points.map(p => parseFloat(p['Horizontal Accuracy']));
                const vAccs = points.map(p => parseFloat(p['Vertical Accuracy']));
                const sats = points.map(p => parseInt(p['Satellites in Use']));
                const hdops = points.map(p => parseFloat(p.HDOP));
                
                return {
                    name: ds.name,
                    color: ds.color,
                    count: points.length,
                    avgHAcc: (hAccs.reduce((a,b)=>a+b,0)/hAccs.length * 1000).toFixed(1),
                    avgVAcc: (vAccs.reduce((a,b)=>a+b,0)/vAccs.length * 1000).toFixed(1),
                    avgSats: (sats.reduce((a,b)=>a+b,0)/sats.length).toFixed(1),
                    avgHDOP: (hdops.reduce((a,b)=>a+b,0)/hdops.length).toFixed(2)
                };
            });
            
            const table = document.getElementById('comparisonTable');
            table.innerHTML = `
                <thead>
                    <tr>
                        <th>Dataset</th>
                        <th>Points</th>
                        <th>Avg H.Acc (mm)</th>
                        <th>Avg V.Acc (mm)</th>
                        <th>Avg Satellites</th>
                        <th>Avg HDOP</th>
                    </tr>
                </thead>
                <tbody>
                    ${comparisonData.map(d => `
                        <tr>
                            <td style="color: ${d.color}; font-weight: bold; border-left: 3px solid ${d.color}; padding-left: 10px;">${d.name}</td>
                            <td>${d.count}</td>
                            <td>${d.avgHAcc}</td>
                            <td>${d.avgVAcc}</td>
                            <td>${d.avgSats}</td>
                            <td>${d.avgHDOP}</td>
                        </tr>
                    `).join('')}
                </tbody>
            `;
            
            document.getElementById('comparativeStats').style.display = 'block';
        }
        
        function calculateCorrelation(x, y) {
            const n = x.length;
            if (n === 0) return { r: 0, r2: 0 };
            
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);
            const sumY2 = y.reduce((sum, yi) => sum + yi * yi, 0);
            
            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
            
            if (denominator === 0) return { r: 0, r2: 0 };
            
            const r = numerator / denominator;
            const r2 = r * r;
            
            return { r, r2 };
        }
        
        function analyzeDOPAccuracy() {
            const data = getAllData();
            
            if (data.length < 5) {
                document.getElementById('dopAnalysis').style.display = 'none';
                return;
            }
            
            // Extract data
            const hdop = data.map(d => parseFloat(d.HDOP)).filter(v => !isNaN(v));
            const vdop = data.map(d => parseFloat(d.VDOP)).filter(v => !isNaN(v));
            const pdop = data.map(d => parseFloat(d.PDOP)).filter(v => !isNaN(v));
            const hAcc = data.map(d => parseFloat(d['Horizontal Accuracy'])).filter(v => !isNaN(v));
            const vAcc = data.map(d => parseFloat(d['Vertical Accuracy'])).filter(v => !isNaN(v));
            
            // Calculate correlations
            const hdopCorr = calculateCorrelation(hdop, hAcc);
            const vdopCorr = calculateCorrelation(vdop, vAcc);
            
            // Calculate 3D position accuracy: sqrt(hAcc^2 + vAcc^2)
            const posAcc = data.map(d => {
                const h = parseFloat(d['Horizontal Accuracy']);
                const v = parseFloat(d['Vertical Accuracy']);
                return !isNaN(h) && !isNaN(v) ? Math.sqrt(h*h + v*v) : NaN;
            }).filter(v => !isNaN(v));
            
            const pdopCorr = calculateCorrelation(pdop, posAcc);
            
            // Display stats
            const statsGrid = document.getElementById('dopStatsGrid');
            const stats = [
                {
                    label: 'HDOP-H.Acc Correlation',
                    value: hdopCorr.r.toFixed(3),
                    color: Math.abs(hdopCorr.r) > 0.7 ? '#4CAF50' : '#FF9800'
                },
                {
                    label: 'HDOP-H.Acc R¬≤',
                    value: (hdopCorr.r2 * 100).toFixed(1) + '%',
                    color: hdopCorr.r2 > 0.5 ? '#4CAF50' : '#FF9800'
                },
                {
                    label: 'VDOP-V.Acc Correlation',
                    value: vdopCorr.r.toFixed(3),
                    color: Math.abs(vdopCorr.r) > 0.7 ? '#4CAF50' : '#FF9800'
                },
                {
                    label: 'VDOP-V.Acc R¬≤',
                    value: (vdopCorr.r2 * 100).toFixed(1) + '%',
                    color: vdopCorr.r2 > 0.5 ? '#4CAF50' : '#FF9800'
                },
                {
                    label: 'PDOP-Pos.Acc Correlation',
                    value: pdopCorr.r.toFixed(3),
                    color: Math.abs(pdopCorr.r) > 0.7 ? '#4CAF50' : '#FF9800'
                },
                {
                    label: 'PDOP-Pos.Acc R¬≤',
                    value: (pdopCorr.r2 * 100).toFixed(1) + '%',
                    color: pdopCorr.r2 > 0.5 ? '#4CAF50' : '#FF9800'
                }
            ];
            
            statsGrid.innerHTML = stats.map(stat => `
                <div class="stat-card" style="background: linear-gradient(135deg, ${stat.color} 0%, ${stat.color}DD 100%);">
                    <div class="stat-label">${stat.label}</div>
                    <div class="stat-value">${stat.value}</div>
                </div>
            `).join('');
            
            // Create charts
            createHDOPvsHAccChart(data);
            createVDOPvsVAccChart(data);
            createPDOPvsPosAccChart(data);
            
            document.getElementById('dopAnalysis').style.display = 'block';
        }
        
        function createHDOPvsHAccChart(data) {
            const ctx = document.getElementById('hdopVsHAccChart');
            if (charts.hdopVsHAcc) charts.hdopVsHAcc.destroy();
            
            // Group by dataset
            const datasetGroups = {};
            data.forEach(point => {
                const dsName = point._dataset || 'Unknown';
                if (!datasetGroups[dsName]) {
                    datasetGroups[dsName] = [];
                }
                const hdop = parseFloat(point.HDOP);
                const hAcc = parseFloat(point['Horizontal Accuracy']) * 1000; // Convert to mm
                if (!isNaN(hdop) && !isNaN(hAcc)) {
                    datasetGroups[dsName].push({ x: hdop, y: hAcc, id: point.ID });
                }
            });
            
            const chartDatasets = Object.keys(datasetGroups).map(dsName => {
                const points = datasetGroups[dsName];
                const color = points[0] ? data.find(d => d._dataset === dsName)?._color || '#4CAF50' : '#4CAF50';
                
                return {
                    label: dsName,
                    data: points,
                    backgroundColor: color + 'AA',
                    borderColor: color,
                    pointRadius: 5
                };
            });
            
            // Calculate trendline for all data
            const allPoints = Object.values(datasetGroups).flat();
            const xVals = allPoints.map(p => p.x);
            const yVals = allPoints.map(p => p.y);
            const corr = calculateCorrelation(xVals, yVals);
            
            // Calculate linear regression
            const n = xVals.length;
            const sumX = xVals.reduce((a, b) => a + b, 0);
            const sumY = yVals.reduce((a, b) => a + b, 0);
            const sumXY = xVals.reduce((sum, xi, i) => sum + xi * yVals[i], 0);
            const sumX2 = xVals.reduce((sum, xi) => sum + xi * xi, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            const minX = Math.min(...xVals);
            const maxX = Math.max(...xVals);
            
            chartDatasets.push({
                label: `Trendline (R¬≤=${(corr.r2*100).toFixed(1)}%)`,
                data: [
                    { x: minX, y: slope * minX + intercept },
                    { x: maxX, y: slope * maxX + intercept }
                ],
                borderColor: 'rgba(244, 67, 54, 0.8)',
                borderWidth: 2,
                borderDash: [10, 5],
                pointRadius: 0,
                showLine: true,
                fill: false,
                type: 'line'
            });
            
            charts.hdopVsHAcc = new Chart(ctx, {
                type: 'scatter',
                data: { datasets: chartDatasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const point = context.raw;
                                    if (point.id) {
                                        return [
                                            `ID: ${point.id}`,
                                            `HDOP: ${point.x.toFixed(2)}`,
                                            `H.Acc: ${point.y.toFixed(1)} mm`
                                        ];
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'HDOP (lower is better)'
                            },
                            beginAtZero: false
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Horizontal Accuracy (mm)'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }
        
        function createVDOPvsVAccChart(data) {
            const ctx = document.getElementById('vdopVsVAccChart');
            if (charts.vdopVsVAcc) charts.vdopVsVAcc.destroy();
            
            // Group by dataset
            const datasetGroups = {};
            data.forEach(point => {
                const dsName = point._dataset || 'Unknown';
                if (!datasetGroups[dsName]) {
                    datasetGroups[dsName] = [];
                }
                const vdop = parseFloat(point.VDOP);
                const vAcc = parseFloat(point['Vertical Accuracy']) * 1000; // Convert to mm
                if (!isNaN(vdop) && !isNaN(vAcc)) {
                    datasetGroups[dsName].push({ x: vdop, y: vAcc, id: point.ID });
                }
            });
            
            const chartDatasets = Object.keys(datasetGroups).map(dsName => {
                const points = datasetGroups[dsName];
                const color = points[0] ? data.find(d => d._dataset === dsName)?._color || '#2196F3' : '#2196F3';
                
                return {
                    label: dsName,
                    data: points,
                    backgroundColor: color + 'AA',
                    borderColor: color,
                    pointRadius: 5
                };
            });
            
            // Calculate trendline
            const allPoints = Object.values(datasetGroups).flat();
            const xVals = allPoints.map(p => p.x);
            const yVals = allPoints.map(p => p.y);
            const corr = calculateCorrelation(xVals, yVals);
            
            const n = xVals.length;
            const sumX = xVals.reduce((a, b) => a + b, 0);
            const sumY = yVals.reduce((a, b) => a + b, 0);
            const sumXY = xVals.reduce((sum, xi, i) => sum + xi * yVals[i], 0);
            const sumX2 = xVals.reduce((sum, xi) => sum + xi * xi, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            const minX = Math.min(...xVals);
            const maxX = Math.max(...xVals);
            
            chartDatasets.push({
                label: `Trendline (R¬≤=${(corr.r2*100).toFixed(1)}%)`,
                data: [
                    { x: minX, y: slope * minX + intercept },
                    { x: maxX, y: slope * maxX + intercept }
                ],
                borderColor: 'rgba(244, 67, 54, 0.8)',
                borderWidth: 2,
                borderDash: [10, 5],
                pointRadius: 0,
                showLine: true,
                fill: false,
                type: 'line'
            });
            
            charts.vdopVsVAcc = new Chart(ctx, {
                type: 'scatter',
                data: { datasets: chartDatasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const point = context.raw;
                                    if (point.id) {
                                        return [
                                            `ID: ${point.id}`,
                                            `VDOP: ${point.x.toFixed(2)}`,
                                            `V.Acc: ${point.y.toFixed(1)} mm`
                                        ];
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'VDOP (lower is better)'
                            },
                            beginAtZero: false
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Vertical Accuracy (mm)'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }
        
        function createPDOPvsPosAccChart(data) {
            const ctx = document.getElementById('pdopVsPosAccChart');
            if (charts.pdopVsPosAcc) charts.pdopVsPosAcc.destroy();
            
            // Group by dataset
            const datasetGroups = {};
            data.forEach(point => {
                const dsName = point._dataset || 'Unknown';
                if (!datasetGroups[dsName]) {
                    datasetGroups[dsName] = [];
                }
                const pdop = parseFloat(point.PDOP);
                const hAcc = parseFloat(point['Horizontal Accuracy']);
                const vAcc = parseFloat(point['Vertical Accuracy']);
                if (!isNaN(pdop) && !isNaN(hAcc) && !isNaN(vAcc)) {
                    const posAcc = Math.sqrt(hAcc*hAcc + vAcc*vAcc) * 1000; // 3D accuracy in mm
                    datasetGroups[dsName].push({ x: pdop, y: posAcc, id: point.ID });
                }
            });
            
            const chartDatasets = Object.keys(datasetGroups).map(dsName => {
                const points = datasetGroups[dsName];
                const color = points[0] ? data.find(d => d._dataset === dsName)?._color || '#9C27B0' : '#9C27B0';
                
                return {
                    label: dsName,
                    data: points,
                    backgroundColor: color + 'AA',
                    borderColor: color,
                    pointRadius: 5
                };
            });
            
            // Calculate trendline
            const allPoints = Object.values(datasetGroups).flat();
            const xVals = allPoints.map(p => p.x);
            const yVals = allPoints.map(p => p.y);
            const corr = calculateCorrelation(xVals, yVals);
            
            const n = xVals.length;
            const sumX = xVals.reduce((a, b) => a + b, 0);
            const sumY = yVals.reduce((a, b) => a + b, 0);
            const sumXY = xVals.reduce((sum, xi, i) => sum + xi * yVals[i], 0);
            const sumX2 = xVals.reduce((sum, xi) => sum + xi * xi, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            const minX = Math.min(...xVals);
            const maxX = Math.max(...xVals);
            
            chartDatasets.push({
                label: `Trendline (R¬≤=${(corr.r2*100).toFixed(1)}%)`,
                data: [
                    { x: minX, y: slope * minX + intercept },
                    { x: maxX, y: slope * maxX + intercept }
                ],
                borderColor: 'rgba(244, 67, 54, 0.8)',
                borderWidth: 2,
                borderDash: [10, 5],
                pointRadius: 0,
                showLine: true,
                fill: false,
                type: 'line'
            });
            
            charts.pdopVsPosAcc = new Chart(ctx, {
                type: 'scatter',
                data: { datasets: chartDatasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const point = context.raw;
                                    if (point.id) {
                                        return [
                                            `ID: ${point.id}`,
                                            `PDOP: ${point.x.toFixed(2)}`,
                                            `Pos.Acc: ${point.y.toFixed(1)} mm`
                                        ];
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'PDOP (lower is better)'
                            },
                            beginAtZero: false
                        },
                        y: {
                            title: {
                                display: true,
                                text: '3D Position Accuracy (mm)'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }
        
        function analyzeTimeSeries() {
            const data = getAllData();
            
            // Check if we have time data
            const hasTime = data.some(d => d.Time);
            if (!hasTime || data.length < 3) {
                document.getElementById('timeSeriesAnalysis').style.display = 'none';
                return;
            }
            
            // Parse times and create time series
            const timeData = data.map(d => {
                const timeStr = d.Time;
                const match = timeStr.match(/(\d{2}\/\d{2}\/\d{4})\s+(\d{2}:\d{2}:\d{2})/);
                if (match) {
                    const [_, dateStr, timeStr] = match;
                    const [month, day, year] = dateStr.split('/');
                    const [hours, minutes, seconds] = timeStr.split(':');
                    return {
                        time: new Date(year, month-1, day, hours, minutes, seconds),
                        hAcc: parseFloat(d['Horizontal Accuracy']) * 1000,
                        vAcc: parseFloat(d['Vertical Accuracy']) * 1000,
                        hdop: parseFloat(d.HDOP),
                        vdop: parseFloat(d.VDOP),
                        pdop: parseFloat(d.PDOP),
                        sats: parseInt(d['Satellites in Use']),
                        dataset: d._dataset,
                        color: d._color
                    };
                }
                return null;
            }).filter(d => d && d.time);
            
            if (timeData.length < 3) {
                document.getElementById('timeSeriesAnalysis').style.display = 'none';
                return;
            }
            
            // Sort by time
            timeData.sort((a, b) => a.time - b.time);
            
            createAccuracyOverTimeChart(timeData);
            createDOPOverTimeChart(timeData);
            createSatOverTimeChart(timeData);
            
            document.getElementById('timeSeriesAnalysis').style.display = 'block';
        }
        
        function createAccuracyOverTimeChart(timeData) {
            const ctx = document.getElementById('accuracyOverTimeChart');
            if (charts.accuracyOverTime) charts.accuracyOverTime.destroy();
            
            // Group by dataset
            const datasets = {};
            timeData.forEach(d => {
                if (!datasets[d.dataset]) {
                    datasets[d.dataset] = { hAcc: [], vAcc: [], color: d.color };
                }
                datasets[d.dataset].hAcc.push({ x: d.time, y: d.hAcc });
                datasets[d.dataset].vAcc.push({ x: d.time, y: d.vAcc });
            });
            
            const chartDatasets = [];
            Object.keys(datasets).forEach(name => {
                const data = datasets[name];
                chartDatasets.push({
                    label: `${name} - H.Acc`,
                    data: data.hAcc,
                    borderColor: data.color,
                    backgroundColor: data.color + '33',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1
                });
                chartDatasets.push({
                    label: `${name} - V.Acc`,
                    data: data.vAcc,
                    borderColor: data.color,
                    backgroundColor: data.color + '33',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    fill: false,
                    tension: 0.1
                });
            });
            
            charts.accuracyOverTime = new Chart(ctx, {
                type: 'line',
                data: { datasets: chartDatasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        x: {
                            type: 'time',
                            time: { tooltipFormat: 'HH:mm:ss' },
                            title: { display: true, text: 'Time' }
                        },
                        y: {
                            title: { display: true, text: 'Accuracy (mm)' },
                            beginAtZero: true
                        }
                    }
                }
            });
        }
        
        function createDOPOverTimeChart(timeData) {
            const ctx = document.getElementById('dopOverTimeChart');
            if (charts.dopOverTime) charts.dopOverTime.destroy();
            
            const datasets = {};
            timeData.forEach(d => {
                if (!datasets[d.dataset]) {
                    datasets[d.dataset] = { hdop: [], vdop: [], pdop: [], color: d.color };
                }
                datasets[d.dataset].hdop.push({ x: d.time, y: d.hdop });
                datasets[d.dataset].vdop.push({ x: d.time, y: d.vdop });
                datasets[d.dataset].pdop.push({ x: d.time, y: d.pdop });
            });
            
            const chartDatasets = [];
            Object.keys(datasets).forEach(name => {
                const data = datasets[name];
                chartDatasets.push({
                    label: `${name} - HDOP`,
                    data: data.hdop,
                    borderColor: data.color,
                    borderWidth: 2,
                    fill: false
                });
            });
            
            charts.dopOverTime = new Chart(ctx, {
                type: 'line',
                data: { datasets: chartDatasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        x: {
                            type: 'time',
                            time: { tooltipFormat: 'HH:mm:ss' },
                            title: { display: true, text: 'Time' }
                        },
                        y: {
                            title: { display: true, text: 'DOP Value' },
                            beginAtZero: false
                        }
                    }
                }
            });
        }
        
        function createSatOverTimeChart(timeData) {
            const ctx = document.getElementById('satOverTimeChart');
            if (charts.satOverTime) charts.satOverTime.destroy();
            
            const datasets = {};
            timeData.forEach(d => {
                if (!datasets[d.dataset]) {
                    datasets[d.dataset] = { sats: [], color: d.color };
                }
                datasets[d.dataset].sats.push({ x: d.time, y: d.sats });
            });
            
            const chartDatasets = [];
            Object.keys(datasets).forEach(name => {
                const data = datasets[name];
                chartDatasets.push({
                    label: name,
                    data: data.sats,
                    borderColor: data.color,
                    backgroundColor: data.color + '66',
                    borderWidth: 2,
                    fill: true
                });
            });
            
            charts.satOverTime = new Chart(ctx, {
                type: 'line',
                data: { datasets: chartDatasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        x: {
                            type: 'time',
                            time: { tooltipFormat: 'HH:mm:ss' },
                            title: { display: true, text: 'Time' }
                        },
                        y: {
                            title: { display: true, text: 'Satellites in Use' },
                            beginAtZero: true
                        }
                    }
                }
            });
        }
        
        function analyzeSatellites() {
            const data = getAllData();
            
            const satsInUse = data.map(d => parseInt(d['Satellites in Use'])).filter(v => !isNaN(v));
            const satsInView = data.map(d => parseInt(d['Satellites in View'])).filter(v => !isNaN(v));
            
            if (satsInUse.length < 3) {
                document.getElementById('satelliteAnalysis').style.display = 'none';
                return;
            }
            
            // Calculate efficiency
            const efficiencies = data.map(d => {
                const inUse = parseInt(d['Satellites in Use']);
                const inView = parseInt(d['Satellites in View']);
                return !isNaN(inUse) && !isNaN(inView) && inView > 0 ? (inUse / inView * 100) : null;
            }).filter(v => v !== null);
            
            const avgEfficiency = efficiencies.reduce((a,b)=>a+b,0) / efficiencies.length;
            const minSats = Math.min(...satsInUse);
            const maxSats = Math.max(...satsInUse);
            const avgSats = satsInUse.reduce((a,b)=>a+b,0) / satsInUse.length;
            
            // Correlation between satellites and accuracy
            const hAccs = data.map(d => parseFloat(d['Horizontal Accuracy'])).filter(v => !isNaN(v));
            const satCorr = calculateCorrelation(satsInUse, hAccs);
            
            const stats = [
                { label: 'Avg Satellites Used', value: avgSats.toFixed(1) },
                { label: 'Min Satellites', value: minSats },
                { label: 'Max Satellites', value: maxSats },
                { label: 'Avg Usage Efficiency', value: avgEfficiency.toFixed(1) + '%' },
                { label: 'Sat-Accuracy Correlation', value: satCorr.r.toFixed(3) },
                { label: 'Diminishing Returns?', value: satCorr.r < -0.3 ? 'Yes' : 'No' }
            ];
            
            document.getElementById('satStatsGrid').innerHTML = stats.map(stat => `
                <div class="stat-card">
                    <div class="stat-label">${stat.label}</div>
                    <div class="stat-value">${stat.value}</div>
                </div>
            `).join('');
            
            createSatVsHAccChart(data);
            createSatEfficiencyChart(data);
            
            document.getElementById('satelliteAnalysis').style.display = 'block';
        }
        
        function createSatVsHAccChart(data) {
            const ctx = document.getElementById('satVsHAccChart');
            if (charts.satVsHAcc) charts.satVsHAcc.destroy();
            
            const datasetGroups = {};
            data.forEach(point => {
                const dsName = point._dataset || 'Unknown';
                if (!datasetGroups[dsName]) datasetGroups[dsName] = [];
                const sats = parseInt(point['Satellites in Use']);
                const hAcc = parseFloat(point['Horizontal Accuracy']) * 1000;
                if (!isNaN(sats) && !isNaN(hAcc)) {
                    datasetGroups[dsName].push({ x: sats, y: hAcc, id: point.ID });
                }
            });
            
            const chartDatasets = Object.keys(datasetGroups).map(name => ({
                label: name,
                data: datasetGroups[name],
                backgroundColor: data.find(d => d._dataset === name)?._color + 'AA',
                pointRadius: 5
            }));
            
            charts.satVsHAcc = new Chart(ctx, {
                type: 'scatter',
                data: { datasets: chartDatasets },
                options: {
                    responsive: true,
                    scales: {
                        x: { title: { display: true, text: 'Satellites in Use' }},
                        y: { title: { display: true, text: 'Horizontal Accuracy (mm)' }, beginAtZero: true }
                    }
                }
            });
        }
        
        function createSatEfficiencyChart(data) {
            const ctx = document.getElementById('satEfficiencyChart');
            if (charts.satEfficiency) charts.satEfficiency.destroy();
            
            const datasetGroups = {};
            data.forEach(point => {
                const dsName = point._dataset || 'Unknown';
                if (!datasetGroups[dsName]) datasetGroups[dsName] = [];
                const inUse = parseInt(point['Satellites in Use']);
                const inView = parseInt(point['Satellites in View']);
                if (!isNaN(inUse) && !isNaN(inView) && inView > 0) {
                    datasetGroups[dsName].push(inUse / inView * 100);
                }
            });
            
            const chartDatasets = Object.keys(datasetGroups).map(name => ({
                label: name,
                data: datasetGroups[name],
                backgroundColor: data.find(d => d._dataset === name)?._color + 'AA',
                borderColor: data.find(d => d._dataset === name)?._color,
                borderWidth: 1
            }));
            
            charts.satEfficiency = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: datasetGroups[Object.keys(datasetGroups)[0]].map((_, i) => `Point ${i+1}`),
                    datasets: chartDatasets
                },
                options: {
                    responsive: true,
                    scales: {
                        y: { title: { display: true, text: 'Usage Efficiency (%)' }, beginAtZero: true, max: 100 }
                    }
                }
            });
        }
        
        function analyzeSpeed() {
            const data = getAllData();
            
            const speeds = data.map(d => parseFloat(d.Speed)).filter(v => !isNaN(v) && v >= 0);
            if (speeds.length < 5 || Math.max(...speeds) < 0.1) {
                document.getElementById('speedAnalysis').style.display = 'none';
                return;
            }
            
            // Categorize by speed
            const stationary = data.filter(d => parseFloat(d.Speed) < 0.1);
            const moving = data.filter(d => parseFloat(d.Speed) >= 0.1);
            
            const stationaryHAcc = stationary.map(d => parseFloat(d['Horizontal Accuracy']) * 1000).filter(v => !isNaN(v));
            const movingHAcc = moving.map(d => parseFloat(d['Horizontal Accuracy']) * 1000).filter(v => !isNaN(v));
            
            const stats = [
                { label: 'Stationary Points', value: stationary.length },
                { label: 'Moving Points', value: moving.length },
                { label: 'Avg Stationary H.Acc', value: stationaryHAcc.length > 0 ? (stationaryHAcc.reduce((a,b)=>a+b,0)/stationaryHAcc.length).toFixed(1) + ' mm' : 'N/A' },
                { label: 'Avg Moving H.Acc', value: movingHAcc.length > 0 ? (movingHAcc.reduce((a,b)=>a+b,0)/movingHAcc.length).toFixed(1) + ' mm' : 'N/A' },
                { label: 'Max Speed', value: Math.max(...speeds).toFixed(2) + ' m/s' },
                { label: 'Movement Penalty', value: movingHAcc.length > 0 && stationaryHAcc.length > 0 ? (((movingHAcc.reduce((a,b)=>a+b,0)/movingHAcc.length) / (stationaryHAcc.reduce((a,b)=>a+b,0)/stationaryHAcc.length) - 1) * 100).toFixed(1) + '%' : 'N/A' }
            ];
            
            document.getElementById('speedStatsGrid').innerHTML = stats.map(stat => `
                <div class="stat-card">
                    <div class="stat-label">${stat.label}</div>
                    <div class="stat-value">${stat.value}</div>
                </div>
            `).join('');
            
            createSpeedVsAccChart(data);
            
            document.getElementById('speedAnalysis').style.display = 'block';
        }
        
        function createSpeedVsAccChart(data) {
            const ctx = document.getElementById('speedVsAccChart');
            if (charts.speedVsAcc) charts.speedVsAcc.destroy();
            
            const datasetGroups = {};
            data.forEach(point => {
                const dsName = point._dataset || 'Unknown';
                if (!datasetGroups[dsName]) datasetGroups[dsName] = [];
                const speed = parseFloat(point.Speed);
                const hAcc = parseFloat(point['Horizontal Accuracy']) * 1000;
                if (!isNaN(speed) && !isNaN(hAcc) && speed >= 0) {
                    datasetGroups[dsName].push({ x: speed, y: hAcc, id: point.ID });
                }
            });
            
            const chartDatasets = Object.keys(datasetGroups).map(name => ({
                label: name,
                data: datasetGroups[name],
                backgroundColor: data.find(d => d._dataset === name)?._color + 'AA',
                pointRadius: 5
            }));
            
            charts.speedVsAcc = new Chart(ctx, {
                type: 'scatter',
                data: { datasets: chartDatasets },
                options: {
                    responsive: true,
                    scales: {
                        x: { title: { display: true, text: 'Speed (m/s)' }},
                        y: { title: { display: true, text: 'Horizontal Accuracy (mm)' }, beginAtZero: true }
                    }
                }
            });
        }
        
        function analyzeRemarks() {
            const data = getAllData();
            
            // Extract unique remarks/networks
            const remarkGroups = {};
            data.forEach(d => {
                const remark = (d.Remarks || d.ID || 'Unknown').toLowerCase();
                // Extract network names
                let network = 'Other';
                if (remark.includes('aptella')) network = 'Aptella';
                else if (remark.includes('auscors')) network = 'Auscors';
                else if (remark.includes('track')) network = 'Tracking';
                
                if (!remarkGroups[network]) {
                    remarkGroups[network] = [];
                }
                remarkGroups[network].push(d);
            });
            
            if (Object.keys(remarkGroups).length < 2) {
                document.getElementById('remarksAnalysis').style.display = 'none';
                return;
            }
            
            const comparisonData = Object.keys(remarkGroups).map(network => {
                const points = remarkGroups[network];
                const hAccs = points.map(p => parseFloat(p['Horizontal Accuracy']) * 1000).filter(v => !isNaN(v));
                const vAccs = points.map(p => parseFloat(p['Vertical Accuracy']) * 1000).filter(v => !isNaN(v));
                const hdops = points.map(p => parseFloat(p.HDOP)).filter(v => !isNaN(v));
                
                return {
                    network,
                    count: points.length,
                    avgHAcc: (hAccs.reduce((a,b)=>a+b,0)/hAccs.length).toFixed(1),
                    stdHAcc: Math.sqrt(hAccs.reduce((sum,v)=>sum+Math.pow(v-(hAccs.reduce((a,b)=>a+b,0)/hAccs.length),2),0)/hAccs.length).toFixed(1),
                    avgVAcc: (vAccs.reduce((a,b)=>a+b,0)/vAccs.length).toFixed(1),
                    avgHDOP: (hdops.reduce((a,b)=>a+b,0)/hdops.length).toFixed(2)
                };
            });
            
            const table = document.getElementById('remarksComparisonTable');
            table.innerHTML = `
                <thead>
                    <tr>
                        <th>Network/Mode</th>
                        <th>Points</th>
                        <th>Avg H.Acc (mm)</th>
                        <th>Std Dev H.Acc (mm)</th>
                        <th>Avg V.Acc (mm)</th>
                        <th>Avg HDOP</th>
                    </tr>
                </thead>
                <tbody>
                    ${comparisonData.map(d => `
                        <tr>
                            <td style="font-weight: bold;">${d.network}</td>
                            <td>${d.count}</td>
                            <td>${d.avgHAcc}</td>
                            <td>${d.stdHAcc}</td>
                            <td>${d.avgVAcc}</td>
                            <td>${d.avgHDOP}</td>
                        </tr>
                    `).join('')}
                </tbody>
            `;
            
            document.getElementById('remarksAnalysis').style.display = 'block';
        }
        
        function analyzeQualityMetrics() {
            const data = getAllData();
            
            if (data.length < 3) {
                document.getElementById('qualityMetrics').style.display = 'none';
                return;
            }
            
            const hAccs = data.map(d => parseFloat(d['Horizontal Accuracy']) * 1000).filter(v => !isNaN(v));
            const mean = hAccs.reduce((a,b)=>a+b,0) / hAccs.length;
            const stdDev = Math.sqrt(hAccs.reduce((sum,v)=>sum+Math.pow(v-mean,2),0)/hAccs.length);
            const cv = (stdDev / mean * 100);
            
            // Find outliers (>2 std dev)
            const outliers = hAccs.filter(v => Math.abs(v - mean) > 2 * stdDev);
            
            const stats = [
                { label: 'Mean H.Acc', value: mean.toFixed(1) + ' mm' },
                { label: 'Std Deviation', value: stdDev.toFixed(1) + ' mm' },
                { label: 'Coefficient of Variation', value: cv.toFixed(1) + '%' },
                { label: 'Outliers (>2œÉ)', value: outliers.length },
                { label: 'Best Measurement', value: Math.min(...hAccs).toFixed(1) + ' mm' },
                { label: 'Worst Measurement', value: Math.max(...hAccs).toFixed(1) + ' mm' }
            ];
            
            document.getElementById('qualityStatsGrid').innerHTML = stats.map(stat => `
                <div class="stat-card">
                    <div class="stat-label">${stat.label}</div>
                    <div class="stat-value">${stat.value}</div>
                </div>
            `).join('');
            
            createAccuracyHistogram(hAccs);
            
            document.getElementById('qualityMetrics').style.display = 'block';
        }
        
        function createAccuracyHistogram(hAccs) {
            const ctx = document.getElementById('accuracyHistogram');
            if (charts.accuracyHist) charts.accuracyHist.destroy();
            
            // Create bins
            const min = Math.min(...hAccs);
            const max = Math.max(...hAccs);
            const binCount = Math.min(20, Math.ceil(Math.sqrt(hAccs.length)));
            const binSize = (max - min) / binCount;
            
            const bins = Array(binCount).fill(0);
            const binLabels = [];
            
            for (let i = 0; i < binCount; i++) {
                const binStart = min + i * binSize;
                const binEnd = binStart + binSize;
                binLabels.push(`${binStart.toFixed(1)}-${binEnd.toFixed(1)}`);
                
                bins[i] = hAccs.filter(v => v >= binStart && v < binEnd).length;
            }
            
            charts.accuracyHist = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: binLabels,
                    datasets: [{
                        label: 'Frequency',
                        data: bins,
                        backgroundColor: 'rgba(54, 162, 235, 0.6)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: { title: { display: true, text: 'Horizontal Accuracy (mm)' }},
                        y: { title: { display: true, text: 'Count' }, beginAtZero: true }
                    }
                }
            });
        }
        
        function displayLocationGroups(groups) {
            const container = document.getElementById('locationGroups');
            const multiPointGroups = groups.filter(g => g.points.length > 1);
            
            if (multiPointGroups.length === 0) {
                container.innerHTML = '<div class="info">No repeated locations found within tolerance. Try increasing the tolerance value.</div>';
                return;
            }
            
            container.innerHTML = multiPointGroups.map((group, idx) => {
                const points = group.points;
                
                // Calculate statistics
                const xs = points.map(p => parseFloat(p.X));
                const ys = points.map(p => parseFloat(p.Y));
                const elevs = points.map(p => parseFloat(p.Elevation));
                const hAccs = points.map(p => parseFloat(p['Horizontal Accuracy']));
                const vAccs = points.map(p => parseFloat(p['Vertical Accuracy']));
                const sats = points.map(p => parseInt(p['Satellites in Use']));
                
                const meanX = xs.reduce((a, b) => a + b) / xs.length;
                const meanY = ys.reduce((a, b) => a + b) / ys.length;
                const meanElev = elevs.reduce((a, b) => a + b) / elevs.length;
                
                const rangeX = Math.max(...xs) - Math.min(...xs);
                const rangeY = Math.max(...ys) - Math.min(...ys);
                const rangeElev = Math.max(...elevs) - Math.min(...elevs);
                
                const stdX = Math.sqrt(xs.reduce((sum, x) => sum + Math.pow(x - meanX, 2), 0) / xs.length);
                const stdY = Math.sqrt(ys.reduce((sum, y) => sum + Math.pow(y - meanY, 2), 0) / ys.length);
                const stdElev = Math.sqrt(elevs.reduce((sum, e) => sum + Math.pow(e - meanElev, 2), 0) / elevs.length);
                
                const maxDist = Math.sqrt(Math.pow(rangeX, 2) + Math.pow(rangeY, 2));
                
                const remarks = [...new Set(points.map(p => p.Remarks))].join(', ');
                
                return `
                    <div class="location-group">
                        <div class="location-header">
                            Location ${idx + 1}: ${points.length} measurements
                            ${points.length > 3 ? '‚ö†Ô∏è' : '‚úì'}
                        </div>
                        <div><strong>Remarks:</strong> ${remarks}</div>
                        <div class="metric-grid">
                            <div class="metric">
                                <div class="metric-label">Mean Easting (X)</div>
                                <div class="metric-value">${meanX.toFixed(3)} m</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Mean Northing (Y)</div>
                                <div class="metric-value">${meanY.toFixed(3)} m</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Mean Elevation</div>
                                <div class="metric-value">${meanElev.toFixed(3)} m</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Std Dev X</div>
                                <div class="metric-value">${(stdX * 1000).toFixed(1)} mm</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Std Dev Y</div>
                                <div class="metric-value">${(stdY * 1000).toFixed(1)} mm</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Std Dev Elev</div>
                                <div class="metric-value">${(stdElev * 1000).toFixed(1)} mm</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Max 2D Distance</div>
                                <div class="metric-value">${(maxDist * 1000).toFixed(1)} mm</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Elev Range</div>
                                <div class="metric-value">${(rangeElev * 1000).toFixed(1)} mm</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Avg H. Accuracy</div>
                                <div class="metric-value">${(hAccs.reduce((a,b)=>a+b)/hAccs.length * 1000).toFixed(1)} mm</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Avg V. Accuracy</div>
                                <div class="metric-value">${(vAccs.reduce((a,b)=>a+b)/vAccs.length * 1000).toFixed(1)} mm</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Avg Satellites</div>
                                <div class="metric-value">${(sats.reduce((a,b)=>a+b)/sats.length).toFixed(1)}</div>
                            </div>
                        </div>
                        ${maxDist > 0.05 ? '<div class="warning">‚ö†Ô∏è Position spread exceeds 50mm - check for systematic differences in settings or conditions</div>' : ''}
                        <details>
                            <summary style="cursor: pointer; padding: 10px; background: #f5f5f5; margin-top: 10px; border-radius: 5px;">View Individual Points</summary>
                            <table style="margin-top: 10px; font-size: 12px;">
                                <tr>
                                    <th>ID</th>
                                    <th>Time</th>
                                    <th>X</th>
                                    <th>Y</th>
                                    <th>Elevation</th>
                                    <th>H.Acc</th>
                                    <th>V.Acc</th>
                                    <th>Sats</th>
                                    <th>HDOP</th>
                                </tr>
                                ${points.map(p => `
                                    <tr>
                                        <td>${p.ID}</td>
                                        <td>${p.Time}</td>
                                        <td>${parseFloat(p.X).toFixed(3)}</td>
                                        <td>${parseFloat(p.Y).toFixed(3)}</td>
                                        <td>${parseFloat(p.Elevation).toFixed(3)}</td>
                                        <td>${(parseFloat(p['Horizontal Accuracy'])*1000).toFixed(1)}</td>
                                        <td>${(parseFloat(p['Vertical Accuracy'])*1000).toFixed(1)}</td>
                                        <td>${p['Satellites in Use']}</td>
                                        <td>${p.HDOP}</td>
                                    </tr>
                                `).join('')}
                            </table>
                        </details>
                    </div>
                `;
            }).join('');
        }
        
        function displayDataTable() {
            const table = document.getElementById('dataTable');
            
            if (datasets.length === 0) {
                table.innerHTML = '<p style="padding: 20px; text-align: center; color: #999;">No data loaded</p>';
                return;
            }
            
            const headers = ['Select', 'Dataset', 'ID', 'Remarks', 'Time', 'Latitude', 'Longitude', 'X', 'Y', 'Elevation', 
                           'Horizontal Accuracy', 'Vertical Accuracy', 'PDOP', 'HDOP', 'VDOP', 
                           'Satellites in Use', 'Fix ID'];
            
            let tableHTML = `
                <thead>
                    <tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr>
                </thead>
                <tbody>
            `;
            
            datasets.forEach((ds, dsIdx) => {
                ds.data.forEach((row, pointIdx) => {
                    const isEnabled = ds.pointsEnabled[pointIdx] && ds.enabled;
                    const rowStyle = isEnabled ? `style="border-left: 3px solid ${ds.color};"` : `style="opacity: 0.4; background: #f5f5f5; border-left: 3px solid ${ds.color};"`;
                    
                    tableHTML += `
                        <tr ${rowStyle}>
                            <td><input type="checkbox" ${isEnabled ? 'checked' : ''} ${!ds.enabled ? 'disabled' : ''} onchange="togglePoint(${dsIdx}, ${pointIdx})" style="cursor: pointer; width: 20px; height: 20px;"></td>
                            <td style="color: ${ds.color}; font-weight: bold; font-size: 11px;">${ds.name.substring(0, 20)}</td>
                            <td>${row['ID'] || ''}</td>
                            <td>${row['Remarks'] || ''}</td>
                            <td style="font-size: 11px;">${row['Time'] || ''}</td>
                            <td>${row['Latitude'] || ''}</td>
                            <td>${row['Longitude'] || ''}</td>
                            <td>${row['X'] || ''}</td>
                            <td>${row['Y'] || ''}</td>
                            <td>${row['Elevation'] || ''}</td>
                            <td>${row['Horizontal Accuracy'] || ''}</td>
                            <td>${row['Vertical Accuracy'] || ''}</td>
                            <td>${row['PDOP'] || ''}</td>
                            <td>${row['HDOP'] || ''}</td>
                            <td>${row['VDOP'] || ''}</td>
                            <td>${row['Satellites in Use'] || ''}</td>
                            <td>${row['Fix ID'] || ''}</td>
                        </tr>
                    `;
                });
            });
            
            tableHTML += '</tbody>';
            table.innerHTML = tableHTML;
        }
        
        function createScatterChart(data, knownPts = [], matches = []) {
            const ctx = document.getElementById('scatterChart');
            
            if (charts.scatter) charts.scatter.destroy();
            
            // Group data by dataset
            const datasetGroups = {};
            data.forEach(point => {
                const dsName = point._dataset || 'Unknown';
                if (!datasetGroups[dsName]) {
                    datasetGroups[dsName] = [];
                }
                datasetGroups[dsName].push(point);
            });
            
            const chartDatasets = [];
            
            // Add dataset groups
            Object.keys(datasetGroups).forEach(dsName => {
                const points = datasetGroups[dsName];
                const color = points[0]._color || '#4CAF50';
                
                chartDatasets.push({
                    label: dsName,
                    data: points.map(d => ({
                        x: parseFloat(d.X),
                        y: parseFloat(d.Y),
                        id: d.ID,
                        remark: d.Remarks || d.ID
                    })),
                    backgroundColor: color + 'CC',
                    borderColor: color,
                    pointRadius: 5
                });
            });
            
            // Add known points if available
            if (knownPts.length > 0) {
                chartDatasets.push({
                    label: 'Known Reference Points',
                    data: knownPts.map(pt => ({
                        x: pt.x,
                        y: pt.y,
                        name: pt.name
                    })),
                    backgroundColor: 'rgba(76, 175, 80, 0.8)',
                    borderColor: 'rgba(76, 175, 80, 1)',
                    borderWidth: 3,
                    pointRadius: 10,
                    pointStyle: 'triangle'
                });
                
                // Add error vectors as line segments
                if (matches.length > 0) {
                    matches.forEach((match, idx) => {
                        const gpsX = parseFloat(match.pointData.X);
                        const gpsY = parseFloat(match.pointData.Y);
                        
                        chartDatasets.push({
                            label: idx === 0 ? 'Error Vectors' : '',
                            data: [
                                { x: match.knownPoint.x, y: match.knownPoint.y },
                                { x: gpsX, y: gpsY }
                            ],
                            borderColor: 'rgba(244, 67, 54, 0.6)',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            showLine: true,
                            fill: false
                        });
                    });
                }
            }
            
            charts.scatter = new Chart(ctx, {
                type: 'scatter',
                data: { datasets: chartDatasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const point = context.raw;
                                    if (point.id) {
                                        return [
                                            `GPS ID: ${point.id}`,
                                            `Remark: ${point.remark}`,
                                            `X: ${point.x.toFixed(3)}`,
                                            `Y: ${point.y.toFixed(3)}`
                                        ];
                                    } else if (point.name) {
                                        return [
                                            `Known Point: ${point.name}`,
                                            `X: ${point.x.toFixed(3)}`,
                                            `Y: ${point.y.toFixed(3)}`
                                        ];
                                    }
                                    return '';
                                }
                            }
                        },
                        legend: {
                            display: true,
                            labels: {
                                filter: (item) => {
                                    return item.text && item.text !== '';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Easting (X) - meters'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Northing (Y) - meters'
                            }
                        }
                    }
                }
            });
        }
        
        function createErrorVectorChart(matches) {
            const ctx = document.getElementById('errorVectorChart');
            if (charts.errorVector) charts.errorVector.destroy();
            
            charts.errorVector = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Known Points (0,0)',
                            data: matches.map(m => ({ x: 0, y: 0 })),
                            backgroundColor: 'rgba(76, 175, 80, 0.8)',
                            borderColor: 'rgba(76, 175, 80, 1)',
                            pointRadius: 8,
                            pointStyle: 'triangle'
                        },
                        {
                            label: 'GPS Errors',
                            data: matches.map(m => ({
                                x: m.errors.eastingError * 1000,
                                y: m.errors.northingError * 1000,
                                id: m.pointData.ID,
                                known: m.knownPoint.name
                            })),
                            backgroundColor: 'rgba(244, 67, 54, 0.6)',
                            borderColor: 'rgba(244, 67, 54, 1)',
                            pointRadius: 6
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const point = context.raw;
                                    if (point.id) {
                                        return [
                                            `GPS ID: ${point.id}`,
                                            `Known Point: ${point.known}`,
                                            `E Error: ${point.x.toFixed(1)} mm`,
                                            `N Error: ${point.y.toFixed(1)} mm`
                                        ];
                                    }
                                    return 'True Position';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Easting Error (mm)'
                            },
                            grid: {
                                color: (context) => context.tick.value === 0 ? 'rgba(0,0,0,0.3)' : 'rgba(0,0,0,0.1)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Northing Error (mm)'
                            },
                            grid: {
                                color: (context) => context.tick.value === 0 ? 'rgba(0,0,0,0.3)' : 'rgba(0,0,0,0.1)'
                            }
                        }
                    }
                }
            });
        }
        
        function createHErrorChart(matches) {
            const ctx = document.getElementById('hErrorChart');
            if (charts.hError) charts.hError.destroy();
            
            charts.hError = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: matches.map(m => `ID ${m.pointData.ID}`),
                    datasets: [{
                        label: 'Horizontal Error (mm)',
                        data: matches.map(m => m.errors.horizontal * 1000),
                        backgroundColor: 'rgba(244, 67, 54, 0.6)',
                        borderColor: 'rgba(244, 67, 54, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Error (mm)'
                            }
                        }
                    }
                }
            });
        }
        
        function createVErrorChart(matches) {
            const ctx = document.getElementById('vErrorChart');
            if (charts.vError) charts.vError.destroy();
            
            const validMatches = matches.filter(m => m.errors.vertical !== null);
            
            if (validMatches.length === 0) {
                ctx.parentElement.innerHTML = '<p style="padding: 20px; text-align: center; color: #999;">No vertical error data available (known points missing Z coordinates)</p>';
                return;
            }
            
            charts.vError = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: validMatches.map(m => `ID ${m.pointData.ID}`),
                    datasets: [{
                        label: 'Vertical Error (mm)',
                        data: validMatches.map(m => m.errors.vertical * 1000),
                        backgroundColor: validMatches.map(m => 
                            m.errors.vertical > 0 ? 'rgba(255, 152, 0, 0.6)' : 'rgba(33, 150, 243, 0.6)'
                        ),
                        borderColor: validMatches.map(m => 
                            m.errors.vertical > 0 ? 'rgba(255, 152, 0, 1)' : 'rgba(33, 150, 243, 1)'
                        ),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Error (mm) - positive = GPS too high'
                            },
                            grid: {
                                color: (context) => context.tick.value === 0 ? 'rgba(0,0,0,0.3)' : 'rgba(0,0,0,0.1)'
                            }
                        }
                    }
                }
            });
        }
        
        function createErrorVsAccuracyChart(matches) {
            const ctx = document.getElementById('errorVsAccuracyChart');
            if (charts.errorVsAccuracy) charts.errorVsAccuracy.destroy();
            
            charts.errorVsAccuracy = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Horizontal',
                            data: matches.map(m => ({
                                x: parseFloat(m.pointData['Horizontal Accuracy']) * 1000,
                                y: m.errors.horizontal * 1000,
                                id: m.pointData.ID
                            })),
                            backgroundColor: 'rgba(33, 150, 243, 0.6)',
                            borderColor: 'rgba(33, 150, 243, 1)',
                            pointRadius: 6
                        },
                        {
                            label: '1:1 Line',
                            data: [
                                { x: 0, y: 0 },
                                { x: 100, y: 100 }
                            ],
                            borderColor: 'rgba(0, 0, 0, 0.3)',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            showLine: true,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const point = context.raw;
                                    if (point.id) {
                                        return [
                                            `GPS ID: ${point.id}`,
                                            `Reported: ${point.x.toFixed(1)} mm`,
                                            `Actual: ${point.y.toFixed(1)} mm`
                                        ];
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Reported Accuracy (mm)'
                            },
                            beginAtZero: true
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Actual Error (mm)'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }
        
        function createAccuracyChart(data) {
            const ctx = document.getElementById('accuracyChart');
            if (charts.accuracy) charts.accuracy.destroy();
            
            charts.accuracy = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(d => `ID ${d.ID}`),
                    datasets: [{
                        label: 'Horizontal Accuracy (mm)',
                        data: data.map(d => parseFloat(d['Horizontal Accuracy']) * 1000),
                        backgroundColor: 'rgba(54, 162, 235, 0.6)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Accuracy (mm)'
                            }
                        }
                    }
                }
            });
        }
        
        function createVAccuracyChart(data) {
            const ctx = document.getElementById('vAccuracyChart');
            if (charts.vAccuracy) charts.vAccuracy.destroy();
            
            charts.vAccuracy = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(d => `ID ${d.ID}`),
                    datasets: [{
                        label: 'Vertical Accuracy (mm)',
                        data: data.map(d => parseFloat(d['Vertical Accuracy']) * 1000),
                        backgroundColor: 'rgba(255, 99, 132, 0.6)',
                        borderColor: 'rgba(255, 99, 132, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Accuracy (mm)'
                            }
                        }
                    }
                }
            });
        }
        
        function createDOPChart(data) {
            const ctx = document.getElementById('dopChart');
            if (charts.dop) charts.dop.destroy();
            
            charts.dop = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.map(d => `ID ${d.ID}`),
                    datasets: [
                        {
                            label: 'PDOP',
                            data: data.map(d => parseFloat(d.PDOP)),
                            borderColor: 'rgb(255, 99, 132)',
                            backgroundColor: 'rgba(255, 99, 132, 0.1)',
                            tension: 0.1
                        },
                        {
                            label: 'HDOP',
                            data: data.map(d => parseFloat(d.HDOP)),
                            borderColor: 'rgb(54, 162, 235)',
                            backgroundColor: 'rgba(54, 162, 235, 0.1)',
                            tension: 0.1
                        },
                        {
                            label: 'VDOP',
                            data: data.map(d => parseFloat(d.VDOP)),
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.1)',
                            tension: 0.1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'DOP Value'
                            }
                        }
                    }
                }
            });
        }
        
        function createSatChart(data) {
            const ctx = document.getElementById('satChart');
            if (charts.sat) charts.sat.destroy();
            
            charts.sat = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(d => `ID ${d.ID}`),
                    datasets: [
                        {
                            label: 'Satellites in View',
                            data: data.map(d => parseInt(d['Satellites in View'])),
                            backgroundColor: 'rgba(153, 102, 255, 0.6)',
                            borderColor: 'rgba(153, 102, 255, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Satellites in Use',
                            data: data.map(d => parseInt(d['Satellites in Use'])),
                            backgroundColor: 'rgba(255, 159, 64, 0.6)',
                            borderColor: 'rgba(255, 159, 64, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Satellites'
                            }
                        }
                    }
                }
            });
        }
        
        function createElevChart(data) {
            const ctx = document.getElementById('elevChart');
            if (charts.elev) charts.elev.destroy();
            
            charts.elev = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.map(d => `ID ${d.ID}`),
                    datasets: [{
                        label: 'Elevation (m)',
                        data: data.map(d => parseFloat(d.Elevation)),
                        borderColor: 'rgb(75, 192, 192)',
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        tension: 0.1,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Elevation (m)'
                            }
                        }
                    }
                }
            });
        }
        
        function generateColors(count) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                const hue = (i * 137.508) % 360;
                colors.push(`hsla(${hue}, 70%, 50%, 0.8)`);
            }
            return colors;
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            updateKnownPointsList();
            updateFilterStatus();
            console.log('GPS Data Analyzer initialized');
        });
    </script>
</body>
</html>