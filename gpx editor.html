<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPX File Reader & Manager</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            color: white;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .subtitle {
            color: rgba(255,255,255,0.9);
            font-size: 1.1rem;
        }

        .upload-area {
            background: white;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .upload-area:hover {
            transform: translateY(-2px);
        }

        .upload-box {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 60px 40px;
            position: relative;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, rgba(102,126,234,0.05) 0%, rgba(118,75,162,0.05) 100%);
        }

        .upload-box.dragover {
            border-color: #764ba2;
            background: rgba(102,126,234,0.1);
        }

        .upload-icon {
            font-size: 3rem;
            color: #667eea;
            margin-bottom: 20px;
        }

        input[type="file"] {
            display: none;
        }

        .upload-label {
            display: inline-block;
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            margin-top: 10px;
        }

        .upload-label:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 20px rgba(102,126,234,0.3);
        }

        .controls {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            display: none;
        }

        .controls.active {
            display: block;
        }

        .control-row {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 15px;
        }

        .selection-info {
            background: #f0f7ff;
            padding: 10px 15px;
            border-radius: 8px;
            color: #667eea;
            font-weight: 600;
            flex: 1;
            min-width: 200px;
        }

        .sort-select, .filter-input, .btn {
            padding: 10px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .sort-select:focus, .filter-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102,126,234,0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn.secondary {
            background: #f5f5f5;
            color: #333;
        }

        .btn.success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }

        .btn.danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }

        .stats {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            display: none;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .stats.active {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }

        .stat-item {
            flex: 1;
            min-width: 150px;
        }

        .stat-label {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
        }

        .data-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            display: none;
            overflow-x: auto;
        }

        .data-container.active {
            display: block;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            cursor: pointer;
            user-select: none;
        }

        th:first-child {
            width: 50px;
            text-align: center;
        }

        th:hover:not(:first-child) {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        th.sorted-asc::after {
            content: ' ‚Üë';
        }

        th.sorted-desc::after {
            content: ' ‚Üì';
        }

        td {
            padding: 15px;
            border-bottom: 1px solid #f0f0f0;
        }

        td:first-child {
            text-align: center;
        }

        tr:hover {
            background: rgba(102,126,234,0.05);
        }

        tr.selected {
            background: rgba(102,126,234,0.1);
        }

        .checkbox-wrapper {
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #667eea;
        }

        .type-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .type-track {
            background: #e3f2fd;
            color: #1976d2;
        }

        .type-waypoint {
            background: #f3e5f5;
            color: #7b1fa2;
        }

        .type-route {
            background: #e8f5e9;
            color: #388e3c;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #999;
        }

        .empty-state-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        .export-menu {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        @media (max-width: 768px) {
            .control-row {
                flex-direction: column;
            }

            .control-row > * {
                width: 100%;
            }

            .export-menu {
                flex-direction: column;
                width: 100%;
            }

            .export-menu > * {
                width: 100%;
            }

            table {
                font-size: 0.9rem;
            }

            th, td {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üó∫Ô∏è GPX File Reader</h1>
            <p class="subtitle">Upload, manage, and export your GPS tracks, routes, and waypoints</p>
        </div>

        <div class="upload-area">
            <div class="upload-box" id="uploadBox">
                <div class="upload-icon">üìÅ</div>
                <h2>Upload GPX Files</h2>
                <p style="color: #666; margin: 10px 0;">Drag and drop files here or click to browse</p>
                <label for="fileInput" class="upload-label">Choose Files</label>
                <input type="file" id="fileInput" accept=".gpx" multiple>
            </div>
        </div>

        <div class="stats" id="stats">
            <div class="stat-item">
                <div class="stat-label">Total Files</div>
                <div class="stat-value" id="totalFiles">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Total Tracks</div>
                <div class="stat-value" id="totalTracks">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Total Waypoints</div>
                <div class="stat-value" id="totalWaypoints">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Total Distance</div>
                <div class="stat-value" id="totalDistance">0 km</div>
            </div>
        </div>

        <div class="controls" id="controls">
            <div class="control-row">
                <div class="selection-info" id="selectionInfo">
                    <span id="selectedCount">0</span> items selected
                </div>
                <button class="btn secondary" id="selectAllBtn">Select All</button>
                <button class="btn secondary" id="deselectAllBtn">Deselect All</button>
            </div>
            <div class="control-row">
                <select class="sort-select" id="sortSelect">
                    <option value="date-desc">Date (Newest First)</option>
                    <option value="date-asc">Date (Oldest First)</option>
                    <option value="name-asc">Name (A-Z)</option>
                    <option value="name-desc">Name (Z-A)</option>
                    <option value="distance-desc">Distance (Longest First)</option>
                    <option value="distance-asc">Distance (Shortest First)</option>
                    <option value="elevation-desc">Elevation (Highest First)</option>
                    <option value="elevation-asc">Elevation (Lowest First)</option>
                </select>
                <input type="text" class="filter-input" id="filterInput" placeholder="Filter by name...">
            </div>
            <div class="control-row">
                <div class="export-menu">
                    <button class="btn success" id="exportGpxBtn" disabled>Export Selected as GPX</button>
                    <button class="btn" id="exportCsvBtn">Export All as CSV</button>
                    <button class="btn danger" id="clearBtn">Clear All</button>
                </div>
            </div>
        </div>

        <div class="data-container" id="dataContainer">
            <table id="dataTable">
                <thead>
                    <tr>
                        <th>
                            <div class="checkbox-wrapper">
                                <input type="checkbox" id="selectAllCheckbox">
                            </div>
                        </th>
                        <th data-sort="type">Type</th>
                        <th data-sort="name">Name</th>
                        <th data-sort="date">Date</th>
                        <th data-sort="distance">Distance</th>
                        <th data-sort="elevation">Max Elevation</th>
                        <th data-sort="points">Points</th>
                        <th data-sort="file">File</th>
                    </tr>
                </thead>
                <tbody id="dataBody">
                    <tr>
                        <td colspan="8" class="empty-state">
                            <div class="empty-state-icon">üìç</div>
                            <p>No GPX data loaded yet</p>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        let gpxData = [];
        let currentSort = { field: 'date', direction: 'desc' };
        let selectedItems = new Set();

        // File handling
        const fileInput = document.getElementById('fileInput');
        const uploadBox = document.getElementById('uploadBox');
        const dataContainer = document.getElementById('dataContainer');
        const dataBody = document.getElementById('dataBody');
        const controls = document.getElementById('controls');
        const stats = document.getElementById('stats');

        // Drag and drop
        uploadBox.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadBox.classList.add('dragover');
        });

        uploadBox.addEventListener('dragleave', () => {
            uploadBox.classList.remove('dragover');
        });

        uploadBox.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadBox.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });

        // Handle file upload
        function handleFiles(files) {
            Array.from(files).forEach(file => {
                if (file.name.toLowerCase().endsWith('.gpx')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        parseGPX(e.target.result, file.name);
                    };
                    reader.readAsText(file);
                }
            });
        }

        // Parse GPX XML
        function parseGPX(xmlString, fileName) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, 'text/xml');

            // Parse tracks
            const tracks = xmlDoc.getElementsByTagName('trk');
            Array.from(tracks).forEach(track => {
                const name = track.getElementsByTagName('name')[0]?.textContent || 'Unnamed Track';
                const desc = track.getElementsByTagName('desc')[0]?.textContent || '';
                const tracksegs = track.getElementsByTagName('trkseg');
                
                Array.from(tracksegs).forEach((seg, index) => {
                    const points = seg.getElementsByTagName('trkpt');
                    if (points.length > 0) {
                        const pointsArray = Array.from(points).map(p => ({
                            lat: parseFloat(p.getAttribute('lat')),
                            lon: parseFloat(p.getAttribute('lon')),
                            ele: p.getElementsByTagName('ele')[0]?.textContent || null,
                            time: p.getElementsByTagName('time')[0]?.textContent || null
                        }));

                        const firstPoint = points[0];
                        const lastPoint = points[points.length - 1];
                        const time = firstPoint.getElementsByTagName('time')[0]?.textContent || 
                                   lastPoint.getElementsByTagName('time')[0]?.textContent || 
                                   new Date().toISOString();
                        
                        const elevations = pointsArray.map(p => p.ele ? parseFloat(p.ele) : 0);
                        const distance = calculateTrackDistance(points);

                        gpxData.push({
                            id: `track_${Date.now()}_${Math.random()}`,
                            type: 'track',
                            name: index > 0 ? `${name} (Segment ${index + 1})` : name,
                            description: desc,
                            date: new Date(time),
                            distance: distance,
                            elevation: Math.max(...elevations),
                            points: points.length,
                            file: fileName,
                            gpxData: pointsArray,
                            originalXml: track
                        });
                    }
                });
            });

            // Parse waypoints
            const waypoints = xmlDoc.getElementsByTagName('wpt');
            Array.from(waypoints).forEach(wpt => {
                const name = wpt.getElementsByTagName('name')[0]?.textContent || 'Unnamed Waypoint';
                const desc = wpt.getElementsByTagName('desc')[0]?.textContent || '';
                const time = wpt.getElementsByTagName('time')[0]?.textContent || new Date().toISOString();
                const ele = wpt.getElementsByTagName('ele')[0];
                
                gpxData.push({
                    id: `wpt_${Date.now()}_${Math.random()}`,
                    type: 'waypoint',
                    name: name,
                    description: desc,
                    date: new Date(time),
                    distance: 0,
                    elevation: ele ? parseFloat(ele.textContent) : 0,
                    points: 1,
                    file: fileName,
                    gpxData: {
                        lat: parseFloat(wpt.getAttribute('lat')),
                        lon: parseFloat(wpt.getAttribute('lon')),
                        ele: ele?.textContent || null,
                        time: time,
                        sym: wpt.getElementsByTagName('sym')[0]?.textContent || null
                    },
                    originalXml: wpt
                });
            });

            // Parse routes
            const routes = xmlDoc.getElementsByTagName('rte');
            Array.from(routes).forEach(route => {
                const name = route.getElementsByTagName('name')[0]?.textContent || 'Unnamed Route';
                const desc = route.getElementsByTagName('desc')[0]?.textContent || '';
                const routepoints = route.getElementsByTagName('rtept');
                
                if (routepoints.length > 0) {
                    const pointsArray = Array.from(routepoints).map(p => ({
                        lat: parseFloat(p.getAttribute('lat')),
                        lon: parseFloat(p.getAttribute('lon')),
                        ele: p.getElementsByTagName('ele')[0]?.textContent || null,
                        time: p.getElementsByTagName('time')[0]?.textContent || null,
                        name: p.getElementsByTagName('name')[0]?.textContent || null
                    }));

                    const firstPoint = routepoints[0];
                    const time = firstPoint.getElementsByTagName('time')[0]?.textContent || new Date().toISOString();
                    
                    const elevations = pointsArray.map(p => p.ele ? parseFloat(p.ele) : 0);
                    const distance = calculateRouteDistance(routepoints);

                    gpxData.push({
                        id: `route_${Date.now()}_${Math.random()}`,
                        type: 'route',
                        name: name,
                        description: desc,
                        date: new Date(time),
                        distance: distance,
                        elevation: Math.max(...elevations),
                        points: routepoints.length,
                        file: fileName,
                        gpxData: pointsArray,
                        originalXml: route
                    });
                }
            });

            updateDisplay();
        }

        // Calculate distance between points
        function calculateTrackDistance(points) {
            let totalDistance = 0;
            for (let i = 1; i < points.length; i++) {
                const lat1 = parseFloat(points[i-1].getAttribute('lat'));
                const lon1 = parseFloat(points[i-1].getAttribute('lon'));
                const lat2 = parseFloat(points[i].getAttribute('lat'));
                const lon2 = parseFloat(points[i].getAttribute('lon'));
                totalDistance += haversineDistance(lat1, lon1, lat2, lon2);
            }
            return totalDistance;
        }

        function calculateRouteDistance(points) {
            let totalDistance = 0;
            for (let i = 1; i < points.length; i++) {
                const lat1 = parseFloat(points[i-1].getAttribute('lat'));
                const lon1 = parseFloat(points[i-1].getAttribute('lon'));
                const lat2 = parseFloat(points[i].getAttribute('lat'));
                const lon2 = parseFloat(points[i].getAttribute('lon'));
                totalDistance += haversineDistance(lat1, lon1, lat2, lon2);
            }
            return totalDistance;
        }

        // Haversine formula for distance calculation
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in kilometers
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Update display
        function updateDisplay() {
            if (gpxData.length > 0) {
                dataContainer.classList.add('active');
                controls.classList.add('active');
                stats.classList.add('active');
                updateStats();
                sortData();
                renderTable();
            }
        }

        // Update statistics
        function updateStats() {
            const files = new Set(gpxData.map(d => d.file)).size;
            const tracks = gpxData.filter(d => d.type === 'track').length;
            const waypoints = gpxData.filter(d => d.type === 'waypoint').length;
            const totalDist = gpxData.reduce((sum, d) => sum + d.distance, 0);

            document.getElementById('totalFiles').textContent = files;
            document.getElementById('totalTracks').textContent = tracks;
            document.getElementById('totalWaypoints').textContent = waypoints;
            document.getElementById('totalDistance').textContent = totalDist.toFixed(2) + ' km';
        }

        // Sort data
        function sortData() {
            const [field, direction] = document.getElementById('sortSelect').value.split('-');
            
            gpxData.sort((a, b) => {
                let aVal = a[field];
                let bVal = b[field];
                
                if (field === 'date') {
                    aVal = aVal.getTime();
                    bVal = bVal.getTime();
                } else if (field === 'name' || field === 'type' || field === 'file') {
                    aVal = aVal.toLowerCase();
                    bVal = bVal.toLowerCase();
                }
                
                if (direction === 'asc') {
                    return aVal > bVal ? 1 : -1;
                } else {
                    return aVal < bVal ? 1 : -1;
                }
            });
        }

        // Render table
        function renderTable() {
            const filter = document.getElementById('filterInput').value.toLowerCase();
            const filteredData = gpxData.filter(item => 
                item.name.toLowerCase().includes(filter) ||
                item.file.toLowerCase().includes(filter)
            );

            if (filteredData.length === 0) {
                dataBody.innerHTML = `
                    <tr>
                        <td colspan="8" class="empty-state">
                            <div class="empty-state-icon">üîç</div>
                            <p>No matching data found</p>
                        </td>
                    </tr>
                `;
                return;
            }

            dataBody.innerHTML = filteredData.map(item => `
                <tr class="${selectedItems.has(item.id) ? 'selected' : ''}" data-id="${item.id}">
                    <td>
                        <div class="checkbox-wrapper">
                            <input type="checkbox" class="item-checkbox" data-id="${item.id}" 
                                ${selectedItems.has(item.id) ? 'checked' : ''}>
                        </div>
                    </td>
                    <td><span class="type-badge type-${item.type}">${item.type}</span></td>
                    <td><strong>${item.name}</strong></td>
                    <td>${item.date.toLocaleDateString()} ${item.date.toLocaleTimeString()}</td>
                    <td>${item.distance.toFixed(2)} km</td>
                    <td>${item.elevation.toFixed(0)} m</td>
                    <td>${item.points}</td>
                    <td>${item.file}</td>
                </tr>
            `).join('');

            // Add checkbox event listeners
            document.querySelectorAll('.item-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', handleCheckboxChange);
            });

            updateSelectionInfo();
        }

        // Handle checkbox changes
        function handleCheckboxChange(e) {
            const id = e.target.getAttribute('data-id');
            const row = e.target.closest('tr');
            
            if (e.target.checked) {
                selectedItems.add(id);
                row.classList.add('selected');
            } else {
                selectedItems.delete(id);
                row.classList.remove('selected');
            }
            
            updateSelectionInfo();
            updateSelectAllCheckbox();
        }

        // Update selection info
        function updateSelectionInfo() {
            const count = selectedItems.size;
            document.getElementById('selectedCount').textContent = count;
            document.getElementById('exportGpxBtn').disabled = count === 0;
        }

        // Update select all checkbox state
        function updateSelectAllCheckbox() {
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            const visibleCheckboxes = document.querySelectorAll('.item-checkbox');
            const checkedCount = document.querySelectorAll('.item-checkbox:checked').length;
            
            selectAllCheckbox.checked = visibleCheckboxes.length > 0 && checkedCount === visibleCheckboxes.length;
            selectAllCheckbox.indeterminate = checkedCount > 0 && checkedCount < visibleCheckboxes.length;
        }

        // Select all checkbox
        document.getElementById('selectAllCheckbox').addEventListener('change', (e) => {
            const checkboxes = document.querySelectorAll('.item-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = e.target.checked;
                const id = checkbox.getAttribute('data-id');
                const row = checkbox.closest('tr');
                
                if (e.target.checked) {
                    selectedItems.add(id);
                    row.classList.add('selected');
                } else {
                    selectedItems.delete(id);
                    row.classList.remove('selected');
                }
            });
            updateSelectionInfo();
        });

        // Select all button
        document.getElementById('selectAllBtn').addEventListener('click', () => {
            gpxData.forEach(item => selectedItems.add(item.id));
            renderTable();
        });

        // Deselect all button
        document.getElementById('deselectAllBtn').addEventListener('click', () => {
            selectedItems.clear();
            renderTable();
        });

        // Export selected as GPX
        document.getElementById('exportGpxBtn').addEventListener('click', () => {
            const selectedData = gpxData.filter(item => selectedItems.has(item.id));
            if (selectedData.length === 0) return;

            const gpxContent = generateGPX(selectedData);
            const blob = new Blob([gpxContent], { type: 'application/gpx+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `exported_${new Date().toISOString().split('T')[0]}.gpx`;
            a.click();
            URL.revokeObjectURL(url);
        });

        // Generate GPX XML
        function generateGPX(items) {
            let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GPX File Reader"
    xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd"
    xmlns="http://www.topografix.com/GPX/1/1"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <metadata>
        <name>Exported GPX</name>
        <time>${new Date().toISOString()}</time>
    </metadata>\n`;

            // Add waypoints
            items.filter(item => item.type === 'waypoint').forEach(item => {
                const data = item.gpxData;
                gpx += `    <wpt lat="${data.lat}" lon="${data.lon}">
        <name>${escapeXml(item.name)}</name>`;
                if (data.ele) gpx += `\n        <ele>${data.ele}</ele>`;
                if (data.time) gpx += `\n        <time>${data.time}</time>`;
                if (item.description) gpx += `\n        <desc>${escapeXml(item.description)}</desc>`;
                if (data.sym) gpx += `\n        <sym>${escapeXml(data.sym)}</sym>`;
                gpx += `\n    </wpt>\n`;
            });

            // Add routes
            items.filter(item => item.type === 'route').forEach(item => {
                gpx += `    <rte>
        <name>${escapeXml(item.name)}</name>`;
                if (item.description) gpx += `\n        <desc>${escapeXml(item.description)}</desc>`;
                
                item.gpxData.forEach(point => {
                    gpx += `\n        <rtept lat="${point.lat}" lon="${point.lon}">`;
                    if (point.ele) gpx += `\n            <ele>${point.ele}</ele>`;
                    if (point.time) gpx += `\n            <time>${point.time}</time>`;
                    if (point.name) gpx += `\n            <name>${escapeXml(point.name)}</name>`;
                    gpx += `\n        </rtept>`;
                });
                gpx += `\n    </rte>\n`;
            });

            // Add tracks
            items.filter(item => item.type === 'track').forEach(item => {
                gpx += `    <trk>
        <name>${escapeXml(item.name)}</name>`;
                if (item.description) gpx += `\n        <desc>${escapeXml(item.description)}</desc>`;
                gpx += `\n        <trkseg>`;
                
                item.gpxData.forEach(point => {
                    gpx += `\n            <trkpt lat="${point.lat}" lon="${point.lon}">`;
                    if (point.ele) gpx += `\n                <ele>${point.ele}</ele>`;
                    if (point.time) gpx += `\n                <time>${point.time}</time>`;
                    gpx += `\n            </trkpt>`;
                });
                gpx += `\n        </trkseg>\n    </trk>\n`;
            });

            gpx += `</gpx>`;
            return gpx;
        }

        // Escape XML special characters
        function escapeXml(text) {
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        // Table header sorting
        document.querySelectorAll('th[data-sort]').forEach(th => {
            th.addEventListener('click', () => {
                const field = th.getAttribute('data-sort');
                const sortSelect = document.getElementById('sortSelect');
                
                // Toggle direction if same field
                if (currentSort.field === field) {
                    currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    currentSort.field = field;
                    currentSort.direction = 'asc';
                }
                
                // Update select to match
                const optionValue = `${field}-${currentSort.direction}`;
                if ([...sortSelect.options].some(opt => opt.value === optionValue)) {
                    sortSelect.value = optionValue;
                }
                
                // Update header classes
                document.querySelectorAll('th').forEach(header => {
                    header.classList.remove('sorted-asc', 'sorted-desc');
                });
                th.classList.add(`sorted-${currentSort.direction}`);
                
                sortData();
                renderTable();
            });
        });

        // Event listeners
        document.getElementById('sortSelect').addEventListener('change', () => {
            updateDisplay();
        });

        document.getElementById('filterInput').addEventListener('input', () => {
            renderTable();
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all data?')) {
                gpxData = [];
                selectedItems.clear();
                dataContainer.classList.remove('active');
                controls.classList.remove('active');
                stats.classList.remove('active');
                fileInput.value = '';
            }
        });

        document.getElementById('exportCsvBtn').addEventListener('click', () => {
            const csvContent = [
                ['Type', 'Name', 'Date', 'Distance (km)', 'Elevation (m)', 'Points', 'File'],
                ...gpxData.map(item => [
                    item.type,
                    item.name,
                    item.date.toISOString(),
                    item.distance.toFixed(2),
                    item.elevation.toFixed(0),
                    item.points,
                    item.file
                ])
            ].map(row => row.join(',')).join('\n');

            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `gpx_data_${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        });
    </script>
</body>
</html>