<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive Borehole Visualizer - 3D, Isopach & Cross Sections</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #f5f5f5; padding: 20px; }
        .container { max-width: 1800px; margin: 0 auto; background: white; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); overflow: hidden; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; text-align: center; }
        .content { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; padding: 20px; }
        .input-section, .map-section { background: #f8f9fa; padding: 20px; border-radius: 8px; }
        .cross-section { grid-column: 1 / -1; background: #f8f9fa; padding: 20px; border-radius: 8px; margin-top: 20px; }
        textarea { width: 100%; height: 300px; padding: 10px; border: 2px solid #ddd; border-radius: 5px; font-family: monospace; font-size: 12px; resize: vertical; }
        button { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 14px; margin: 10px 5px 0 0; transition: transform 0.2s; }
        button:hover { transform: translateY(-2px); }
        button:disabled { background: #ccc; cursor: not-allowed; transform: none; }
        button.nav-btn { background: linear-gradient(135deg, #ffc107 0%, #ff8c00 100%); font-size: 18px; padding: 8px 15px; }
        button.export-btn { background: linear-gradient(135deg, #28a745 0%, #20c997 100%); }
        #map, #isopachMap { height: 400px; width: 100%; border-radius: 5px; border: 2px solid #ddd; }
        #threeContainer { height: 600px; width: 100%; border: 2px solid #ddd; border-radius: 5px; }
        .section-title { font-size: 18px; font-weight: bold; margin-bottom: 15px; color: #333; }
        .time-controls { background: white; padding: 15px; border-radius: 5px; margin-top: 10px; border: 1px solid #ddd; display: flex; align-items: center; gap: 15px; justify-content: center; flex-wrap: wrap; }
        .time-display { font-size: 18px; font-weight: bold; color: #333; min-width: 150px; text-align: center; }
        .date-display { font-size: 14px; color: #666; min-width: 120px; text-align: center; }
        .info-panel { background: white; padding: 15px; border-radius: 5px; margin-top: 10px; border: 1px solid #ddd; }
        .kriging-controls { background: white; padding: 10px; border-radius: 5px; margin-top: 10px; border: 1px solid #ddd; }
        .kriging-controls label { display: block; margin: 8px 0; font-size: 13px; }
        .isopach-legend { background: white; padding: 10px; border-radius: 5px; margin-top: 10px; border: 1px solid #ddd; }
        .isopach-gradient { height: 20px; width: 100%; border-radius: 3px; margin: 5px 0; }
        .isopach-labels { display: flex; justify-content: space-between; font-size: 11px; color: #666; }
        .three-controls { background: white; padding: 10px; border-radius: 5px; margin-top: 10px; border: 1px solid #ddd; text-align: center; font-size: 11px; color: #666; }
        .view-btn { background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 3px 2px; }
        .visualization-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px; }
        .viz-panel { background: white; padding: 15px; border-radius: 8px; border: 2px solid #28a745; }
        .date-input-box { margin-bottom: 10px; padding: 10px; background: white; border-radius: 5px; border: 1px solid #ddd; }
        .date-input-box label { font-weight: bold; font-size: 13px; display: block; margin-bottom: 5px; }
        .date-input-box input { padding: 5px; border: 2px solid #ddd; border-radius: 4px; font-size: 13px; width: 100%; }
        
        /* Cross-section styles */
        .sections-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-top: 20px; }
        .section-panel { background: white; padding: 15px; border-radius: 8px; border: 2px solid #ddd; position: relative; cursor: move; transition: box-shadow 0.2s; }
        .section-panel:hover { box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); }
        .section-panel.dragging { opacity: 0.5; cursor: grabbing; }
        .section-panel.drag-over { border-style: dashed; background: #f0f0f0; }
        .section-panel.section-1 { border-color: #ff6600; }
        .section-panel.section-2 { border-color: #0066cc; }
        .section-panel.section-3 { border-color: #28a745; }
        .section-panel.section-4 { border-color: #dc3545; }
        .section-panel.section-5 { border-color: #6f42c1; }
        .section-panel.section-6 { border-color: #fd7e14; }
        .section-panel.section-7 { border-color: #20c997; }
        .section-panel.section-8 { border-color: #e83e8c; }
        
        .section-close-btn { position: absolute; top: 10px; right: 10px; background: #dc3545; color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; font-size: 16px; line-height: 1; padding: 0; }
        .section-close-btn:hover { background: #c82333; }
        
        .cross-section-canvas { width: 100%; height: 400px; border: 2px solid #ddd; border-radius: 5px; }
        
        .section-subtitle { font-size: 16px; font-weight: bold; margin-bottom: 10px; padding: 8px; border-radius: 5px; }
        .section-subtitle.section-1 { background: #fff3e0; color: #ff6600; }
        .section-subtitle.section-2 { background: #e3f2fd; color: #0066cc; }
        .section-subtitle.section-3 { background: #e8f5e9; color: #28a745; }
        .section-subtitle.section-4 { background: #ffebee; color: #dc3545; }
        .section-subtitle.section-5 { background: #f3e5f5; color: #6f42c1; }
        .section-subtitle.section-6 { background: #fff3e0; color: #fd7e14; }
        .section-subtitle.section-7 { background: #e0f2f1; color: #20c997; }
        .section-subtitle.section-8 { background: #fce4ec; color: #e83e8c; }
        
        .data-visibility-controls { background: #f8f9fa; padding: 10px; border-radius: 5px; margin-top: 10px; max-height: 200px; overflow-y: auto; }
        .data-row-item { display: flex; align-items: center; gap: 8px; padding: 5px; margin: 3px 0; background: white; border-radius: 3px; border: 1px solid #ddd; }
        .data-row-item input[type="checkbox"] { cursor: pointer; }
        .data-row-item label { cursor: pointer; flex: 1; font-size: 13px; }
        
        .legend { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; }
        .legend-item { display: flex; align-items: center; gap: 5px; padding: 5px 10px; background: white; border-radius: 5px; border: 1px solid #ddd; }
        .color-picker { width: 20px; height: 20px; border: none; border-radius: 3px; cursor: pointer; }
        
        .controls { display: flex; gap: 10px; margin-top: 10px; align-items: center; flex-wrap: wrap; }
        
        .groundwater-legend { background: #e8f4fd; padding: 10px; border-radius: 5px; margin-top: 10px; border-left: 4px solid #0066cc; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Comprehensive Borehole Groundwater Visualizer</h1>
            <p>3D View, Kriging Isopach Mapping & Cross Sections - Use Arrow Keys to Navigate Days</p>
        </div>
        <div class="content">
            <div class="input-section">
                <div class="section-title">Data Input</div>
                <div class="date-input-box">
                    <label for="startDate">Start Date (Day 1):</label>
                    <input type="date" id="startDate">
                </div>
                <textarea id="dataInput" placeholder="Paste borehole data...
Format: name Easting Northing GroundLevel depth depthToGW U1 d1 U2 d2 U3 d3 day1_GW day2_GW..."></textarea>
                <button onclick="parseData()">Parse Data</button>
                <button onclick="loadSampleData()">Load Sample</button>
                <button onclick="clearData()">Clear</button>
                <div class="info-panel"><div id="dataInfo">No data loaded</div></div>
                <div class="info-panel" style="max-height: 200px; overflow-y: auto;">
                    <div style="font-weight: bold; margin-bottom: 8px; font-size: 12px;">Soil Colors (click to edit)</div>
                    <div id="soilColorPalette" style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; font-size: 11px;"></div>
                </div>
            </div>
            <div class="map-section">
                <div class="section-title">Borehole Map</div>
                <div id="map"></div>
                <div class="controls">
                    <div id="sectionLineControls" style="display: flex; flex-wrap: wrap; gap: 10px;"></div>
                </div>
                <div class="info-panel" style="font-size: 12px; color: #666;">
                    <strong>Keyboard Navigation:</strong> Use ‚Üê ‚Üí arrow keys to navigate between days
                </div>
            </div>
        </div>
        
        <div class="cross-section">
            <div class="section-title">Time Controls</div>
            <div class="time-controls">
                <button class="nav-btn" id="prevBtn" onclick="previousDay()">‚óÄ</button>
                <div>
                    <div class="time-display" id="timeDisplay">Day 1</div>
                    <div class="date-display" id="dateDisplay">-</div>
                </div>
                <button class="nav-btn" id="nextBtn" onclick="nextDay()">‚ñ∂</button>
                <div style="margin-left: 20px;">
                    <label for="daySlider">Jump to Day:</label>
                    <input type="range" id="daySlider" min="1" max="1" value="1" onchange="jumpToDay(this.value)">
                    <span id="sliderValue">1</span>
                </div>
                <div style="margin-left: 20px;">
                    <button class="export-btn" onclick="exportAllDaysHTML()" style="padding: 10px 20px;">üìÑ Export All Days (Print‚ÜíPDF)</button>
                    <button class="export-btn" onclick="exportSplitHTML()" style="padding: 10px 20px; background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);">üìö Export Split (50 days each)</button>
                </div>
            </div>
            <div id="exportProgress" style="text-align: center; margin-top: 10px; min-height: 20px; font-weight: bold; color: #28a745;"></div>
        </div>
    </div>

    <div class="cross-section">
        <div class="visualization-grid">
            <div class="viz-panel">
                <div style="background: #e8f5e9; color: #28a745; font-weight: bold; padding: 8px; border-radius: 5px; margin-bottom: 10px;">
                    3D View with GW TIN Surface <span id="threeDayIndicator" style="float: right; font-size: 12px;">(Day 1)</span> <span id="threeVEIndicator" style="float: right; font-size: 11px; margin-right: 10px; color: #666;">(VE=1.0x)</span>
                </div>
                <div id="threeContainer"></div>
                <div class="three-controls">
                    <p>Mouse: Left=Pan | Right=Rotate | Scroll=Zoom</p>
                    <button class="view-btn" onclick="resetCamera()">Reset</button>
                    <button class="view-btn" onclick="setTopView()">Top</button>
                    <button class="view-btn" onclick="setSideView()">Side</button>
                    <br>
                    <label style="font-size: 11px;"><input type="checkbox" id="showGWTIN" checked onchange="render3D()"> GW TIN Surface</label>
                    <label style="font-size: 11px;"><input type="checkbox" id="showBoreholes3D" checked onchange="render3D()"> Borehole Columns</label>
                    <label style="font-size: 11px;"><input type="checkbox" id="showGroundPlane" checked onchange="render3D()"> Ground Plane</label>
                    <label style="font-size: 11px;"><input type="checkbox" id="showGroundSurface" onchange="render3D()"> Ground Surface</label>
                    <label style="font-size: 11px;"><input type="checkbox" id="showVisualizationBox" onchange="render3D()"> Visualization Box</label>
                    <label style="font-size: 11px;"><input type="checkbox" id="boxOpaque" onchange="render3D()"> Box Opaque</label>
                    <br>
                    <div style="font-size: 11px; margin-top: 5px;">
                        <label>Box Depth Below: <span id="boxDepthBelowValue">10 m</span></label>
                        <input type="range" id="boxDepthBelow" min="0" max="50" step="1" value="10" style="width: 90%;" oninput="updateBoxDepthBelow(this.value)">
                    </div>
                    <div style="font-size: 11px; margin-top: 5px;">
                        <label>Height Above: <span id="boxHeightAboveValue">5 m</span></label>
                        <input type="range" id="boxHeightAbove" min="0" max="50" step="1" value="5" style="width: 90%;" oninput="updateBoxHeightAbove(this.value)">
                    </div>
                    <div style="font-size: 10px; color: #666; margin-top: 3px;">
                        Click isopach map corners to define box area
                        <button onclick="clearBoxCorners()" style="font-size: 10px; padding: 2px 6px; margin-left: 5px;">Clear Corners</button>
                    </div>
                    <br>
                    <label style="font-size: 11px;">Vertical Exaggeration: <span id="vertExagValue">1.0x</span></label>
                    <input type="range" id="verticalExaggeration" min="0.5" max="20" step="0.5" value="1" style="width: 90%;" oninput="updateVerticalExaggeration(this.value)">
                </div>
            </div>

            <div class="viz-panel" id="isopachMapContainer" style="border-color: #0066cc;">
                <div style="background: #e3f2fd; color: #0066cc; font-weight: bold; padding: 8px; border-radius: 5px; margin-bottom: 10px;">
                    Groundwater Isopach Map (Kriging)
                </div>
                <div id="isopachMap"></div>
                <div class="kriging-controls">
                    <label><input type="checkbox" id="showContours" checked onchange="updateIsopachMap()"> Show Contour Lines</label>
                    <label><input type="checkbox" id="showHeatmap" checked onchange="updateIsopachMap()"> Show Heatmap</label>
                    <label>Contour Interval: <span id="contourIntervalValue">0.2m</span>
                        <input type="range" id="contourInterval" min="0.1" max="2" step="0.1" value="0.2" style="width: 100%;" oninput="updateContourInterval(this.value)">
                    </label>
                    <label>Grid Resolution: <span id="gridResolutionValue">100</span>
                        <input type="range" id="gridResolution" min="40" max="200" step="20" value="100" style="width: 100%;" oninput="updateGridResolution(this.value)">
                    </label>
                    <label>Smoothing: <span id="smoothingValue">Medium</span>
                        <input type="range" id="smoothingFactor" min="1" max="5" step="1" value="3" style="width: 100%;" oninput="updateSmoothing(this.value)">
                    </label>
                    <label>Interpolation Range (m): <span id="interpolationRangeValue">50m</span>
                        <input type="range" id="interpolationRange" min="20" max="200" step="10" value="50" style="width: 100%;" oninput="updateInterpolationRange(this.value)">
                    </label>
                </div>
                <div class="isopach-legend" id="isopachLegend"></div>
            </div>
        </div>
    </div>
    
    <div class="cross-section">
        <div class="section-title">
            Cross Sections
            <button onclick="addNewSection()" style="float: right; margin: 0;">+ Add New Section</button>
        </div>
        
        <div id="sectionsContainer" class="sections-grid"></div>
        
        <div class="legend" id="legend"></div>
        <div class="groundwater-legend">
            <strong>Groundwater Legend:</strong><br>
            Blue solid line = Current day's groundwater level<br>
            Blue dashed line = Previous day's groundwater level (Day 1 shows initial level)
        </div>
    </div>

    <script>
        let boreholeData = [];
        let map = null, isopachMap = null;
        let markers = [];
        let sectionLines = {};
        let currentDay = 1, maxDays = 1;
        let sections = [];
        let nextSectionId = 1;
        let krigingGrid = null;
        let contourInterval = 0.2;
        let smoothingFactor = 3;
        let interpolationRange = 50;
        let gridResolution = 100;
        let globalMinGW = null, globalMaxGW = null;
        let visualizationBoxCorners = [];
        let boxCornerMarkers = [];
        let threeModule = null, threeScene = null, threeCamera = null, threeRenderer = null;
        let cameraRadius = 30, cameraTheta = 0, cameraPhi = Math.PI / 4;
        let cameraTarget = null, verticalExaggeration = 1.0;
        let startDate = null;

        const soilColors = {
            'GC': '#8B6914', 'GP': '#B8956A', 'GW': '#A0826D', 'GM': '#9C7A5E',
            'SAND': '#F4C430', 'SP': '#F4C430', 'SW': '#E8B923', 'SM': '#D4A520', 'SC': '#C19A6B',
            'sandy SAND': '#F4C430', 'clayey SAND': '#C19A6B', 'clayeySAND': '#C19A6B',
            'ML': '#A89968', 'MH': '#8B7355',
            'CLAY': '#A0522D', 'CL': '#A0522D', 'CH': '#8B4513',
            'sandy CLAY': '#B5651D', 'sandyCLAY': '#B5651D',
            'OH': '#556B2F', 'OL': '#6B8E23', 'PT': '#2F4F2F',
            '-': '#999999', 'CORELOSS': '#cccccc', 'coreloss': '#cccccc',
            'FILL': '#8B8680', 'ROCK': '#708090'
        };

        const sectionColors = [
            '#ff6600', '#0066cc', '#28a745', '#dc3545', 
            '#6f42c1', '#fd7e14', '#20c997', '#e83e8c'
        ];

        document.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowLeft') { e.preventDefault(); previousDay(); }
            else if (e.key === 'ArrowRight') { e.preventDefault(); nextDay(); }
        });

        function getDateForDay(day) {
            if (!startDate || day < 1) return '-';
            const date = new Date(startDate);
            date.setDate(date.getDate() + (day - 1));
            return date.toLocaleDateString('en-AU', { 
                day: '2-digit', 
                month: 'short', 
                year: 'numeric' 
            });
        }

        // ===== SECTION MANAGEMENT =====
        function initializeSections() {
            sections = [];
            for (let i = 1; i <= 4; i++) {
                addNewSection();
            }
        }

        function addNewSection() {
            const section = {
                id: nextSectionId++,
                name: `Section ${sections.length + 1}`,
                visibility: {},
                color: sectionColors[sections.length % sectionColors.length]
            };
            
            boreholeData.forEach(bh => {
                const sectionNumber = sections.length + 1;
                
                if (sectionNumber === 1) {
                    section.visibility[bh.name] = (bh.name === 'BH04' || bh.name === 'BH05');
                } else if (sectionNumber === 2) {
                    section.visibility[bh.name] = (bh.name === 'BH01' || bh.name === 'BH02' || bh.name === 'BH03' || bh.name === 'BH04');
                } else if (sectionNumber === 3) {
                    section.visibility[bh.name] = (bh.name === 'BH05' || bh.name === 'BH06');
                } else if (sectionNumber === 4) {
                    section.visibility[bh.name] = (bh.name === 'BH06' || bh.name === 'BH07' || bh.name === 'BH08');
                } else {
                    section.visibility[bh.name] = true;
                }
            });
            
            sections.push(section);
            renderSections();
            updateMapControls();
            
            return section;
        }

        function removeSection(sectionId) {
            const index = sections.findIndex(s => s.id === sectionId);
            if (index !== -1) {
                if (sectionLines[sectionId]) {
                    map.removeLayer(sectionLines[sectionId]);
                    delete sectionLines[sectionId];
                }
                
                sections.splice(index, 1);
                renderSections();
                updateMapControls();
            }
        }

        function renderSections() {
            const container = document.getElementById('sectionsContainer');
            container.innerHTML = '';
            
            sections.forEach((section, idx) => {
                const panel = document.createElement('div');
                panel.className = `section-panel section-${(idx % 8) + 1}`;
                panel.draggable = true;
                panel.dataset.sectionId = section.id;
                
                panel.addEventListener('dragstart', handleDragStart);
                panel.addEventListener('dragover', handleDragOver);
                panel.addEventListener('drop', handleDrop);
                panel.addEventListener('dragend', handleDragEnd);
                panel.addEventListener('dragenter', handleDragEnter);
                panel.addEventListener('dragleave', handleDragLeave);
                
                let htmlContent = '';
                if (sections.length > 1) {
                    htmlContent += `<button class="section-close-btn" onclick="removeSection(${section.id})" title="Remove section">√ó</button>`;
                }
                htmlContent += `
                    <div class="section-subtitle section-${(idx % 8) + 1}">${section.name}</div>
                    <canvas id="crossSection${section.id}" class="cross-section-canvas"></canvas>
                    <div class="controls">
                        <button onclick="generateCrossSection(${section.id})">Generate Section</button>
                        <button class="export-btn" onclick="exportSectionToPNG(${section.id})">Export PNG</button>
                    </div>
                    <div class="data-visibility-controls">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <strong>Show/Hide Boreholes:</strong>
                            <div>
                                <button onclick="showAllBoreholes(${section.id})" style="padding: 4px 8px; font-size: 11px; margin: 0 2px;">Show All</button>
                                <button onclick="hideAllBoreholes(${section.id})" style="padding: 4px 8px; font-size: 11px; margin: 0 2px;">Hide All</button>
                            </div>
                        </div>
                        <div id="dataControls${section.id}"></div>
                    </div>
                `;
                panel.innerHTML = htmlContent;
                container.appendChild(panel);
                
                updateSectionVisibilityControls(section.id);
            });
        }

        // Drag and drop handlers
        let draggedElement = null;
        let draggedSectionId = null;

        function handleDragStart(e) {
            draggedElement = e.target;
            draggedSectionId = parseInt(e.target.dataset.sectionId);
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.innerHTML);
        }

        function handleDragOver(e) {
            if (e.preventDefault) e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDragEnter(e) {
            if (e.target.classList.contains('section-panel')) {
                e.target.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            if (e.target.classList.contains('section-panel')) {
                e.target.classList.remove('drag-over');
            }
        }

        function handleDrop(e) {
            if (e.stopPropagation) e.stopPropagation();
            
            if (draggedElement !== e.target && e.target.classList.contains('section-panel')) {
                const targetSectionId = parseInt(e.target.dataset.sectionId);
                
                const draggedIndex = sections.findIndex(s => s.id === draggedSectionId);
                const targetIndex = sections.findIndex(s => s.id === targetSectionId);
                
                if (draggedIndex !== -1 && targetIndex !== -1) {
                    [sections[draggedIndex], sections[targetIndex]] = [sections[targetIndex], sections[draggedIndex]];
                    
                    renderSections();
                    generateCrossSection(draggedSectionId);
                    generateCrossSection(targetSectionId);
                }
            }
            
            e.target.classList.remove('drag-over');
            return false;
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.section-panel').forEach(panel => {
                panel.classList.remove('drag-over');
            });
        }

        function updateSectionVisibilityControls(sectionId) {
            const section = sections.find(s => s.id === sectionId);
            if (!section) return;
            
            const controlsDiv = document.getElementById(`dataControls${sectionId}`);
            if (!controlsDiv) return;
            
            controlsDiv.innerHTML = '';
            
            boreholeData.forEach(bh => {
                const item = document.createElement('div');
                item.className = 'data-row-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `vis${sectionId}_${bh.name}`;
                checkbox.checked = section.visibility[bh.name];
                checkbox.onchange = () => {
                    section.visibility[bh.name] = checkbox.checked;
                    generateCrossSection(sectionId);
                    updateSectionLine(sectionId);
                };
                
                const label = document.createElement('label');
                label.htmlFor = `vis${sectionId}_${bh.name}`;
                label.textContent = bh.name;
                
                item.appendChild(checkbox);
                item.appendChild(label);
                controlsDiv.appendChild(item);
            });
        }

        function showAllBoreholes(sectionId) {
            const section = sections.find(s => s.id === sectionId);
            if (!section) return;
            
            boreholeData.forEach(bh => {
                section.visibility[bh.name] = true;
            });
            
            updateSectionVisibilityControls(sectionId);
            generateCrossSection(sectionId);
            updateSectionLine(sectionId);
        }

        function hideAllBoreholes(sectionId) {
            const section = sections.find(s => s.id === sectionId);
            if (!section) return;
            
            boreholeData.forEach(bh => {
                section.visibility[bh.name] = false;
            });
            
            updateSectionVisibilityControls(sectionId);
            generateCrossSection(sectionId);
            updateSectionLine(sectionId);
        }

        function updateMapControls() {
            const controlsDiv = document.getElementById('sectionLineControls');
            controlsDiv.innerHTML = '';
            
            sections.forEach((section, idx) => {
                const label = document.createElement('label');
                label.style.color = section.color;
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `showSectionLine${section.id}`;
                checkbox.checked = true;
                checkbox.onchange = () => toggleSectionLine(section.id);
                
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(` Show ${section.name} Line`));
                controlsDiv.appendChild(label);
            });
        }

        // ===== MAP INITIALIZATION =====
        function initMap() {
            map = L.map('map').setView([-31.95, 115.85], 16);
            L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '¬© Esri',
                crossOrigin: 'anonymous'
            }).addTo(map);

            isopachMap = L.map('isopachMap').setView([-31.95, 115.85], 16);
            L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '¬© Esri',
                crossOrigin: 'anonymous'
            }).addTo(isopachMap);
            
            isopachMap.on('click', function(e) {
                if (visualizationBoxCorners.length < 4) {
                    const lat = e.latlng.lat;
                    const lng = e.latlng.lng;
                    const utm = latLngToUtm(lat, lng, 50, 'S');
                    
                    visualizationBoxCorners.push({ lat, lng, easting: utm.easting, northing: utm.northing });
                    
                    const marker = L.circleMarker([lat, lng], {
                        radius: 8,
                        fillColor: '#ff0000',
                        color: '#ffffff',
                        weight: 2,
                        fillOpacity: 0.8
                    }).addTo(isopachMap);
                    
                    marker.bindPopup(`Corner ${visualizationBoxCorners.length}`);
                    boxCornerMarkers.push(marker);
                    
                    if (visualizationBoxCorners.length === 4) {
                        alert('4 corners defined! Enable "Visualization Box" checkbox to see it in 3D.');
                        render3D();
                    }
                } else {
                    alert('4 corners already defined. Clear them first to redefine.');
                }
            });
        }
        
        function clearBoxCorners() {
            visualizationBoxCorners = [];
            boxCornerMarkers.forEach(m => isopachMap.removeLayer(m));
            boxCornerMarkers = [];
            render3D();
        }

        // ===== DATA PARSING =====
        function parseData() {
            const input = document.getElementById('dataInput').value.trim();
            if (!input) { alert('Enter data first'); return; }
            
            const dateInput = document.getElementById('startDate').value;
            if (dateInput) {
                startDate = new Date(dateInput);
            } else {
                startDate = null;
            }
            
            boreholeData = [];
            const lines = input.split('\n');
            maxDays = 1;
            
            for (let line of lines) {
                if (!line.trim()) continue;
                const parts = line.trim().split(/[\s\t]+/);
                if (parts.length < 12) continue;
                
                const bh = {
                    name: parts[0],
                    easting: parseFloat(parts[1]),
                    northing: parseFloat(parts[2]),
                    groundLevel: parseFloat(parts[3]),
                    depth: parseFloat(parts[4]),
                    depthToGW: parseFloat(parts[5]),
                    units: [],
                    gwElevations: []
                };
                
                for (let i = 6; i < 12; i += 2) {
                    if (parts[i] !== '-' && !isNaN(parseFloat(parts[i + 1]))) {
                        bh.units.push({ name: parts[i], depth: parseFloat(parts[i + 1]) });
                    }
                }
                
                for (let i = 12; i < parts.length; i++) {
                    const gw = parseFloat(parts[i]);
                    if (!isNaN(gw)) bh.gwElevations.push(gw);
                }
                
                maxDays = Math.max(maxDays, bh.gwElevations.length);
                
                const ll = utmToLatLng(bh.easting, bh.northing, 50, 'S');
                bh.lat = ll.lat;
                bh.lng = ll.lng;
                
                boreholeData.push(bh);
            }

            currentDay = 1;
            
            if (sections.length === 0) {
                initializeSections();
            }
            
            sections.forEach((section, idx) => {
                boreholeData.forEach(bh => {
                    if (!(bh.name in section.visibility)) {
                        const sectionNumber = idx + 1;
                        
                        if (sectionNumber === 1) {
                            section.visibility[bh.name] = (bh.name === 'BH04' || bh.name === 'BH05');
                        } else if (sectionNumber === 2) {
                            section.visibility[bh.name] = (bh.name === 'BH01' || bh.name === 'BH02' || bh.name === 'BH03' || bh.name === 'BH04');
                        } else if (sectionNumber === 3) {
                            section.visibility[bh.name] = (bh.name === 'BH05' || bh.name === 'BH06');
                        } else if (sectionNumber === 4) {
                            section.visibility[bh.name] = (bh.name === 'BH06' || bh.name === 'BH07' || bh.name === 'BH08');
                        } else {
                            section.visibility[bh.name] = true;
                        }
                    }
                });
            });
            
            updateTimeControls();
            updateDataInfo();
            plotOnMap();
            renderSections();
            
            sections.forEach(section => {
                generateCrossSection(section.id);
            });

            globalMinGW = Infinity;
            globalMaxGW = -Infinity;
            for (let day = 1; day <= maxDays; day++) {
                boreholeData.forEach(bh => {
                    const gw = getCurrentGWLevel(bh, day);
                    if (gw !== null) {
                        globalMinGW = Math.min(globalMinGW, gw);
                        globalMaxGW = Math.max(globalMaxGW, gw);
                    }
                });
            }

            updateIsopachMap();
            render3D();
        }

        // ===== TIME CONTROLS =====
        function updateTimeControls() {
            document.getElementById('timeDisplay').textContent = `Day ${currentDay}`;
            document.getElementById('dateDisplay').textContent = getDateForDay(currentDay);
            document.getElementById('prevBtn').disabled = currentDay <= 1;
            document.getElementById('nextBtn').disabled = currentDay >= maxDays;
            document.getElementById('daySlider').max = maxDays;
            document.getElementById('daySlider').value = currentDay;
            document.getElementById('sliderValue').textContent = currentDay;
        }

        function previousDay() {
            if (currentDay > 1) {
                currentDay--;
                updateTimeControls();
                sections.forEach(section => generateCrossSection(section.id));
                updateIsopachMap();
                render3D();
            }
        }

        function nextDay() {
            if (currentDay < maxDays) {
                currentDay++;
                updateTimeControls();
                sections.forEach(section => generateCrossSection(section.id));
                updateIsopachMap();
                render3D();
            }
        }

        function jumpToDay(day) {
            currentDay = parseInt(day);
            updateTimeControls();
            sections.forEach(section => generateCrossSection(section.id));
            updateIsopachMap();
            render3D();
        }

        function getCurrentGWLevel(bh, day) {
            return day <= bh.gwElevations.length ? bh.gwElevations[day - 1] : null;
        }

        // ===== CROSS-SECTION GENERATION =====
        function generateCrossSection(sectionId) {
            if (boreholeData.length < 2) {
                alert('Need at least 2 boreholes for cross-section');
                return;
            }

            const section = sections.find(s => s.id === sectionId);
            if (!section) return;

            const canvasId = `crossSection${sectionId}`;
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const visibleBoreholes = boreholeData.filter(bh => section.visibility[bh.name]);

            if (visibleBoreholes.length < 2) {
                ctx.fillStyle = '#666';
                ctx.font = '14px Arial';
                ctx.fillText('Select at least 2 boreholes to display', 20, canvas.height / 2);
                return;
            }

            const sortedBoreholes = sortBoreholesByBestFit(visibleBoreholes);
            drawCrossSection(ctx, sortedBoreholes, section.name, section.color, sectionId);
            updateLegend();
        }

        function sortBoreholesByBestFit(boreholes) {
            const n = boreholes.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;

            boreholes.forEach(bh => {
                sumX += bh.easting;
                sumY += bh.northing;
                sumXY += bh.easting * bh.northing;
                sumX2 += bh.easting * bh.easting;
            });

            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            const lineStart = {
                x: Math.min(...boreholes.map(bh => bh.easting)),
                y: 0
            };
            lineStart.y = slope * lineStart.x + intercept;

            boreholes.forEach(bh => {
                const dx = bh.easting - lineStart.x;
                const dy = bh.northing - lineStart.y;
                bh.distanceAlongLine = Math.sqrt(dx * dx + dy * dy);
            });

            return [...boreholes].sort((a, b) => a.distanceAlongLine - b.distanceAlongLine);
        }

        function getSynchronizedElevationRange(sectionId) {
            const section = sections.find(s => s.id === sectionId);
            if (!section) return null;

            const sectionIndex = sections.findIndex(s => s.id === sectionId);
            
            let syncSectionIds = [];
            if (sectionIndex === 0 || sectionIndex === 1) {
                syncSectionIds = [sections[0]?.id, sections[1]?.id].filter(id => id !== undefined);
            } else if (sectionIndex === 2 || sectionIndex === 3) {
                syncSectionIds = [sections[2]?.id, sections[3]?.id].filter(id => id !== undefined);
            }

            let allBoreholes = [];
            syncSectionIds.forEach(syncId => {
                const syncSection = sections.find(s => s.id === syncId);
                if (syncSection) {
                    const visibleBoreholes = boreholeData.filter(bh => syncSection.visibility[bh.name]);
                    allBoreholes.push(...visibleBoreholes);
                }
            });

            if (allBoreholes.length === 0) return null;

            const minElevation = Math.min(...allBoreholes.map(bh => bh.groundLevel - bh.depth));
            const maxElevation = Math.max(...allBoreholes.map(bh => bh.groundLevel));

            return { minElevation, maxElevation };
        }

        function drawCrossSection(ctx, boreholes, sectionName, sectionColor, sectionId) {
            const padding = 50;
            const width = ctx.canvas.width - 2 * padding;
            const height = ctx.canvas.height - 2 * padding;

            const maxDistance = Math.max(...boreholes.map(bh => bh.distanceAlongLine));
            
            const elevationRange = getSynchronizedElevationRange(sectionId);
            const minElevation = elevationRange ? elevationRange.minElevation : Math.min(...boreholes.map(bh => bh.groundLevel - bh.depth));
            const maxElevation = elevationRange ? elevationRange.maxElevation : Math.max(...boreholes.map(bh => bh.groundLevel));

            const xScale = width / maxDistance;
            const yScale = height / (maxElevation - minElevation);

            // Draw grid
            ctx.strokeStyle = 'rgba(150, 150, 150, 0.2)';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 3]);
            
            const minElev = Math.floor(minElevation);
            const maxElev = Math.ceil(maxElevation);
            
            for (let elev = minElev; elev <= maxElev; elev += 1) {
                const y = padding + height - (elev - minElevation) * yScale;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + width, y);
                ctx.stroke();
            }
            ctx.setLineDash([]);

            // Draw axes
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, padding + height);
            ctx.lineTo(padding + width, padding + height);
            ctx.stroke();

            // Y-axis labels
            ctx.fillStyle = '#000';
            ctx.font = '11px Arial';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            
            for (let elev = minElev; elev <= maxElev; elev += 1) {
                const y = padding + height - (elev - minElevation) * yScale;
                
                ctx.beginPath();
                ctx.moveTo(padding - 5, y);
                ctx.lineTo(padding, y);
                ctx.stroke();
                
                ctx.fillText(elev.toFixed(0) + 'm', padding - 8, y);
            }
            
            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';

            // Draw previous day's groundwater level (dashed)
            ctx.strokeStyle = '#0066cc';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            boreholes.forEach((bh, i) => {
                const x = padding + bh.distanceAlongLine * xScale;
                let previousGwElevation;
                
                if (currentDay === 1) {
                    previousGwElevation = bh.groundLevel - bh.depthToGW;
                } else {
                    const previousGW = getCurrentGWLevel(bh, currentDay - 1);
                    previousGwElevation = previousGW !== null ? previousGW : (bh.groundLevel - bh.depthToGW);
                }
                
                const gwY = padding + height - (previousGwElevation - minElevation) * yScale;
                
                if (i === 0) {
                    ctx.moveTo(x, gwY);
                } else {
                    ctx.lineTo(x, gwY);
                }
            });
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw current day's groundwater level (solid)
            ctx.strokeStyle = '#0066cc';
            ctx.lineWidth = 3;
            ctx.beginPath();
            boreholes.forEach((bh, i) => {
                const x = padding + bh.distanceAlongLine * xScale;
                const currentGW = getCurrentGWLevel(bh, currentDay);
                
                if (currentGW !== null) {
                    const gwY = padding + height - (currentGW - minElevation) * yScale;
                    
                    if (i === 0) {
                        ctx.moveTo(x, gwY);
                    } else {
                        ctx.lineTo(x, gwY);
                    }
                }
            });
            ctx.stroke();

            // Draw boreholes
            boreholes.forEach(bh => {
                const x = padding + bh.distanceAlongLine * xScale;
                const groundY = padding + height - (bh.groundLevel - minElevation) * yScale;
                const bottomY = padding + height - (bh.groundLevel - bh.depth - minElevation) * yScale;

                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, groundY);
                ctx.lineTo(x, bottomY);
                ctx.stroke();

                const currentGW = getCurrentGWLevel(bh, currentDay);
                if (currentGW !== null) {
                    const gwY = padding + height - (currentGW - minElevation) * yScale;
                    ctx.strokeStyle = '#0066cc';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x - 10, gwY);
                    ctx.lineTo(x + 10, gwY);
                    ctx.stroke();
                }

                let currentDepth = 0;
                bh.units.forEach(unit => {
                    const unitTopY = padding + height - (bh.groundLevel - currentDepth - minElevation) * yScale;
                    const unitBottomY = padding + height - (bh.groundLevel - unit.depth - minElevation) * yScale;

                    ctx.fillStyle = soilColors[unit.name] || '#cccccc';
                    ctx.fillRect(x - 5, unitTopY, 10, unitBottomY - unitTopY);

                    ctx.fillStyle = '#000';
                    ctx.font = '10px Arial';
                    ctx.fillText(unit.name, x + 8, (unitTopY + unitBottomY) / 2);

                    currentDepth = unit.depth;
                });

                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.fillText(bh.name, x - 15, groundY - 5);
            });

            // Axis labels
            ctx.fillStyle = '#000';
            ctx.font = '12px Arial';
            ctx.fillText('Distance (m)', padding + width / 2, padding + height + 30);

            ctx.save();
            ctx.translate(20, padding + height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Elevation (m AHD)', 0, 0);
            ctx.restore();

            ctx.fillStyle = sectionColor;
            ctx.font = 'bold 16px Arial';
            ctx.fillText(`${sectionName} - Day ${currentDay}`, padding + width - 150, padding + 20);
        }

        function updateLegend() {
            const legend = document.getElementById('legend');
            legend.innerHTML = '';

            const usedSoils = new Set();
            boreholeData.forEach(bh => {
                bh.units.forEach(unit => {
                    usedSoils.add(unit.name);
                });
            });

            usedSoils.forEach(soil => {
                const item = document.createElement('div');
                item.className = 'legend-item';

                const colorInput = document.createElement('input');
                colorInput.type = 'color';
                colorInput.className = 'color-picker';
                colorInput.value = rgbToHex(soilColors[soil] || '#cccccc');
                colorInput.addEventListener('change', (e) => {
                    soilColors[soil] = e.target.value;
                    sections.forEach(section => generateCrossSection(section.id));
                    render3D();
                });

                const label = document.createElement('span');
                label.textContent = soil;
                label.style.marginLeft = '8px';

                item.appendChild(colorInput);
                item.appendChild(label);
                legend.appendChild(item);
            });
        }

        function rgbToHex(rgb) {
            if (!rgb || typeof rgb !== 'string') return '#cccccc';
            if (rgb.startsWith('#')) return rgb;

            const result = rgb.match(/\d+/g);
            if (result) {
                return '#' + result.map(x => parseInt(x).toString(16).padStart(2, '0')).join('');
            }
            return '#cccccc';
        }

        function exportSectionToPNG(sectionId) {
            if (!boreholeData.length) {
                alert('Load data first');
                return;
            }

            const section = sections.find(s => s.id === sectionId);
            if (!section) return;

            const canvasId = `crossSection${sectionId}`;
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const link = document.createElement('a');
            link.download = `${section.name.toLowerCase().replace(' ', '_')}_day_${currentDay}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // ===== SECTION LINES ON MAP =====
        function addSectionLine(sectionId) {
            if (boreholeData.length < 2) return;

            const section = sections.find(s => s.id === sectionId);
            if (!section) return;

            const visibleBoreholes = boreholeData.filter(bh => section.visibility[bh.name]);
            if (visibleBoreholes.length < 2) return;

            const n = visibleBoreholes.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;

            visibleBoreholes.forEach(bh => {
                sumX += bh.easting;
                sumY += bh.northing;
                sumXY += bh.easting * bh.northing;
                sumX2 += bh.easting * bh.easting;
            });

            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            const minEasting = Math.min(...visibleBoreholes.map(bh => bh.easting));
            const maxEasting = Math.max(...visibleBoreholes.map(bh => bh.easting));

            const startNorthing = slope * minEasting + intercept;
            const endNorthing = slope * maxEasting + intercept;

            const startLatLng = utmToLatLng(minEasting, startNorthing, 50, 'S');
            const endLatLng = utmToLatLng(maxEasting, endNorthing, 50, 'S');

            const line = L.polyline([
                [startLatLng.lat, startLatLng.lng],
                [endLatLng.lat, endLatLng.lng]
            ], {
                color: section.color,
                weight: 3,
                opacity: 0.8,
                dashArray: '10, 5'
            }).addTo(map);

            line.bindTooltip(`${section.name} Line`, {
                permanent: false,
                direction: 'top'
            });

            sectionLines[sectionId] = line;
        }

        function updateSectionLine(sectionId) {
            if (sectionLines[sectionId]) {
                map.removeLayer(sectionLines[sectionId]);
                delete sectionLines[sectionId];
            }
            const checkbox = document.getElementById(`showSectionLine${sectionId}`);
            if (checkbox && checkbox.checked) {
                addSectionLine(sectionId);
            }
        }

        function toggleSectionLine(sectionId) {
            if (sectionLines[sectionId]) {
                map.removeLayer(sectionLines[sectionId]);
                delete sectionLines[sectionId];
            }
            const checkbox = document.getElementById(`showSectionLine${sectionId}`);
            if (checkbox && checkbox.checked) {
                addSectionLine(sectionId);
            }
        }

        // ===== KRIGING CLASS =====
        class ImprovedKriging {
            constructor(points, values, range, smoothing = 3) {
                this.points = points;
                this.values = values;
                this.range = range;
                this.smoothing = smoothing;
            }

            predict(x, y) {
                const maxDist = this.range;
                const minDist = 0.1;
                
                let totalWeight = 0;
                let weightedSum = 0;
                let minDistFound = Infinity;
                let closestValue = null;

                for (let i = 0; i < this.points.length; i++) {
                    const dx = x - this.points[i].x;
                    const dy = y - this.points[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    minDistFound = Math.min(minDistFound, dist);
                    
                    if (dist < minDist) {
                        return this.values[i];
                    }
                    
                    if (dist <= maxDist) {
                        const power = 3.0 - (this.smoothing - 1) * 0.4;
                        const weight = 1.0 / Math.pow(dist, power);
                        weightedSum += weight * this.values[i];
                        totalWeight += weight;
                        
                        if (closestValue === null) {
                            closestValue = this.values[i];
                        }
                    }
                }

                if (totalWeight > 0) {
                    return weightedSum / totalWeight;
                }
                
                let nearestDist = Infinity;
                let nearestValue = this.values[0];
                for (let i = 0; i < this.points.length; i++) {
                    const dx = x - this.points[i].x;
                    const dy = y - this.points[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestValue = this.values[i];
                    }
                }
                return nearestValue;
            }

            interpolateGrid(bounds, resolution) {
                const { minX, maxX, minY, maxY } = bounds;
                const dx = (maxX - minX) / resolution;
                const dy = (maxY - minY) / resolution;

                const grid = [];
                for (let i = 0; i <= resolution; i++) {
                    const row = [];
                    for (let j = 0; j <= resolution; j++) {
                        const x = minX + j * dx;
                        const y = minY + i * dy;
                        row.push(this.predict(x, y));
                    }
                    grid.push(row);
                }

                if (this.smoothing > 1) {
                    return { grid: this.gaussianSmooth(grid, resolution), bounds, resolution, dx, dy };
                }

                return { grid, bounds, resolution, dx, dy };
            }

            gaussianSmooth(grid, resolution) {
                const smoothed = [];
                const kernelSize = this.smoothing;
                const kernel = this.getGaussianKernel(kernelSize);
                const offset = Math.floor(kernel.length / 2);

                for (let i = 0; i <= resolution; i++) {
                    const row = [];
                    for (let j = 0; j <= resolution; j++) {
                        let sum = 0, weightSum = 0;

                        for (let ki = 0; ki < kernel.length; ki++) {
                            for (let kj = 0; kj < kernel.length; kj++) {
                                const ii = i + ki - offset;
                                const jj = j + kj - offset;

                                if (ii >= 0 && ii <= resolution && jj >= 0 && jj <= resolution) {
                                    const weight = kernel[ki][kj];
                                    sum += grid[ii][jj] * weight;
                                    weightSum += weight;
                                }
                            }
                        }

                        row.push(sum / weightSum);
                    }
                    smoothed.push(row);
                }

                return smoothed;
            }

            getGaussianKernel(size) {
                const sigma = size / 2;
                const kernelSize = size * 2 + 1;
                const kernel = [];
                let sum = 0;

                for (let i = 0; i < kernelSize; i++) {
                    kernel[i] = [];
                    for (let j = 0; j < kernelSize; j++) {
                        const x = i - size;
                        const y = j - size;
                        const value = Math.exp(-(x * x + y * y) / (2 * sigma * sigma));
                        kernel[i][j] = value;
                        sum += value;
                    }
                }

                for (let i = 0; i < kernelSize; i++) {
                    for (let j = 0; j < kernelSize; j++) {
                        kernel[i][j] /= sum;
                    }
                }

                return kernel;
            }
        }

        // ===== ISOPACH MAP =====
        function updateContourInterval(value) {
            contourInterval = parseFloat(value);
            document.getElementById('contourIntervalValue').textContent = value + 'm';
            updateIsopachMap();
        }

        function updateGridResolution(value) {
            gridResolution = parseInt(value);
            document.getElementById('gridResolutionValue').textContent = value;
            updateIsopachMap();
        }

        function updateSmoothing(value) {
            smoothingFactor = parseInt(value);
            const labels = ['Very Low', 'Low', 'Medium', 'High', 'Very High'];
            document.getElementById('smoothingValue').textContent = labels[value - 1];
            updateIsopachMap();
        }

        function updateInterpolationRange(value) {
            interpolationRange = parseInt(value);
            document.getElementById('interpolationRangeValue').textContent = value + 'm';
            updateIsopachMap();
        }

        function updateIsopachMap() {
            if (!isopachMap || boreholeData.length < 3) return;

            isopachMap.eachLayer(layer => {
                if (!(layer instanceof L.TileLayer)) {
                    isopachMap.removeLayer(layer);
                }
            });

            const points = [], values = [];
            boreholeData.forEach(bh => {
                const gw = getCurrentGWLevel(bh, currentDay);
                if (gw !== null) {
                    points.push({ x: bh.easting, y: bh.northing });
                    values.push(gw);
                }
            });
            if (points.length < 3) return;

            const minE = Math.min(...points.map(p => p.x));
            const maxE = Math.max(...points.map(p => p.x));
            const minN = Math.min(...points.map(p => p.y));
            const maxN = Math.max(...points.map(p => p.y));
            const bounds = {
                minX: minE - 10,
                maxX: maxE + 10,
                minY: minN - 10,
                maxY: maxN + 10
            };

            const kriging = new ImprovedKriging(points, values, interpolationRange, smoothingFactor);
            krigingGrid = kriging.interpolateGrid(bounds, gridResolution);

            const allValues = krigingGrid.grid.flat();
            const minValue = Math.min(...allValues);
            const maxValue = Math.max(...allValues);

            updateIsopachLegend(minValue, maxValue);

            if (document.getElementById('showHeatmap').checked) {
                drawHeatmap(krigingGrid, minValue, maxValue);
            }
            if (document.getElementById('showContours').checked) {
                drawContours(krigingGrid, minValue, maxValue);
            }

            boreholeData.forEach(bh => {
                const marker = L.circleMarker([bh.lat, bh.lng], {
                    radius: 6,
                    fillColor: '#fff',
                    color: '#000',
                    weight: 2,
                    fillOpacity: 0.9
                }).addTo(isopachMap);
                const gw = getCurrentGWLevel(bh, currentDay);
                marker.bindPopup(`<b>${bh.name}</b><br>GW: ${gw ? gw.toFixed(2) : 'N/A'}m AHD`);
            });
        }

        function drawHeatmap(grid, minValue, maxValue) {
            const { bounds, resolution } = grid;
            const canvas = document.createElement('canvas');
            canvas.width = resolution + 1;
            canvas.height = resolution + 1;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(canvas.width, canvas.height);

            const colorScaleMin = globalMinGW !== null ? globalMinGW : minValue;
            const colorScaleMax = globalMaxGW !== null ? globalMaxGW : maxValue;

            for (let i = 0; i <= resolution; i++) {
                for (let j = 0; j <= resolution; j++) {
                    const value = grid.grid[i][j];
                    const norm = (value - colorScaleMin) / (colorScaleMax - colorScaleMin);
                    const color = getColorForValue(norm);

                    const canvasX = j;
                    const canvasY = resolution - i;
                    const idx = (canvasY * canvas.width + canvasX) * 4;

                    imageData.data[idx] = color.r;
                    imageData.data[idx + 1] = color.g;
                    imageData.data[idx + 2] = color.b;
                    imageData.data[idx + 3] = 100;
                }
            }
            ctx.putImageData(imageData, 0, 0);

            const sw = utmToLatLng(bounds.minX, bounds.minY, 50, 'S');
            const ne = utmToLatLng(bounds.maxX, bounds.maxY, 50, 'S');
            L.imageOverlay(canvas.toDataURL(), [[sw.lat, sw.lng], [ne.lat, ne.lng]]).addTo(isopachMap);
        }

        function drawContours(grid, minValue, maxValue) {
            const { bounds, resolution, dx, dy } = grid;
            const levels = [];
            for (let level = Math.ceil(minValue / contourInterval) * contourInterval; level <= maxValue; level += contourInterval) {
                levels.push(level);
            }

            levels.forEach((level, levelIdx) => {
                const contours = marchingSquares(grid.grid, level, resolution);
                const shouldLabel = levelIdx % 2 === 0;
                let labelDrawnForThisLevel = false;
                let rightmostLatLng = null;
                let maxLng = -Infinity;

                contours.forEach((contour, idx) => {
                    const latLngs = contour.map(p => {
                        const x = bounds.minX + p.x * dx;
                        const y = bounds.minY + p.y * dy;
                        const ll = utmToLatLng(x, y, 50, 'S');
                        return [ll.lat, ll.lng];
                    });

                    if (latLngs.length >= 2) {
                        L.polyline(latLngs, {
                            color: '#0066cc',
                            weight: 2.5,
                            opacity: 1.0,
                            smoothFactor: 1.0
                        }).addTo(isopachMap);

                        if (shouldLabel && !labelDrawnForThisLevel) {
                            latLngs.forEach(ll => {
                                if (ll[1] > maxLng) {
                                    maxLng = ll[1];
                                    rightmostLatLng = ll;
                                }
                            });
                        }
                    }
                });
                
                if (shouldLabel && rightmostLatLng) {
                    labelDrawnForThisLevel = true;
                    
                    const labelIcon = L.divIcon({
                        className: 'contour-label',
                        html: `<div style="background: rgba(255,255,255,0.9); padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: bold; color: #0066cc; border: 1.5px solid #0066cc; white-space: nowrap; box-shadow: 0 1px 3px rgba(0,0,0,0.3);">${level.toFixed(2)}</div>`,
                        iconSize: [50, 20],
                        iconAnchor: [-5, 10]
                    });
                    L.marker(rightmostLatLng, { icon: labelIcon }).addTo(isopachMap);
                }
            });
        }

        function marchingSquares(grid, level, resolution) {
            const contours = [];
            const visited = Array(resolution).fill(0).map(() => Array(resolution).fill(false));

            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    if (visited[i][j]) continue;

                    const v00 = grid[i][j];
                    const v10 = grid[i][j + 1];
                    const v01 = grid[i + 1][j];
                    const v11 = grid[i + 1][j + 1];

                    const c = (v00 >= level ? 8 : 0) + (v10 >= level ? 4 : 0) +
                        (v11 >= level ? 2 : 0) + (v01 >= level ? 1 : 0);

                    if (c === 0 || c === 15) continue;

                    const contour = traceContour(grid, level, resolution, i, j, visited);
                    if (contour.length > 1) {
                        contours.push(contour);
                    }
                }
            }

            return contours;
        }

        function traceContour(grid, level, resolution, startI, startJ, visited) {
            const contour = [];
            let i = startI, j = startJ;
            let prevDir = -1;
            const maxSteps = resolution * resolution * 4;
            let steps = 0;

            while (steps < maxSteps) {
                if (i < 0 || i >= resolution || j < 0 || j >= resolution) break;

                visited[i][j] = true;

                const v00 = grid[i][j];
                const v10 = grid[i][j + 1];
                const v01 = grid[i + 1][j];
                const v11 = grid[i + 1][j + 1];

                const c = (v00 >= level ? 8 : 0) + (v10 >= level ? 4 : 0) +
                    (v11 >= level ? 2 : 0) + (v01 >= level ? 1 : 0);

                if (c === 0 || c === 15) break;

                const edges = getEdges(c, prevDir);
                if (edges.length === 0) break;

                const edge = edges[0];
                const point = getEdgePoint(i, j, v00, v10, v01, v11, edge, level);
                contour.push(point);

                const nextCell = getNextCell(i, j, edge);
                if (nextCell.i === startI && nextCell.j === startJ && contour.length > 3) {
                    contour.push(contour[0]);
                    break;
                }

                prevDir = getOppositeEdge(edge);
                i = nextCell.i;
                j = nextCell.j;
                steps++;
            }

            return contour;
        }

        function getEdges(caseValue, prevDir) {
            const edgeTable = {
                1: ['left', 'bottom'], 2: ['bottom', 'right'], 3: ['left', 'right'],
                4: ['top', 'right'], 5: ['top', 'bottom'], 6: ['top', 'bottom'],
                7: ['left', 'top'], 8: ['left', 'top'], 9: ['top', 'bottom'],
                10: ['top', 'bottom'], 11: ['top', 'right'], 12: ['left', 'right'],
                13: ['bottom', 'right'], 14: ['left', 'bottom']
            };

            const edges = edgeTable[caseValue] || [];
            if (prevDir >= 0 && edges.includes(prevDir)) {
                return edges.filter(e => e !== prevDir);
            }
            return edges;
        }

        function getEdgePoint(i, j, v00, v10, v01, v11, edge, level) {
            const epsilon = 0.0001;
            let t;

            switch (edge) {
                case 'top':
                    t = Math.abs(v10 - v00) > epsilon ? (level - v00) / (v10 - v00) : 0.5;
                    return { x: j + Math.max(0, Math.min(1, t)), y: i };
                case 'right':
                    t = Math.abs(v11 - v10) > epsilon ? (level - v10) / (v11 - v10) : 0.5;
                    return { x: j + 1, y: i + Math.max(0, Math.min(1, t)) };
                case 'bottom':
                    t = Math.abs(v11 - v01) > epsilon ? (level - v01) / (v11 - v01) : 0.5;
                    return { x: j + Math.max(0, Math.min(1, t)), y: i + 1 };
                case 'left':
                    t = Math.abs(v01 - v00) > epsilon ? (level - v00) / (v01 - v00) : 0.5;
                    return { x: j, y: i + Math.max(0, Math.min(1, t)) };
            }
        }

        function getNextCell(i, j, edge) {
            switch (edge) {
                case 'top': return { i: i, j: j + 1 };
                case 'right': return { i: i + 1, j: j };
                case 'bottom': return { i: i, j: j - 1 };
                case 'left': return { i: i - 1, j: j };
            }
        }

        function getOppositeEdge(edge) {
            const opposites = { 'top': 'bottom', 'bottom': 'top', 'left': 'right', 'right': 'left' };
            return opposites[edge];
        }

        function getColorForValue(norm) {
            if (norm < 0.25) {
                const t = norm / 0.25;
                return { r: 0, g: Math.floor(t * 255), b: 255 };
            } else if (norm < 0.5) {
                const t = (norm - 0.25) / 0.25;
                return { r: 0, g: 255, b: Math.floor((1 - t) * 255) };
            } else if (norm < 0.75) {
                const t = (norm - 0.5) / 0.25;
                return { r: Math.floor(t * 255), g: 255, b: 0 };
            } else {
                const t = (norm - 0.75) / 0.25;
                return { r: 255, g: Math.floor((1 - t) * 255), b: 0 };
            }
        }

        function updateIsopachLegend(minValue, maxValue) {
            const legend = document.getElementById('isopachLegend');
            const legendMin = globalMinGW !== null ? globalMinGW : minValue;
            const legendMax = globalMaxGW !== null ? globalMaxGW : maxValue;
            
            const dateStr = getDateForDay(currentDay);

            legend.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 5px; font-size: 12px;">GW Elevation (m AHD) - Day ${currentDay}${dateStr !== '-' ? ' (' + dateStr + ')' : ''}</div>
                <div class="isopach-gradient" style="background: linear-gradient(to right, rgb(0,0,255), rgb(0,255,255), rgb(0,255,0), rgb(255,255,0), rgb(255,0,0));"></div>
                <div class="isopach-labels">
                    <span>${legendMin.toFixed(2)}</span>
                    <span>${((legendMin + legendMax) / 2).toFixed(2)}</span>
                    <span>${legendMax.toFixed(2)}</span>
                </div>
                <div style="font-size: 10px; color: #666; margin-top: 3px;">Fixed scale across all ${maxDays} days</div>
                <div style="font-size: 10px; color: #0066cc; margin-top: 3px; font-weight: bold;">Contour Interval: ${contourInterval} m</div>
            `;
        }

        // ===== 3D RENDERING =====
        async function render3D() {
            const container = document.getElementById('threeContainer');
            if (boreholeData.length === 0) {
                container.innerHTML = '';
                return;
            }

            const dayIndicator = document.getElementById('threeDayIndicator');
            if (dayIndicator) {
                const dateStr = getDateForDay(currentDay);
                dayIndicator.textContent = `(Day ${currentDay}${dateStr !== '-' ? ' - ' + dateStr : ''})`;
            }

            try {
                if (!threeModule) {
                    threeModule = await import('https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js');
                }
                const THREE = threeModule;

                const minE = Math.min(...boreholeData.map(b => b.easting));
                const maxE = Math.max(...boreholeData.map(b => b.easting));
                const minN = Math.min(...boreholeData.map(b => b.northing));
                const maxN = Math.max(...boreholeData.map(b => b.northing));
                const minElev = Math.min(...boreholeData.map(b => b.groundLevel - b.depth));
                const scale = 0.1;

                if (!cameraTarget) {
                    cameraTarget = new THREE.Vector3((maxE - minE) * scale * 0.5, 0, -(maxN - minN) * scale * 0.5);
                }

                let scene, camera, renderer;
                if (threeScene && threeCamera && threeRenderer) {
                    scene = threeScene;
                    camera = threeCamera;
                    renderer = threeRenderer;

                    const objectsToRemove = [];
                    scene.children.forEach(child => {
                        if (child.type === 'Mesh') {
                            if (child.geometry.type === 'PlaneGeometry' && Math.abs(child.position.y) < 0.01) {
                                return;
                            }
                            objectsToRemove.push(child);
                        } else if (child.type === 'LineSegments' || child.type === 'Line') {
                            objectsToRemove.push(child);
                        }
                    });
                    objectsToRemove.forEach(obj => {
                        if (obj.geometry) obj.geometry.dispose();
                        if (obj.material) obj.material.dispose();
                        scene.remove(obj);
                    });
                } else {
                    scene = new THREE.Scene();
                    scene.background = new THREE.Color(0xffffff);
                    camera = new THREE.PerspectiveCamera(45, container.offsetWidth / container.offsetHeight, 0.1, 1000);
                    renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
                    renderer.setSize(container.offsetWidth, container.offsetHeight);
                    container.innerHTML = '';
                    container.appendChild(renderer.domElement);

                    const dirLight1 = new THREE.DirectionalLight(0xffffff, 1.2);
                    dirLight1.position.set(10, 20, 10);
                    scene.add(dirLight1);
                    
                    const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
                    dirLight2.position.set(-10, 15, -10);
                    scene.add(dirLight2);
                    
                    scene.add(new THREE.AmbientLight(0xdddddd, 1.5));

                    if (document.getElementById('showGroundPlane').checked) {
                        const plane = new THREE.Mesh(
                            new THREE.PlaneGeometry((maxE - minE) * scale * 1.5, (maxN - minN) * scale * 1.5),
                            new THREE.MeshPhongMaterial({ color: 0xeeeeee, side: THREE.DoubleSide })
                        );
                        plane.rotation.x = -Math.PI / 2;
                        plane.position.set((maxE - minE) * scale * 0.5,
                            (minElev - Math.max(...boreholeData.map(b => b.groundLevel))) * scale * verticalExaggeration,
                            -(maxN - minN) * scale * 0.5);
                        scene.add(plane);
                    }

                    threeScene = scene;
                    threeCamera = camera;
                    threeRenderer = renderer;
                    setupMouseControls(renderer, camera);
                }

                updateCameraPosition();

                if (document.getElementById('showBoreholes3D').checked) {
                    boreholeData.forEach(bh => {
                        const x = (bh.easting - minE) * scale;
                        const z = -(bh.northing - minN) * scale;
                        const groundY = (bh.groundLevel - minElev) * scale * verticalExaggeration;

                        let currentDepth = 0;
                        bh.units.forEach(unit => {
                            const unitHeight = (unit.depth - currentDepth) * scale * verticalExaggeration;
                            const box = new THREE.Mesh(
                                new THREE.BoxGeometry(0.5, unitHeight, 0.5),
                                new THREE.MeshPhongMaterial({ color: new THREE.Color(soilColors[unit.name] || '#ccc') })
                            );
                            box.position.set(x, groundY - (currentDepth * scale * verticalExaggeration) - (unitHeight / 2), z);
                            scene.add(box);
                            currentDepth = unit.depth;
                        });

                        const gw = getCurrentGWLevel(bh, currentDay);
                        if (gw !== null) {
                            const gwHeight = (gw - minElev) * scale * verticalExaggeration;
                            const gwBox = new THREE.Mesh(
                                new THREE.BoxGeometry(0.8, 0.1, 0.8),
                                new THREE.MeshPhongMaterial({ color: 0x0066cc, transparent: true, opacity: 0.7 })
                            );
                            gwBox.position.set(x, gwHeight, z);
                            scene.add(gwBox);
                        }
                    });
                }

                if (document.getElementById('showGWTIN').checked && krigingGrid) {
                    drawGWTINSurface(THREE, scene, krigingGrid, minE, minN, minElev, scale);
                }
                
                if (document.getElementById('showGroundSurface').checked && boreholeData.length > 0) {
                    drawGroundSurface(THREE, scene, boreholeData, minE, minN, minElev, scale);
                }
                
                if (document.getElementById('showVisualizationBox').checked && visualizationBoxCorners.length === 4) {
                    drawVisualizationBox(THREE, scene, visualizationBoxCorners, boreholeData, minE, minN, minElev, scale);
                }

                function animate() {
                    requestAnimationFrame(animate);
                    renderer.render(scene, camera);
                }
                if (!threeRenderer.info.render.frame) animate();

            } catch (error) {
                console.error('3D error:', error);
                container.innerHTML = '<div style="padding: 20px;">3D visualization unavailable</div>';
            }
        }

        function drawGWTINSurface(THREE, scene, grid, minE, minN, minElev, scale) {
            const { bounds, resolution } = grid;
            const dx = (bounds.maxX - bounds.minX) / resolution;
            const dy = (bounds.maxY - bounds.minY) / resolution;

            const vertices = [], colors = [];
            const allValues = grid.grid.flat();

            const minGW = globalMinGW !== null ? globalMinGW : Math.min(...allValues);
            const maxGW = globalMaxGW !== null ? globalMaxGW : Math.max(...allValues);

            for (let i = 0; i <= resolution; i++) {
                for (let j = 0; j <= resolution; j++) {
                    const x = (bounds.minX + j * dx - minE) * scale;
                    const z = -((bounds.minY + i * dy) - minN) * scale;
                    const gwElev = grid.grid[i][j];
                    const y = (gwElev - minElev) * scale * verticalExaggeration;
                    vertices.push(x, y, z);

                    const norm = (gwElev - minGW) / (maxGW - minGW);
                    const color = getColorForValue(norm);
                    colors.push(color.r / 255, color.g / 255, color.b / 255);
                }
            }

            const indices = [];
            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const tl = i * (resolution + 1) + j;
                    const tr = tl + 1;
                    const bl = (i + 1) * (resolution + 1) + j;
                    const br = bl + 1;

                    indices.push(tl, bl, tr);
                    indices.push(tr, bl, br);
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();

            const mesh = new THREE.Mesh(geometry,
                new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.85,
                    shininess: 50,
                    flatShading: false
                }));
            scene.add(mesh);

            const wireframeGeometry = new THREE.WireframeGeometry(geometry);
            const wireframe = new THREE.LineSegments(
                wireframeGeometry,
                new THREE.LineBasicMaterial({ color: 0x0066cc, transparent: true, opacity: 0.25, linewidth: 1 })
            );
            scene.add(wireframe);
        }
        
        function drawGroundSurface(THREE, scene, boreholeData, minE, minN, minElev, scale) {
            const points = boreholeData.map(bh => ({
                x: (bh.easting - minE) * scale,
                z: -((bh.northing - minN) * scale),
                y: (bh.groundLevel - minElev) * scale * verticalExaggeration
            }));
            
            const resolution = 50;
            const maxExtentX = Math.max(...boreholeData.map(b => b.easting)) - minE;
            const maxExtentZ = Math.max(...boreholeData.map(b => b.northing)) - minN;
            
            const vertices = [], colors = [];
            
            for (let i = 0; i <= resolution; i++) {
                for (let j = 0; j <= resolution; j++) {
                    const x = (j / resolution) * maxExtentX * scale;
                    const z = -(i / resolution) * maxExtentZ * scale;
                    
                    let sumWeight = 0, sumValue = 0;
                    points.forEach(p => {
                        const dist = Math.sqrt((x - p.x) ** 2 + (z - p.z) ** 2) + 0.1;
                        const weight = 1 / (dist * dist);
                        sumWeight += weight;
                        sumValue += weight * p.y;
                    });
                    const y = sumValue / sumWeight;
                    
                    vertices.push(x, y, z);
                    colors.push(0.6, 0.5, 0.4);
                }
            }
            
            const indices = [];
            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const tl = i * (resolution + 1) + j;
                    const tr = tl + 1;
                    const bl = (i + 1) * (resolution + 1) + j;
                    const br = bl + 1;
                    
                    indices.push(tl, bl, tr);
                    indices.push(tr, bl, br);
                }
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            
            const mesh = new THREE.Mesh(geometry,
                new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.5,
                    shininess: 20
                }));
            scene.add(mesh);
        }
        
        function drawVisualizationBox(THREE, scene, corners, boreholeData, minE, minN, minElev, scale) {
            const depthBelow = parseFloat(document.getElementById('boxDepthBelow').value) || 10;
            const heightAbove = parseFloat(document.getElementById('boxHeightAbove').value) || 5;
            
            const cornerCoords = corners.map(c => ({
                x: (c.easting - minE) * scale,
                z: -((c.northing - minN) * scale)
            }));
            
            let avgGroundLevel = 0;
            corners.forEach(c => {
                let minDist = Infinity;
                let nearestGL = 0;
                boreholeData.forEach(bh => {
                    const dist = Math.sqrt((c.easting - bh.easting) ** 2 + (c.northing - bh.northing) ** 2);
                    if (dist < minDist) {
                        minDist = dist;
                        nearestGL = bh.groundLevel;
                    }
                });
                avgGroundLevel += nearestGL;
            });
            avgGroundLevel /= corners.length;
            
            const baseY = (avgGroundLevel - minElev - depthBelow) * scale * verticalExaggeration;
            const topY = (avgGroundLevel - minElev + heightAbove) * scale * verticalExaggeration;
            const boxHeight = topY - baseY;
            
            const isOpaque = document.getElementById('boxOpaque').checked;
            
            const material = new THREE.MeshPhongMaterial({
                color: 0xcccccc,
                transparent: !isOpaque,
                opacity: isOpaque ? 1.0 : 0.3,
                side: THREE.DoubleSide
            });
            
            for (let i = 0; i < 4; i++) {
                const c1 = cornerCoords[i];
                const c2 = cornerCoords[(i + 1) % 4];
                
                const width = Math.sqrt((c2.x - c1.x) ** 2 + (c2.z - c1.z) ** 2);
                const angle = Math.atan2(c2.z - c1.z, c2.x - c1.x);
                
                const faceGeom = new THREE.PlaneGeometry(width, boxHeight);
                const face = new THREE.Mesh(faceGeom, material);
                
                face.position.set(
                    (c1.x + c2.x) / 2,
                    (baseY + topY) / 2,
                    (c1.z + c2.z) / 2
                );
                face.rotation.y = -angle;
                
                scene.add(face);
            }
            
            const shape = new THREE.Shape();
            shape.moveTo(cornerCoords[0].x, cornerCoords[0].z);
            for (let i = 1; i < 4; i++) {
                shape.lineTo(cornerCoords[i].x, cornerCoords[i].z);
            }
            shape.closePath();
            
            const topGeom = new THREE.ShapeGeometry(shape);
            const top = new THREE.Mesh(topGeom, material);
            top.rotation.x = -Math.PI / 2;
            top.position.y = topY;
            scene.add(top);
            
            const bottom = new THREE.Mesh(topGeom, material);
            bottom.rotation.x = -Math.PI / 2;
            bottom.position.y = baseY;
            scene.add(bottom);
            
            const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
            
            for (let i = 0; i < 4; i++) {
                const c1 = cornerCoords[i];
                const c2 = cornerCoords[(i + 1) % 4];
                const geom = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(c1.x, baseY, c1.z),
                    new THREE.Vector3(c2.x, baseY, c2.z)
                ]);
                scene.add(new THREE.Line(geom, edgeMaterial));
            }
            
            for (let i = 0; i < 4; i++) {
                const c1 = cornerCoords[i];
                const c2 = cornerCoords[(i + 1) % 4];
                const geom = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(c1.x, topY, c1.z),
                    new THREE.Vector3(c2.x, topY, c2.z)
                ]);
                scene.add(new THREE.Line(geom, edgeMaterial));
            }
            
            for (let i = 0; i < 4; i++) {
                const c = cornerCoords[i];
                const geom = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(c.x, baseY, c.z),
                    new THREE.Vector3(c.x, topY, c.z)
                ]);
                scene.add(new THREE.Line(geom, edgeMaterial));
            }
        }

        function updateCameraPosition() {
            if (!threeCamera || !cameraTarget) return;
            threeCamera.position.x = cameraTarget.x + cameraRadius * Math.sin(cameraPhi) * Math.cos(cameraTheta);
            threeCamera.position.y = cameraTarget.y + cameraRadius * Math.cos(cameraPhi);
            threeCamera.position.z = cameraTarget.z + cameraRadius * Math.sin(cameraPhi) * Math.sin(cameraTheta);
            threeCamera.lookAt(cameraTarget);
        }

        function setupMouseControls(renderer, camera) {
            let mouseX = 0, mouseY = 0, isMouseDown = false, isRightMouseDown = false;
            renderer.domElement.addEventListener('mousedown', e => {
                e.preventDefault();
                mouseX = e.clientX;
                mouseY = e.clientY;
                if (e.button === 0) isMouseDown = true;
                else if (e.button === 2) isRightMouseDown = true;
            });
            renderer.domElement.addEventListener('mouseup', () => {
                isMouseDown = false;
                isRightMouseDown = false;
            });
            renderer.domElement.addEventListener('mousemove', e => {
                if (isMouseDown || isRightMouseDown) {
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;
                    if (isMouseDown) {
                        const panSpeed = 0.02;
                        const right = new threeModule.Vector3();
                        const up = new threeModule.Vector3(0, 1, 0);
                        camera.getWorldDirection(right);
                        right.cross(up).normalize();
                        cameraTarget.addScaledVector(right, -deltaX * panSpeed);
                        cameraTarget.y += deltaY * panSpeed;
                        updateCameraPosition();
                    } else if (isRightMouseDown) {
                        cameraTheta -= deltaX * 0.01;
                        cameraPhi += deltaY * 0.01;
                        cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi));
                        updateCameraPosition();
                    }
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                }
            });
            renderer.domElement.addEventListener('wheel', e => {
                e.preventDefault();
                cameraRadius += e.deltaY * 0.02;
                cameraRadius = Math.max(5, Math.min(100, cameraRadius));
                updateCameraPosition();
            });
            renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
        }

        function resetCamera() {
            cameraRadius = 30;
            cameraTheta = 0;
            cameraPhi = Math.PI / 4;
            updateCameraPosition();
        }

        function setTopView() {
            cameraTheta = 0;
            cameraPhi = 0.01;
            cameraRadius = 35;
            updateCameraPosition();
        }

        function setSideView() {
            cameraTheta = Math.PI / 2;
            cameraPhi = Math.PI / 2;
            cameraRadius = 30;
            updateCameraPosition();
        }

        function updateVerticalExaggeration(value) {
            verticalExaggeration = parseFloat(value);
            document.getElementById('vertExagValue').textContent = verticalExaggeration.toFixed(1) + 'x';
            const veIndicator = document.getElementById('threeVEIndicator');
            if (veIndicator) {
                veIndicator.textContent = `(VE=${verticalExaggeration.toFixed(1)}x)`;
            }
            if (threeScene && threeRenderer) {
                const container = document.getElementById('threeContainer');
                container.removeChild(threeRenderer.domElement);
                threeScene = null;
                threeCamera = null;
                threeRenderer = null;
            }
            render3D();
        }
        
        function updateBoxDepthBelow(value) {
            document.getElementById('boxDepthBelowValue').textContent = value + ' m';
            render3D();
        }
        
        function updateBoxHeightAbove(value) {
            document.getElementById('boxHeightAboveValue').textContent = value + ' m';
            render3D();
        }

        // ===== COORDINATE CONVERSIONS =====
        function utmToLatLng(easting, northing, zone, hemisphere) {
            const a = 6378137.0, f = 1 / 298.257223563, k0 = 0.9996;
            const e = Math.sqrt(f * (2 - f));
            const e1sq = e * e / (1 - e * e);
            const x = easting - 500000;
            const y = northing - 10000000;
            const lonOrigin = toRadians(117);
            const M = y / k0;
            const mu = M / (a * (1 - e * e / 4 - 3 * e * e * e * e / 64));
            const e1 = (1 - Math.sqrt(1 - e * e)) / (1 + Math.sqrt(1 - e * e));
            const fp = mu + (3 * e1 / 2) * Math.sin(2 * mu) + (21 * e1 * e1 / 16) * Math.sin(4 * mu);
            const C1 = e1sq * Math.cos(fp) * Math.cos(fp);
            const T1 = Math.tan(fp) * Math.tan(fp);
            const N1 = a / Math.sqrt(1 - e * e * Math.sin(fp) * Math.sin(fp));
            const D = x / (N1 * k0);
            const lat = fp - (N1 * Math.tan(fp) / (a * k0)) * (D * D / 2);
            const lon = lonOrigin + (D - (1 + 2 * T1 + C1) * D * D * D / 6) / Math.cos(fp);
            return { lat: toDegrees(lat), lng: toDegrees(lon) };
        }
        
        function latLngToUtm(lat, lng, zone, hemisphere) {
            const a = 6378137.0, f = 1 / 298.257223563, k0 = 0.9996;
            const latRad = toRadians(lat);
            const lonRad = toRadians(lng);
            const lonOrigin = toRadians(117);
            
            const e = Math.sqrt(f * (2 - f));
            const e2 = e * e;
            const N = a / Math.sqrt(1 - e2 * Math.sin(latRad) * Math.sin(latRad));
            const T = Math.tan(latRad) * Math.tan(latRad);
            const C = (e2 / (1 - e2)) * Math.cos(latRad) * Math.cos(latRad);
            const A = Math.cos(latRad) * (lonRad - lonOrigin);
            
            const M = a * ((1 - e2 / 4 - 3 * e2 * e2 / 64 - 5 * e2 * e2 * e2 / 256) * latRad
                - (3 * e2 / 8 + 3 * e2 * e2 / 32 + 45 * e2 * e2 * e2 / 1024) * Math.sin(2 * latRad)
                + (15 * e2 * e2 / 256 + 45 * e2 * e2 * e2 / 1024) * Math.sin(4 * latRad)
                - (35 * e2 * e2 * e2 / 3072) * Math.sin(6 * latRad));
            
            const easting = 500000 + k0 * N * (A + (1 - T + C) * A * A * A / 6
                + (5 - 18 * T + T * T + 72 * C - 58 * (e2 / (1 - e2))) * A * A * A * A * A / 120);
            
            const northing = 10000000 + k0 * (M + N * Math.tan(latRad) * (A * A / 2
                + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24
                + (61 - 58 * T + T * T + 600 * C - 330 * (e2 / (1 - e2))) * A * A * A * A * A * A / 720));
            
            return { easting, northing };
        }

        function toDegrees(rad) { return rad * 180 / Math.PI; }
        function toRadians(deg) { return deg * Math.PI / 180; }

        // ===== UTILITY FUNCTIONS =====
        function updateDataInfo() {
            document.getElementById('dataInfo').innerHTML = 
                `Loaded ${boreholeData.length} boreholes<br>Time series: ${maxDays} days`;
            updateSoilColorPalette();
        }

        function updateSoilColorPalette() {
            const palette = document.getElementById('soilColorPalette');
            if (!palette) return;

            palette.innerHTML = '';
            const soilTypes = new Set();
            boreholeData.forEach(bh => {
                bh.units.forEach(unit => {
                    if (unit.name && unit.name !== '-') {
                        soilTypes.add(unit.name);
                    }
                });
            });

            if (!soilTypes.has('-')) soilTypes.add('-');

            Array.from(soilTypes).sort().forEach(soilType => {
                const color = soilColors[soilType] || '#cccccc';
                const div = document.createElement('div');
                div.style.cssText = 'display: flex; align-items: center; gap: 5px; padding: 3px; cursor: pointer; border-radius: 3px;';
                div.innerHTML = `
                    <input type="color" value="${color}" onchange="updateSoilColor('${soilType}', this.value)" 
                           style="width: 30px; height: 20px; border: none; cursor: pointer;">
                    <span style="flex: 1;">${soilType}</span>
                `;
                palette.appendChild(div);
            });
        }

        function updateSoilColor(soilType, newColor) {
            soilColors[soilType] = newColor;
            sections.forEach(section => generateCrossSection(section.id));
            render3D();
        }

        function plotOnMap() {
            if (!map) return;
            markers.forEach(m => map.removeLayer(m));
            markers = [];
            if (boreholeData.length === 0) return;

            const group = new L.featureGroup();
            boreholeData.forEach(bh => {
                const marker = L.circleMarker([bh.lat, bh.lng], {
                    radius: 8,
                    fillColor: '#f00',
                    color: '#fff',
                    weight: 2,
                    fillOpacity: 0.8
                }).addTo(map);
                marker.bindPopup(`<b>${bh.name}</b><br>Ground: ${bh.groundLevel}m<br>Depth: ${bh.depth}m`);
                markers.push(marker);
                group.addLayer(marker);
            });

            if (group.getLayers().length > 0) {
                map.fitBounds(group.getBounds());
                if (isopachMap) isopachMap.fitBounds(group.getBounds());
            }
            
            sections.forEach(section => {
                const checkbox = document.getElementById(`showSectionLine${section.id}`);
                if (checkbox && checkbox.checked) {
                    addSectionLine(section.id);
                }
            });
        }

        function loadSampleData() {
            document.getElementById('startDate').value = '2025-01-01';
            document.getElementById('dataInput').value = `BH01 392329.129 6463706.281 6.43 10 3.3 coreloss 1.7 SAND 8.6 sandyCLAY 10 3.155426096 3.194607543 3.224040775 3.215131498
BH02 392288.038 6463724.634 6.76 10 2.8 coreloss 2 coreloss 4 coreloss 10 4.200669725 4.222033639 4.251707441 4.232715596
BH03 392259.899 6463735.424 6.92 10 2.2 coreloss 2 coreloss 4 coreloss 10 5.104385321 5.143655454 5.178083588 5.160407747
BH04 392227.653 6463742.08 6.42 10 4.8 coreloss 2 CLAY 6.7 sandyCLAY 10 1.645785933 1.646897044 1.661186544 1.656876656
BH05 392198.218 6463726.259 4.28 10 3.1 coreloss 2 coreloss 4 coreloss 10 -0.321633028 -0.303363914 -0.294126402 -0.289303772
BH06 392225.565 6463678.997 2.35 10 2.3 coreloss 2.6 sandyCLAY 7.2 clayeySAND 10 0.438261978 0.453219164 0.470201835 0.467030581
BH07 392239.332 6463669.223 2.26 10 2 coreloss 3.8 sandyCLAY 7.5 clayeySAND 10 0.648009174 0.666192661 0.708802243 0.669892966
BH08 392276.386 6463657.653 2.22 10 2.2 coreloss 4.7 sandyCLAY 7.2 clayeySAND 10 0.363794088 0.38508053 0.404122324 0.396281346`;
            parseData();
        }

        function clearData() {
            document.getElementById('dataInput').value = '';
            document.getElementById('startDate').value = '';
            startDate = null;
            boreholeData = [];
            currentDay = 1;
            maxDays = 1;
            sections = [];
            nextSectionId = 1;
            krigingGrid = null;
            globalMinGW = null;
            globalMaxGW = null;
            cameraRadius = 30;
            cameraTheta = 0;
            cameraPhi = Math.PI / 4;
            cameraTarget = null;
            verticalExaggeration = 1.0;
            threeScene = null;
            threeCamera = null;
            threeRenderer = null;
            document.getElementById('verticalExaggeration').value = 1;
            document.getElementById('vertExagValue').textContent = '1.0x';
            updateTimeControls();
            updateDataInfo();
            if (map) {
                markers.forEach(m => map.removeLayer(m));
                markers = [];
                Object.values(sectionLines).forEach(line => map.removeLayer(line));
                sectionLines = {};
            }
            if (isopachMap) {
                isopachMap.eachLayer(layer => {
                    if (!(layer instanceof L.TileLayer)) isopachMap.removeLayer(layer);
                });
            }
            document.getElementById('sectionsContainer').innerHTML = '';
            document.getElementById('legend').innerHTML = '';
            document.getElementById('sectionLineControls').innerHTML = '';
            document.getElementById('isopachLegend').innerHTML = '';
            document.getElementById('threeContainer').innerHTML = '';
        }

        // ===== HTML EXPORT FOR PRINTING =====
        async function exportAllDaysHTML() {
            if (boreholeData.length === 0) {
                alert('Please load data first!');
                return;
            }

            const progressDiv = document.getElementById('exportProgress');
            
            if (maxDays > 50) {
                const proceed = confirm(`You have ${maxDays} days to export.\n\nThis will be automatically split into ${Math.ceil(maxDays / 50)} separate HTML files (50 days each).\n\nContinue?`);
                if (!proceed) return;
                
                await exportSplitHTML();
                return;
            }
            
            progressDiv.textContent = '‚è≥ Generating HTML for printing...';
            
            try {
                await exportDaysRange(1, maxDays);
                
                progressDiv.textContent = `‚úì Exported ${maxDays} days! Open the file and press Ctrl+P to print to PDF.`;
                setTimeout(() => {
                    progressDiv.textContent = '';
                }, 5000);
            } catch (error) {
                console.error('HTML export error:', error);
                alert('HTML export failed: ' + error.message);
                progressDiv.textContent = '';
            }
        }

        async function exportSplitHTML() {
            if (boreholeData.length === 0) {
                alert('Please load data first!');
                return;
            }

            const progressDiv = document.getElementById('exportProgress');
            const daysPerFile = 50;
            const numFiles = Math.ceil(maxDays / daysPerFile);
            
            progressDiv.textContent = `‚è≥ Creating ${numFiles} HTML files...`;

            try {
                for (let fileNum = 0; fileNum < numFiles; fileNum++) {
                    const startDay = fileNum * daysPerFile + 1;
                    const endDay = Math.min((fileNum + 1) * daysPerFile, maxDays);
                    
                    progressDiv.textContent = `‚è≥ Creating file ${fileNum + 1} of ${numFiles} (Days ${startDay}-${endDay})...`;
                    
                    await exportDaysRange(startDay, endDay, fileNum + 1, numFiles);
                    await new Promise(resolve => setTimeout(resolve, 300));
                }

                progressDiv.textContent = `‚úì Successfully exported ${numFiles} HTML files covering ${maxDays} days!`;
                setTimeout(() => {
                    progressDiv.textContent = '';
                }, 4000);

            } catch (error) {
                console.error('HTML export error:', error);
                alert('HTML export failed: ' + error.message);
                progressDiv.textContent = '';
            }
        }

        async function exportDaysRange(startDay, endDay, fileNumber = 1, totalFiles = 1) {
            const originalDay = currentDay;
            const pages = [];

            for (let day = startDay; day <= endDay; day++) {
                const progress = day - startDay + 1;
                const total = endDay - startDay + 1;
                document.getElementById('exportProgress').textContent = `‚è≥ Capturing Day ${day} (${progress}/${total})...`;
                
                currentDay = day;
                updateTimeControls();
                sections.forEach(section => generateCrossSection(section.id));
                updateIsopachMap();
                render3D();

                await new Promise(resolve => setTimeout(resolve, 800));

                // Capture map with section lines
                const mapCanvas = await captureMapWithSections();
                
                // Capture cross sections
                const sectionImages = [];
                for (let i = 0; i < Math.min(4, sections.length); i++) {
                    const section = sections[i];
                    const canvas = document.getElementById(`crossSection${section.id}`);
                    if (canvas) {
                        sectionImages.push({
                            name: section.name,
                            color: section.color,
                            image: canvas.toDataURL('image/png')
                        });
                    }
                }

                // Capture 3D view
                const webglCanvas = document.querySelector('#threeContainer canvas');
                const img3D = webglCanvas ? webglCanvas.toDataURL('image/png') : null;

                // Capture isopach map
                const isopachImg = await captureIsopachMap();

                const dateStr = getDateForDay(day);
                pages.push({
                    day: day,
                    date: dateStr,
                    mapImage: mapCanvas,
                    sections: sectionImages,
                    img3D: img3D,
                    imgIsopach: isopachImg,
                    ve: verticalExaggeration.toFixed(1),
                    contourInterval: contourInterval
                });
            }

            currentDay = originalDay;
            updateTimeControls();
            sections.forEach(section => generateCrossSection(section.id));
            updateIsopachMap();
            render3D();

            const html = generatePrintHTML(pages, startDay, endDay, fileNumber, totalFiles);

            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            
            const filename = totalFiles > 1 
                ? `GW_Report_Part${fileNumber}_Days${startDay}-${endDay}.html`
                : `GW_Report_All_Days.html`;
            
            link.href = url;
            link.download = filename;
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();

            setTimeout(() => {
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }, 100);
        }

        async function captureMapWithSections() {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                canvas.width = map.getSize().x * 2;
                canvas.height = map.getSize().y * 2;
                const ctx = canvas.getContext('2d');
                ctx.scale(2, 2);

                // Fill background
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Get map tiles
                const tilePane = document.querySelector('#map .leaflet-tile-pane');
                if (tilePane) {
                    const tiles = tilePane.querySelectorAll('img.leaflet-tile');
                    const transform = tilePane.style.transform || tilePane.style.webkitTransform;
                    let offsetX = 0, offsetY = 0;
                    
                    if (transform) {
                        const match = transform.match(/translate3d\(([^,]+)px,\s*([^,]+)px/);
                        if (match) {
                            offsetX = parseFloat(match[1]);
                            offsetY = parseFloat(match[2]);
                        }
                    }
                    
                    tiles.forEach(tile => {
                        if (!tile.complete || tile.naturalWidth === 0) return;
                        try {
                            const tileStyle = tile.style.transform || tile.style.webkitTransform;
                            let tileX = 0, tileY = 0;
                            if (tileStyle) {
                                const tileMatch = tileStyle.match(/translate3d\(([^,]+)px,\s*([^,]+)px/);
                                if (tileMatch) {
                                    tileX = parseFloat(tileMatch[1]);
                                    tileY = parseFloat(tileMatch[2]);
                                }
                            }
                            ctx.drawImage(tile, offsetX + tileX, offsetY + tileY, tile.width, tile.height);
                        } catch (e) {
                            console.warn('Failed to draw tile:', e);
                        }
                    });
                }

                // Draw section lines using Leaflet's coordinate system
                sections.forEach(section => {
                    if (sectionLines[section.id] && map.hasLayer(sectionLines[section.id])) {
                        const line = sectionLines[section.id];
                        const latLngs = line.getLatLngs();
                        
                        if (latLngs.length >= 2) {
                            ctx.strokeStyle = section.color;
                            ctx.lineWidth = 3;
                            ctx.setLineDash([10, 5]);
                            ctx.beginPath();
                            
                            latLngs.forEach((latLng, i) => {
                                const point = map.latLngToContainerPoint(latLng);
                                if (i === 0) {
                                    ctx.moveTo(point.x, point.y);
                                } else {
                                    ctx.lineTo(point.x, point.y);
                                }
                            });
                            
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                    }
                });

                // Draw borehole markers using Leaflet's coordinate system
                boreholeData.forEach(bh => {
                    const point = map.latLngToContainerPoint([bh.lat, bh.lng]);
                    
                    // Draw red circle
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // White border
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw label
                    ctx.fillStyle = '#000000';
                    ctx.font = 'bold 11px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(bh.name, point.x, point.y - 12);
                });

                setTimeout(() => resolve(canvas.toDataURL('image/png')), 100);
            });
        }

        async function captureIsopachMap() {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                canvas.width = isopachMap.getSize().x * 2;
                canvas.height = isopachMap.getSize().y * 2;
                const ctx = canvas.getContext('2d');
                ctx.scale(2, 2);

                // Fill background
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Get map tiles
                const tilePane = document.querySelector('#isopachMap .leaflet-tile-pane');
                if (tilePane) {
                    const tiles = tilePane.querySelectorAll('img.leaflet-tile');
                    const transform = tilePane.style.transform || tilePane.style.webkitTransform;
                    let offsetX = 0, offsetY = 0;
                    
                    if (transform) {
                        const match = transform.match(/translate3d\(([^,]+)px,\s*([^,]+)px/);
                        if (match) {
                            offsetX = parseFloat(match[1]);
                            offsetY = parseFloat(match[2]);
                        }
                    }
                    
                    tiles.forEach(tile => {
                        if (!tile.complete || tile.naturalWidth === 0) return;
                        try {
                            const tileStyle = tile.style.transform || tile.style.webkitTransform;
                            let tileX = 0, tileY = 0;
                            if (tileStyle) {
                                const tileMatch = tileStyle.match(/translate3d\(([^,]+)px,\s*([^,]+)px/);
                                if (tileMatch) {
                                    tileX = parseFloat(tileMatch[1]);
                                    tileY = parseFloat(tileMatch[2]);
                                }
                            }
                            ctx.drawImage(tile, offsetX + tileX, offsetY + tileY, tile.width, tile.height);
                        } catch (e) {
                            console.warn('Failed to draw tile:', e);
                        }
                    });
                }

                // Draw heatmap from kriging grid
                if (krigingGrid && document.getElementById('showHeatmap').checked) {
                    const { grid, bounds, resolution, dx, dy } = krigingGrid;
                    const { minX, maxX, minY, maxY } = bounds;
                    
                    const colorScaleMin = globalMinGW !== null ? globalMinGW : Math.min(...grid.flat());
                    const colorScaleMax = globalMaxGW !== null ? globalMaxGW : Math.max(...grid.flat());
                    
                    ctx.globalAlpha = 0.6;
                    
                    for (let i = 0; i <= resolution; i++) {
                        for (let j = 0; j <= resolution; j++) {
                            const value = grid[i][j];
                            if (value === null || value === undefined || isNaN(value)) continue;
                            
                            const norm = (value - colorScaleMin) / (colorScaleMax - colorScaleMin);
                            const color = getColorForValue(norm);
                            
                            const x = minX + j * dx;
                            const y = minY + i * dy;
                            const ll = utmToLatLng(x, y, 50, 'S');
                            
                            const x2 = minX + (j + 1) * dx;
                            const y2 = minY + (i + 1) * dy;
                            const ll2 = utmToLatLng(x2, y2, 50, 'S');
                            
                            const point1 = isopachMap.latLngToContainerPoint([ll.lat, ll.lng]);
                            const point2 = isopachMap.latLngToContainerPoint([ll2.lat, ll2.lng]);
                            
                            const cellWidth = Math.abs(point2.x - point1.x);
                            const cellHeight = Math.abs(point2.y - point1.y);
                            
                            ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                            ctx.fillRect(point1.x, point1.y, cellWidth, cellHeight);
                        }
                    }
                    
                    ctx.globalAlpha = 1.0;
                }

                // Draw contours using Leaflet's coordinate system
                if (krigingGrid && document.getElementById('showContours').checked) {
                    const { grid, bounds, resolution, dx, dy } = krigingGrid;
                    const allValues = grid.flat();
                    const minValue = Math.min(...allValues);
                    const maxValue = Math.max(...allValues);
                    
                    const levels = [];
                    for (let level = Math.ceil(minValue / contourInterval) * contourInterval; level <= maxValue; level += contourInterval) {
                        levels.push(level);
                    }

                    ctx.strokeStyle = '#0066cc';
                    ctx.lineWidth = 2.5;
                    
                    levels.forEach((level, levelIdx) => {
                        const contours = marchingSquares(grid, level, resolution);
                        const shouldLabel = levelIdx % 2 === 0;
                        let rightmostPoint = null;
                        let maxX = -Infinity;

                        contours.forEach(contour => {
                            if (contour.length < 2) return;
                            
                            ctx.beginPath();
                            contour.forEach((p, i) => {
                                const x = bounds.minX + p.x * dx;
                                const y = bounds.minY + p.y * dy;
                                const ll = utmToLatLng(x, y, 50, 'S');
                                const point = isopachMap.latLngToContainerPoint([ll.lat, ll.lng]);
                                
                                if (i === 0) {
                                    ctx.moveTo(point.x, point.y);
                                } else {
                                    ctx.lineTo(point.x, point.y);
                                }
                                
                                if (shouldLabel && point.x > maxX) {
                                    maxX = point.x;
                                    rightmostPoint = point;
                                }
                            });
                            ctx.stroke();
                        });
                        
                        // Draw label
                        if (shouldLabel && rightmostPoint) {
                            const labelText = level.toFixed(2);
                            ctx.font = 'bold 11px Arial';
                            ctx.textAlign = 'left';
                            ctx.textBaseline = 'middle';
                            const textWidth = ctx.measureText(labelText).width;
                            
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                            ctx.fillRect(rightmostPoint.x + 5, rightmostPoint.y - 7, textWidth + 6, 14);
                            
                            ctx.strokeStyle = '#0066cc';
                            ctx.lineWidth = 1.5;
                            ctx.strokeRect(rightmostPoint.x + 5, rightmostPoint.y - 7, textWidth + 6, 14);
                            
                            ctx.fillStyle = '#0066cc';
                            ctx.fillText(labelText, rightmostPoint.x + 8, rightmostPoint.y);
                            
                            ctx.strokeStyle = '#0066cc';
                            ctx.lineWidth = 2.5;
                        }
                    });
                }

                // Draw borehole markers using Leaflet's coordinate system
                boreholeData.forEach(bh => {
                    const point = isopachMap.latLngToContainerPoint([bh.lat, bh.lng]);
                    
                    // Draw white circle with black border
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });

                setTimeout(() => resolve(canvas.toDataURL('image/png')), 100);
            });
        }

        function generatePrintHTML(pages, startDay, endDay, fileNumber, totalFiles) {
            const pagesHTML = pages.map(page => `
                <div class="page">
                    <div class="page-header">
                        <h1>Borehole Groundwater Visualization - Day ${page.day}${page.date !== '-' ? ' (' + page.date + ')' : ''}</h1>
                    </div>
                    
                    <div class="page-content">
                        <div class="left-column">
                            <div class="map-container">
                                <h2>Borehole Map with Section Lines</h2>
                                <img src="${page.mapImage}" alt="Map with sections">
                            </div>
                            
                            <div class="sections-container">
                                <h2>Cross Sections</h2>
                                <div class="sections-grid-print">
${page.sections.map(section => `
                                    <div class="section-print">
                                        <div class="section-title-print" style="background: ${section.color}20; color: ${section.color};">
                                            ${section.name}
                                        </div>
                                        <img src="${section.image}" alt="${section.name}">
                                    </div>
`).join('')}
                                </div>
                            </div>
                        </div>
                        
                        <div class="right-column">
                            <div class="viz-container">
                                <h2>3D View with GW Surface (VE=${page.ve}x)</h2>
                                <img src="${page.img3D}" alt="3D View">
                            </div>
                            
                            <div class="viz-container">
                                <h2>Groundwater Isopach Map (Kriging)</h2>
                                <img src="${page.imgIsopach}" alt="Isopach Map">
                                <p class="contour-note">Contour Interval: ${page.contourInterval}m</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="page-footer">
                        <div class="legend-footer">
                            <strong>Legend:</strong> Blue solid line = Current day | Blue dashed line = Previous day
                        </div>
                        <div class="page-number">
                            ${totalFiles > 1 ? `Part ${fileNumber} | ` : ''}Page ${page.day - startDay + 1} of ${endDay - startDay + 1} | Day ${page.day} of ${maxDays}
                        </div>
                    </div>
                </div>
            `).join('');

            return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Borehole Groundwater Report - Days ${startDay}-${endDay}</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: white;
            color: #333;
        }
        
        @media screen {
            body {
                background: #f5f5f5;
                padding: 20px;
            }
            
            .print-instructions {
                max-width: 420mm;
                margin: 0 auto 20px auto;
                padding: 20px;
                background: #fff3cd;
                border: 2px solid #ffc107;
                border-radius: 8px;
                text-align: center;
            }
            
            .print-instructions h2 {
                color: #856404;
                margin-bottom: 10px;
            }
            
            .print-instructions p {
                color: #856404;
                font-size: 14px;
                margin: 5px 0;
            }
        }
        
        @media print {
            .print-instructions {
                display: none;
            }
            
            body {
                background: white;
                padding: 0;
            }
            
            .page {
                margin: 0;
                box-shadow: none;
                width: 100%;
                height: 100vh;
            }
        }
        
        .page {
            width: 420mm;
            height: 297mm;
            margin: 0 auto 20mm auto;
            background: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            page-break-after: always;
            page-break-inside: avoid;
        }
        
        .page:last-child {
            page-break-after: auto;
        }
        
        .page-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 25px;
            text-align: center;
        }
        
        .page-header h1 {
            font-size: 24px;
            margin: 0;
        }
        
        .page-content {
            flex: 1;
            display: flex;
            gap: 20px;
            padding: 20px;
            overflow: hidden;
        }
        
        .left-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .right-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .map-container {
            flex: 0 0 auto;
        }
        
        .map-container h2 {
            font-size: 16px;
            margin-bottom: 8px;
            color: #667eea;
        }
        
        .map-container img {
            width: 100%;
            height: auto;
            max-height: 200px;
            object-fit: contain;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .sections-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .sections-container h2 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #667eea;
        }
        
        .sections-grid-print {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            flex: 1;
        }
        
        .section-print {
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .section-title-print {
            padding: 5px 10px;
            font-weight: bold;
            font-size: 13px;
            text-align: center;
        }
        
        .section-print img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        .viz-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            overflow: hidden;
        }
        
        .viz-container h2 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #28a745;
        }
        
        .viz-container:last-child h2 {
            color: #0066cc;
        }
        
        .viz-container img {
            flex: 1;
            width: 100%;
            height: 100%;
            object-fit: contain;
            border: 1px solid #eee;
            border-radius: 3px;
        }
        
        .contour-note {
            font-size: 11px;
            color: #0066cc;
            font-weight: bold;
            margin-top: 5px;
            text-align: center;
        }
        
        .page-footer {
            background: #f8f9fa;
            padding: 10px 25px;
            border-top: 2px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }
        
        .legend-footer {
            color: #666;
        }
        
        .page-number {
            color: #999;
            font-weight: bold;
        }
        
        @page {
            size: A3 landscape;
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="print-instructions">
        <h2>üìÑ Ready to Print to PDF</h2>
        <p><strong>Chrome/Edge:</strong> Press Ctrl+P (or Cmd+P on Mac) ‚Üí Destination: "Save as PDF" ‚Üí Click Save</p>
        <p><strong>Settings:</strong> Landscape orientation, <strong>A3 size</strong> (or "Fit to page" if A3 not available), no margins</p>
        <p><strong>Total Pages:</strong> ${endDay - startDay + 1} (one page per day)</p>
        ${totalFiles > 1 ? `<p style="color: #d39e00;"><strong>Note:</strong> This is Part ${fileNumber} of ${totalFiles}</p>` : ''}
    </div>

${pagesHTML}

</body>
</html>`;
        }

        window.onload = function() {
            initMap();
            updateTimeControls();
        };
    </script>

</body>
</html>